"""
Immobilien-Transaktionsplattform
Rollen: Makler, K√§ufer, Verk√§ufer, Finanzierer, Notar
Erweiterte Version mit Timeline, OCR, Benachrichtigungen, etc.
Responsive Design f√ºr Mobile, Tablet und Desktop
"""

import streamlit as st
from datetime import datetime, date, timedelta
from typing import Dict, List, Optional, Any, Tuple
import json
import io
from dataclasses import dataclass, field, asdict
from enum import Enum
import hashlib
import re
import base64
import uuid

# Datenbank-Integration
try:
    from database import (
        init_database,
        check_database_connection,
        health_check as db_health_check,
        track_interaktion,
        get_interaktionen_stats,
        InteraktionsTyp as DBInteraktionsTyp,
    )
    DATABASE_AVAILABLE = True
except ImportError:
    DATABASE_AVAILABLE = False


def safe_track_interaktion(
    interaktions_typ: str,
    details: dict = None,
    nutzer_id: str = None,
    projekt_id: str = None,
    immobilien_id: str = None
):
    """
    Sicher Interaktionen tracken - nur wenn DB verf√ºgbar und verbunden.

    Args:
        interaktions_typ: Typ der Interaktion (z.B. 'login', 'dokument_upload')
        details: Zus√§tzliche Details als Dictionary
        nutzer_id: ID des Nutzers (falls nicht aus session_state)
        projekt_id: ID des Projekts (optional)
        immobilien_id: ID der Immobilie (optional)
    """
    if not DATABASE_AVAILABLE:
        return None

    if not st.session_state.get('database_connected', False):
        return None

    try:
        # Nutzer-ID aus Session State holen falls nicht √ºbergeben
        if nutzer_id is None and st.session_state.get('current_user'):
            user = st.session_state.current_user
            nutzer_id = getattr(user, 'user_id', None)

        # Interaktion tracken
        return track_interaktion(
            nutzer_id=nutzer_id,
            projekt_id=projekt_id,
            immobilien_id=immobilien_id,
            interaktions_typ=interaktions_typ,
            details=details or {}
        )
    except Exception as e:
        # Fehler beim Tracking sollten die App nicht crashen
        print(f"Tracking-Fehler: {e}")
        return None


# ============================================================================
# DATENBANK-KONFIGURATION FUNKTIONEN
# ============================================================================

def test_database_connection(db_url: str) -> dict:
    """
    Testet die Datenbankverbindung mit der gegebenen URL.

    Args:
        db_url: SQLAlchemy-kompatible Datenbank-URL

    Returns:
        Dictionary mit 'success', 'error' (bei Fehler), 'server_info'
    """
    try:
        from sqlalchemy import create_engine, text
        import os

        # F√ºr SQLite: Verzeichnis erstellen falls n√∂tig
        if db_url.startswith('sqlite:///'):
            db_path = db_url.replace('sqlite:///', '')
            db_dir = os.path.dirname(db_path)
            if db_dir and not os.path.exists(db_dir):
                os.makedirs(db_dir, exist_ok=True)

        # Engine erstellen mit Timeout
        engine = create_engine(db_url, pool_pre_ping=True, pool_timeout=5)

        # Verbindung testen
        with engine.connect() as conn:
            if db_url.startswith('sqlite'):
                result = conn.execute(text("SELECT sqlite_version()"))
                version = result.scalar()
                server_info = f"SQLite {version}"
            elif 'postgresql' in db_url:
                result = conn.execute(text("SELECT version()"))
                version = result.scalar()
                server_info = version.split(',')[0] if version else "PostgreSQL"
            elif 'mysql' in db_url:
                result = conn.execute(text("SELECT VERSION()"))
                version = result.scalar()
                server_info = f"MySQL {version}"
            else:
                server_info = "Verbunden"

        engine.dispose()
        return {'success': True, 'server_info': server_info}

    except ImportError as e:
        return {'success': False, 'error': f"Fehlende Pakete: {e}. Installieren Sie sqlalchemy und ggf. psycopg2-binary oder pymysql."}
    except Exception as e:
        return {'success': False, 'error': str(e)}


def save_database_config(config: dict) -> bool:
    """
    Speichert die Datenbank-Konfiguration in .streamlit/secrets.toml

    Args:
        config: Dictionary mit Datenbank-Konfiguration

    Returns:
        True bei Erfolg
    """
    import os

    secrets_dir = ".streamlit"
    secrets_file = os.path.join(secrets_dir, "secrets.toml")

    # Verzeichnis erstellen falls n√∂tig
    if not os.path.exists(secrets_dir):
        os.makedirs(secrets_dir)

    # Bestehende Secrets laden falls vorhanden
    existing_content = ""
    if os.path.exists(secrets_file):
        with open(secrets_file, 'r') as f:
            existing_content = f.read()

    # [database] Sektion erstellen
    db_type = config.get('db_type', 'sqlite')

    if db_type == 'sqlite':
        db_url = f"sqlite:///{config.get('sqlite_path', 'data/immobilien_plattform.db')}"
    elif db_type == 'postgresql':
        db_url = f"postgresql://{config.get('username', '')}:{config.get('password', '')}@{config.get('host', 'localhost')}:{config.get('port', 5432)}/{config.get('database', 'immobilien_plattform')}"
    else:
        db_url = f"mysql+pymysql://{config.get('username', '')}:{config.get('password', '')}@{config.get('host', 'localhost')}:{config.get('port', 3306)}/{config.get('database', 'immobilien_plattform')}"

    db_section = f'''
[database]
type = "{db_type}"
url = "{db_url}"
auto_load = {str(config.get('auto_load', False)).lower()}
'''

    # Alte [database] Sektion entfernen falls vorhanden
    import re
    existing_content = re.sub(r'\[database\].*?(?=\n\[|\Z)', '', existing_content, flags=re.DOTALL)
    existing_content = existing_content.strip()

    # Neue Sektion anh√§ngen
    new_content = existing_content + "\n" + db_section if existing_content else db_section.strip()

    with open(secrets_file, 'w') as f:
        f.write(new_content)

    return True


def initialize_database_tables(db_url: str) -> dict:
    """
    Erstellt alle Datenbanktabellen basierend auf den SQLAlchemy-Modellen.

    Args:
        db_url: SQLAlchemy-kompatible Datenbank-URL

    Returns:
        Dictionary mit 'success', 'tables_created', 'error'
    """
    try:
        from sqlalchemy import create_engine, inspect
        import os

        # F√ºr SQLite: Verzeichnis erstellen falls n√∂tig
        if db_url.startswith('sqlite:///'):
            db_path = db_url.replace('sqlite:///', '')
            db_dir = os.path.dirname(db_path)
            if db_dir and not os.path.exists(db_dir):
                os.makedirs(db_dir, exist_ok=True)

        engine = create_engine(db_url)

        # Pr√ºfe welche Tabellen bereits existieren
        inspector = inspect(engine)
        existing_tables = set(inspector.get_table_names())

        # Importiere das Base-Model und erstelle Tabellen
        if DATABASE_AVAILABLE:
            from database import Base
            Base.metadata.create_all(engine)

            # Neue Tabellen z√§hlen
            new_tables = set(inspector.get_table_names())
            created_count = len(new_tables - existing_tables)
            total_count = len(new_tables)

            engine.dispose()
            return {
                'success': True,
                'tables_created': created_count,
                'total_tables': total_count
            }
        else:
            return {'success': False, 'error': 'Datenbank-Modul nicht verf√ºgbar'}

    except Exception as e:
        return {'success': False, 'error': str(e)}


def migrate_session_to_database(items: list) -> dict:
    """
    Migriert ausgew√§hlte Daten vom Session State in die Datenbank.

    Args:
        items: Liste der zu migrierenden Datentypen

    Returns:
        Dictionary mit 'success', 'migrated_count', 'error'
    """
    if not DATABASE_AVAILABLE:
        return {'success': False, 'error': 'Datenbank-Modul nicht verf√ºgbar'}

    db_url = st.session_state.get('db_connection_url')
    if not db_url:
        return {'success': False, 'error': 'Keine Datenbankverbindung konfiguriert'}

    try:
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
        from database import Base, Nutzer, Projekt, Dokument, Akte, Preisvorschlag, Benachrichtigung

        engine = create_engine(db_url)
        Session = sessionmaker(bind=engine)
        session = Session()

        migrated_count = 0

        # Nutzer migrieren
        if "Nutzer" in items:
            for user_id, user in st.session_state.get('users', {}).items():
                existing = session.query(Nutzer).filter_by(user_id=user_id).first()
                if not existing:
                    db_nutzer = Nutzer(
                        user_id=user.user_id,
                        email=user.email,
                        password_hash=user.password_hash,
                        name=user.name,
                        rolle=user.rolle,
                        telefon=getattr(user, 'telefon', ''),
                        adresse=getattr(user, 'adresse', ''),
                        onboarding_complete=getattr(user, 'onboarding_complete', False)
                    )
                    session.add(db_nutzer)
                    migrated_count += 1

        # Projekte migrieren
        if "Projekte" in items:
            for projekt_id, projekt in st.session_state.get('projekte', {}).items():
                existing = session.query(Projekt).filter_by(projekt_id=projekt_id).first()
                if not existing:
                    db_projekt = Projekt(
                        projekt_id=projekt.projekt_id,
                        name=projekt.name,
                        beschreibung=getattr(projekt, 'beschreibung', ''),
                        adresse=getattr(projekt, 'adresse', ''),
                        kaufpreis=getattr(projekt, 'kaufpreis', 0),
                        status=getattr(projekt, 'status', 'aktiv'),
                        makler_id=getattr(projekt, 'makler_id', None),
                        notar_id=getattr(projekt, 'notar_id', None)
                    )
                    session.add(db_projekt)
                    migrated_count += 1

        # Akten migrieren
        if "Akten" in items:
            for akte_id, akte in st.session_state.get('akten', {}).items():
                existing = session.query(Akte).filter_by(akte_id=akte_id).first()
                if not existing:
                    db_akte = Akte(
                        akte_id=akte.akte_id,
                        notar_id=akte.notar_id,
                        aktenzeichen=akte.aktenzeichen,
                        aktennummer=akte.aktennummer,
                        aktenjahr=akte.aktenjahr,
                        hauptbereich=akte.hauptbereich,
                        untertyp=akte.untertyp,
                        betreff=getattr(akte, 'betreff', ''),
                        status=getattr(akte, 'status', 'offen')
                    )
                    session.add(db_akte)
                    migrated_count += 1

        session.commit()
        session.close()
        engine.dispose()

        return {'success': True, 'migrated_count': migrated_count}

    except Exception as e:
        return {'success': False, 'error': str(e)}


def load_database_to_session() -> dict:
    """
    L√§dt Daten aus der Datenbank in den Session State.

    Returns:
        Dictionary mit 'success', 'loaded_count', 'error'
    """
    if not DATABASE_AVAILABLE:
        return {'success': False, 'error': 'Datenbank-Modul nicht verf√ºgbar'}

    db_url = st.session_state.get('db_connection_url')
    if not db_url:
        return {'success': False, 'error': 'Keine Datenbankverbindung konfiguriert'}

    try:
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
        from database import Nutzer, Projekt, Akte

        engine = create_engine(db_url)
        Session = sessionmaker(bind=engine)
        session = Session()

        loaded_count = 0

        # Nutzer laden
        db_users = session.query(Nutzer).all()
        for db_user in db_users:
            # In Session State User-Objekt konvertieren
            user = User(
                user_id=db_user.user_id,
                email=db_user.email,
                password_hash=db_user.password_hash,
                name=db_user.name,
                rolle=db_user.rolle,
                telefon=db_user.telefon or '',
                adresse=db_user.adresse or '',
                onboarding_complete=db_user.onboarding_complete or False
            )
            st.session_state.users[db_user.user_id] = user
            loaded_count += 1

        # Projekte laden
        db_projekte = session.query(Projekt).all()
        for db_projekt in db_projekte:
            projekt = ProjektData(
                projekt_id=db_projekt.projekt_id,
                name=db_projekt.name,
                beschreibung=db_projekt.beschreibung or '',
                adresse=db_projekt.adresse or '',
                kaufpreis=float(db_projekt.kaufpreis) if db_projekt.kaufpreis else 0,
                status=db_projekt.status or 'aktiv',
                makler_id=db_projekt.makler_id,
                notar_id=db_projekt.notar_id
            )
            st.session_state.projekte[db_projekt.projekt_id] = projekt
            loaded_count += 1

        session.close()
        engine.dispose()

        return {'success': True, 'loaded_count': loaded_count}

    except Exception as e:
        return {'success': False, 'error': str(e)}


def load_database_config_on_startup():
    """
    L√§dt die Datenbank-Konfiguration aus secrets.toml beim Start.
    Wird in der main() Funktion aufgerufen.
    """
    import os

    try:
        # Pr√ºfe ob secrets.toml existiert
        if hasattr(st, 'secrets') and 'database' in st.secrets:
            db_config = st.secrets['database']
            db_url = db_config.get('url', '')
            db_type = db_config.get('type', 'sqlite')
            auto_load = db_config.get('auto_load', False)

            if db_url:
                # Konfiguration in Session State speichern
                st.session_state.db_config = {
                    'db_type': db_type,
                    'auto_load': auto_load
                }
                st.session_state.db_connection_url = db_url

                # Verbindung testen
                result = test_database_connection(db_url)
                if result['success']:
                    st.session_state.database_connected = True

                    # Auto-Load wenn aktiviert
                    if auto_load:
                        load_database_to_session()
                else:
                    st.session_state.database_connected = False

    except Exception as e:
        print(f"Fehler beim Laden der Datenbank-Konfiguration: {e}")


# ============================================================================
# DEUTSCHE ZAHLENFORMATIERUNG
# ============================================================================

def format_euro(betrag: float, dezimalstellen: int = 2) -> str:
    """
    Formatiert einen Betrag im deutschen Format.
    - Punkt (.) als Tausendertrennzeichen
    - Komma (,) als Dezimaltrennzeichen

    Beispiel: 100000.50 -> "100.000,50"
    """
    if dezimalstellen == 0:
        formatted = f"{betrag:,.0f}"
    else:
        formatted = f"{betrag:,.{dezimalstellen}f}"
    # Konvertiere US-Format zu deutschem Format
    # Erst Komma durch Platzhalter ersetzen, dann Punkt durch Komma, dann Platzhalter durch Punkt
    return formatted.replace(",", "X").replace(".", ",").replace("X", ".")

# ============================================================================
# RESPONSIVE DESIGN SYSTEM
# ============================================================================

class DeviceType(Enum):
    """Ger√§tetypen f√ºr responsive Design"""
    MOBILE = "mobile"      # iPhone, Android Phones (< 768px)
    TABLET = "tablet"      # iPad, Android Tablets (768px - 1024px)
    DESKTOP = "desktop"    # Laptop, Desktop (> 1024px)


def inject_responsive_css():
    """Injiziert modernes responsives CSS f√ºr alle Ger√§tetypen"""
    st.markdown("""
    <style>
    /* ============================================
       MODERNE APP-DESIGN BASIS
       ============================================ */

    /* CSS Variablen f√ºr konsistentes Design */
    :root {
        --primary-color: #2563eb;
        --primary-dark: #1d4ed8;
        --primary-light: #3b82f6;
        --secondary-color: #64748b;
        --success-color: #10b981;
        --warning-color: #f59e0b;
        --error-color: #ef4444;
        --background-color: #f8fafc;
        --card-background: #ffffff;
        --text-primary: #1e293b;
        --text-secondary: #64748b;
        --border-color: #e2e8f0;
        --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        --radius-sm: 0.375rem;
        --radius-md: 0.5rem;
        --radius-lg: 0.75rem;
        --radius-xl: 1rem;
    }

    /* Dark Mode Unterst√ºtzung */
    @media (prefers-color-scheme: dark) {
        :root {
            --background-color: #0f172a;
            --card-background: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border-color: #334155;
        }
    }

    /* Basis-Styling */
    .stApp {
        background-color: var(--background-color);
    }

    /* Modernes Card-Design */
    .modern-card {
        background: var(--card-background);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        padding: 1.5rem;
        margin-bottom: 1rem;
        border: 1px solid var(--border-color);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .modern-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
    }

    /* Moderne Buttons */
    .stButton > button {
        background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
        color: white;
        border: none;
        border-radius: var(--radius-md);
        padding: 0.75rem 1.5rem;
        font-weight: 600;
        transition: all 0.2s ease;
        box-shadow: var(--shadow-sm);
    }

    .stButton > button:hover {
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }

    .stButton > button:active {
        transform: translateY(0);
    }

    /* Moderne Inputs */
    .stTextInput > div > div > input,
    .stSelectbox > div > div > select,
    .stTextArea > div > div > textarea {
        border-radius: var(--radius-md);
        border: 2px solid var(--border-color);
        padding: 0.75rem 1rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .stTextInput > div > div > input:focus,
    .stSelectbox > div > div > select:focus,
    .stTextArea > div > div > textarea:focus {
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    /* Moderne Tabs */
    .stTabs [data-baseweb="tab-list"] {
        gap: 0.5rem;
        background: var(--card-background);
        padding: 0.5rem;
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-sm);
    }

    .stTabs [data-baseweb="tab"] {
        border-radius: var(--radius-md);
        padding: 0.75rem 1rem;
        font-weight: 500;
        transition: all 0.2s ease;
    }

    .stTabs [aria-selected="true"] {
        background: var(--primary-color);
        color: white;
    }

    /* Moderne Expander */
    .streamlit-expanderHeader {
        background: var(--card-background);
        border-radius: var(--radius-md);
        border: 1px solid var(--border-color);
        font-weight: 600;
    }

    /* Status-Badges */
    .status-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.875rem;
        font-weight: 500;
    }

    .status-success {
        background: #d1fae5;
        color: #065f46;
    }

    .status-warning {
        background: #fef3c7;
        color: #92400e;
    }

    .status-error {
        background: #fee2e2;
        color: #991b1b;
    }

    .status-info {
        background: #dbeafe;
        color: #1e40af;
    }

    /* ============================================
       MOBILE STYLES (< 768px)
       ============================================ */
    @media (max-width: 767px) {
        /* Mobile Header */
        .mobile-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: var(--card-background);
            padding: 1rem;
            box-shadow: var(--shadow-md);
            margin: -1rem -1rem 1rem -1rem;
        }

        /* Mobile Navigation */
        .mobile-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--card-background);
            box-shadow: 0 -4px 6px -1px rgb(0 0 0 / 0.1);
            padding: 0.5rem;
            z-index: 1000;
            display: flex;
            justify-content: space-around;
        }

        .mobile-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.75rem;
        }

        .mobile-nav-item.active {
            color: var(--primary-color);
        }

        .mobile-nav-icon {
            font-size: 1.5rem;
            margin-bottom: 0.25rem;
        }

        /* Kompaktere Cards auf Mobile */
        .modern-card {
            padding: 1rem;
            margin-bottom: 0.75rem;
        }

        /* Vollbreite Buttons auf Mobile */
        .stButton > button {
            width: 100%;
            padding: 1rem;
            font-size: 1rem;
        }

        /* Tabs als horizontales Scrolling */
        .stTabs [data-baseweb="tab-list"] {
            overflow-x: auto;
            flex-wrap: nowrap;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        .stTabs [data-baseweb="tab-list"]::-webkit-scrollbar {
            display: none;
        }

        .stTabs [data-baseweb="tab"] {
            white-space: nowrap;
            flex-shrink: 0;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
        }

        /* Gr√∂√üere Touch-Targets */
        .stCheckbox, .stRadio {
            min-height: 44px;
            display: flex;
            align-items: center;
        }

        /* Angepasste Schriftgr√∂√üen */
        h1 { font-size: 1.5rem !important; }
        h2 { font-size: 1.25rem !important; }
        h3 { font-size: 1.1rem !important; }

        /* Sidebar auf Mobile - Streamlit Standard beibehalten */
        [data-testid="stSidebar"] {
            /* Sidebar bleibt nutzbar √ºber Streamlit's eigenes Men√º */
        }

        /* Bottom Padding f√ºr Mobile Navigation */
        .main .block-container {
            padding-bottom: 5rem;
        }
    }

    /* ============================================
       TABLET STYLES (768px - 1024px)
       ============================================ */
    @media (min-width: 768px) and (max-width: 1024px) {
        /* Tablet-optimiertes Grid */
        .tablet-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        /* Mittlere Card-Gr√∂√üe */
        .modern-card {
            padding: 1.25rem;
        }

        /* Tabs mit mittlerer Gr√∂√üe */
        .stTabs [data-baseweb="tab"] {
            padding: 0.625rem 1rem;
        }

        /* Sidebar schmaler auf Tablet */
        [data-testid="stSidebar"] {
            width: 250px;
        }

        /* Angepasste Schriftgr√∂√üen */
        h1 { font-size: 1.75rem !important; }
        h2 { font-size: 1.5rem !important; }
        h3 { font-size: 1.25rem !important; }
    }

    /* ============================================
       DESKTOP STYLES (> 1024px)
       ============================================ */
    @media (min-width: 1025px) {
        /* Desktop Grid */
        .desktop-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }

        /* Breite Cards */
        .modern-card {
            padding: 1.5rem;
        }

        /* Hover-Effekte auf Desktop */
        .modern-card:hover {
            transform: translateY(-4px);
        }

        /* Sidebar volle Breite */
        [data-testid="stSidebar"] {
            width: 300px;
        }
    }

    /* ============================================
       SPEZIELLE KOMPONENTEN
       ============================================ */

    /* Quick Actions Grid */
    .quick-actions {
        display: grid;
        gap: 0.75rem;
    }

    @media (max-width: 767px) {
        .quick-actions {
            grid-template-columns: repeat(2, 1fr);
        }
    }

    @media (min-width: 768px) {
        .quick-actions {
            grid-template-columns: repeat(4, 1fr);
        }
    }

    .quick-action-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        background: var(--card-background);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
    }

    .quick-action-btn:hover {
        border-color: var(--primary-color);
        background: rgba(37, 99, 235, 0.05);
    }

    .quick-action-icon {
        font-size: 2rem;
        margin-bottom: 0.5rem;
    }

    .quick-action-label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-primary);
    }

    /* Progress Steps */
    .progress-steps {
        display: flex;
        justify-content: space-between;
        margin-bottom: 2rem;
    }

    .progress-step {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        position: relative;
    }

    .progress-step::before {
        content: '';
        position: absolute;
        top: 1rem;
        left: 50%;
        width: 100%;
        height: 2px;
        background: var(--border-color);
        z-index: 0;
    }

    .progress-step:last-child::before {
        display: none;
    }

    .progress-step-circle {
        width: 2rem;
        height: 2rem;
        border-radius: 50%;
        background: var(--border-color);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        color: var(--text-secondary);
        z-index: 1;
        position: relative;
    }

    .progress-step.active .progress-step-circle {
        background: var(--primary-color);
        color: white;
    }

    .progress-step.completed .progress-step-circle {
        background: var(--success-color);
        color: white;
    }

    .progress-step-label {
        margin-top: 0.5rem;
        font-size: 0.75rem;
        color: var(--text-secondary);
        text-align: center;
    }

    @media (max-width: 767px) {
        .progress-step-label {
            display: none;
        }

        .progress-step-circle {
            width: 1.5rem;
            height: 1.5rem;
            font-size: 0.75rem;
        }
    }

    /* Stat Cards */
    .stat-card {
        background: var(--card-background);
        border-radius: var(--radius-lg);
        padding: 1.25rem;
        border: 1px solid var(--border-color);
    }

    .stat-value {
        font-size: 2rem;
        font-weight: 700;
        color: var(--primary-color);
        line-height: 1;
    }

    .stat-label {
        font-size: 0.875rem;
        color: var(--text-secondary);
        margin-top: 0.25rem;
    }

    @media (max-width: 767px) {
        .stat-value {
            font-size: 1.5rem;
        }

        .stat-card {
            padding: 1rem;
        }
    }

    /* Avatar/Profilbild */
    .avatar {
        width: 3rem;
        height: 3rem;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 1.25rem;
    }

    .avatar-sm {
        width: 2rem;
        height: 2rem;
        font-size: 0.875rem;
    }

    .avatar-lg {
        width: 4rem;
        height: 4rem;
        font-size: 1.5rem;
    }

    /* Floating Action Button (FAB) - Mobile */
    .fab {
        position: fixed;
        bottom: 5rem;
        right: 1rem;
        width: 3.5rem;
        height: 3.5rem;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        box-shadow: var(--shadow-lg);
        cursor: pointer;
        z-index: 999;
        transition: transform 0.2s ease;
    }

    .fab:hover {
        transform: scale(1.1);
    }

    @media (min-width: 768px) {
        .fab {
            display: none;
        }
    }

    /* List Items */
    .list-item {
        display: flex;
        align-items: center;
        padding: 1rem;
        background: var(--card-background);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        margin-bottom: 0.5rem;
        transition: all 0.2s ease;
    }

    .list-item:hover {
        border-color: var(--primary-color);
    }

    .list-item-icon {
        font-size: 1.5rem;
        margin-right: 1rem;
    }

    .list-item-content {
        flex: 1;
    }

    .list-item-title {
        font-weight: 600;
        color: var(--text-primary);
    }

    .list-item-subtitle {
        font-size: 0.875rem;
        color: var(--text-secondary);
    }

    .list-item-action {
        color: var(--text-secondary);
    }

    /* Empty State */
    .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        color: var(--text-secondary);
    }

    .empty-state-icon {
        font-size: 4rem;
        margin-bottom: 1rem;
        opacity: 0.5;
    }

    .empty-state-title {
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.5rem;
    }

    .empty-state-text {
        font-size: 0.875rem;
    }

    /* Skeleton Loading */
    .skeleton {
        background: linear-gradient(90deg, var(--border-color) 25%, #f1f5f9 50%, var(--border-color) 75%);
        background-size: 200% 100%;
        animation: skeleton-loading 1.5s infinite;
        border-radius: var(--radius-sm);
    }

    @keyframes skeleton-loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }

    /* Pull to Refresh Indicator */
    .pull-indicator {
        text-align: center;
        padding: 1rem;
        color: var(--text-secondary);
        font-size: 0.875rem;
    }

    /* Toast Notifications */
    .toast {
        position: fixed;
        bottom: 6rem;
        left: 50%;
        transform: translateX(-50%);
        background: var(--text-primary);
        color: white;
        padding: 0.75rem 1.5rem;
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        z-index: 10000;
        animation: toast-in 0.3s ease;
    }

    @keyframes toast-in {
        from {
            opacity: 0;
            transform: translateX(-50%) translateY(1rem);
        }
        to {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    }

    /* Swipe Actions (f√ºr Listen) */
    .swipe-container {
        overflow-x: hidden;
        position: relative;
    }

    .swipe-content {
        transition: transform 0.2s ease;
    }

    .swipe-actions {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        display: flex;
    }

    .swipe-action {
        width: 4rem;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
    }

    .swipe-action-delete {
        background: var(--error-color);
    }

    .swipe-action-edit {
        background: var(--primary-color);
    }

    /* iOS Safe Area */
    @supports (padding: max(0px)) {
        .mobile-nav {
            padding-bottom: max(0.5rem, env(safe-area-inset-bottom));
        }

        .main .block-container {
            padding-bottom: max(5rem, calc(4rem + env(safe-area-inset-bottom)));
        }
    }

    </style>
    """, unsafe_allow_html=True)


def get_device_type() -> str:
    """
    Ermittelt den Ger√§tetyp basierend auf Session State.
    In Streamlit k√∂nnen wir den User-Agent nicht direkt lesen,
    daher verwenden wir JavaScript zur Erkennung.
    """
    # Default zu desktop
    if 'device_type' not in st.session_state:
        st.session_state.device_type = DeviceType.DESKTOP.value

    return st.session_state.device_type


def inject_device_detection():
    """Injiziert JavaScript zur Ger√§teerkennung"""
    st.markdown("""
    <script>
    (function() {
        function detectDevice() {
            const width = window.innerWidth;
            let deviceType = 'desktop';

            if (width < 768) {
                deviceType = 'mobile';
            } else if (width <= 1024) {
                deviceType = 'tablet';
            }

            // Speichern im sessionStorage
            sessionStorage.setItem('deviceType', deviceType);

            // Klasse zum Body hinzuf√ºgen
            document.body.classList.remove('device-mobile', 'device-tablet', 'device-desktop');
            document.body.classList.add('device-' + deviceType);
        }

        // Initial und bei Resize
        detectDevice();
        window.addEventListener('resize', detectDevice);
    })();
    </script>
    """, unsafe_allow_html=True)


def render_mobile_header(title: str, show_back: bool = False, show_menu: bool = True):
    """Rendert einen modernen Mobile Header"""
    st.markdown(f"""
    <div class="mobile-header">
        <div style="display: flex; align-items: center; justify-content: space-between;">
            <div style="display: flex; align-items: center; gap: 1rem;">
                {"<span style='font-size: 1.5rem; cursor: pointer;'>‚Üê</span>" if show_back else ""}
                <h1 style="margin: 0; font-size: 1.25rem; font-weight: 600;">{title}</h1>
            </div>
            {"<span style='font-size: 1.5rem; cursor: pointer;'>‚ò∞</span>" if show_menu else ""}
        </div>
    </div>
    """, unsafe_allow_html=True)


def render_mobile_nav(active_tab: str, role: str):
    """Rendert die Bottom Navigation f√ºr Mobile"""

    nav_items = {
        UserRole.KAEUFER.value: [
            {"icon": "üè†", "label": "Home", "key": "home"},
            {"icon": "üìù", "label": "Aufgaben", "key": "aufgaben"},
            {"icon": "üí∞", "label": "Finanzierung", "key": "finanzierung"},
            {"icon": "üìÑ", "label": "Dokumente", "key": "dokumente"},
            {"icon": "üë§", "label": "Profil", "key": "profil"},
        ],
        UserRole.VERKAEUFER.value: [
            {"icon": "üè†", "label": "Home", "key": "home"},
            {"icon": "üìã", "label": "Projekte", "key": "projekte"},
            {"icon": "üìÑ", "label": "Dokumente", "key": "dokumente"},
            {"icon": "üìÖ", "label": "Termine", "key": "termine"},
            {"icon": "üë§", "label": "Profil", "key": "profil"},
        ],
        UserRole.MAKLER.value: [
            {"icon": "üè†", "label": "Home", "key": "home"},
            {"icon": "üìã", "label": "Projekte", "key": "projekte"},
            {"icon": "üìä", "label": "Expos√©s", "key": "exposes"},
            {"icon": "üë•", "label": "Kunden", "key": "kunden"},
            {"icon": "üë§", "label": "Profil", "key": "profil"},
        ],
        UserRole.FINANZIERER.value: [
            {"icon": "üè†", "label": "Home", "key": "home"},
            {"icon": "üìä", "label": "Anfragen", "key": "anfragen"},
            {"icon": "üìã", "label": "Angebote", "key": "angebote"},
            {"icon": "üìÑ", "label": "Dokumente", "key": "dokumente"},
            {"icon": "üë§", "label": "Profil", "key": "profil"},
        ],
        UserRole.NOTAR.value: [
            {"icon": "üè†", "label": "Home", "key": "home"},
            {"icon": "üìã", "label": "Projekte", "key": "projekte"},
            {"icon": "üìù", "label": "Checklisten", "key": "checklisten"},
            {"icon": "üìÖ", "label": "Termine", "key": "termine"},
            {"icon": "‚öôÔ∏è", "label": "Mehr", "key": "mehr"},
        ],
    }

    items = nav_items.get(role, nav_items[UserRole.KAEUFER.value])

    nav_html = '<div class="mobile-nav">'
    for item in items:
        active_class = "active" if item["key"] == active_tab else ""
        nav_html += f'''
        <div class="mobile-nav-item {active_class}" data-tab="{item['key']}">
            <span class="mobile-nav-icon">{item['icon']}</span>
            <span>{item['label']}</span>
        </div>
        '''
    nav_html += '</div>'

    st.markdown(nav_html, unsafe_allow_html=True)


def render_quick_actions(actions: List[Dict[str, str]]):
    """Rendert Quick Action Buttons im Grid"""
    cols = st.columns(len(actions) if len(actions) <= 4 else 4)
    for i, action in enumerate(actions[:4]):
        with cols[i % 4]:
            st.markdown(f"""
            <div class="quick-action-btn">
                <span class="quick-action-icon">{action.get('icon', 'üìå')}</span>
                <span class="quick-action-label">{action.get('label', 'Aktion')}</span>
            </div>
            """, unsafe_allow_html=True)


def render_stat_cards(stats: List[Dict[str, Any]]):
    """Rendert Statistik-Cards"""
    cols = st.columns(len(stats))
    for i, stat in enumerate(stats):
        with cols[i]:
            st.markdown(f"""
            <div class="stat-card">
                <div class="stat-value">{stat.get('value', '0')}</div>
                <div class="stat-label">{stat.get('label', 'Label')}</div>
            </div>
            """, unsafe_allow_html=True)


def render_progress_steps(steps: List[Dict[str, Any]], current_step: int):
    """Rendert Progress Steps"""
    steps_html = '<div class="progress-steps">'
    for i, step in enumerate(steps):
        status = "completed" if i < current_step else ("active" if i == current_step else "")
        steps_html += f'''
        <div class="progress-step {status}">
            <div class="progress-step-circle">{i + 1 if status != "completed" else "‚úì"}</div>
            <div class="progress-step-label">{step.get('label', '')}</div>
        </div>
        '''
    steps_html += '</div>'
    st.markdown(steps_html, unsafe_allow_html=True)


def render_list_item(icon: str, title: str, subtitle: str = "", action_icon: str = "‚Üí"):
    """Rendert ein List Item"""
    st.markdown(f"""
    <div class="list-item">
        <span class="list-item-icon">{icon}</span>
        <div class="list-item-content">
            <div class="list-item-title">{title}</div>
            {"<div class='list-item-subtitle'>" + subtitle + "</div>" if subtitle else ""}
        </div>
        <span class="list-item-action">{action_icon}</span>
    </div>
    """, unsafe_allow_html=True)


def render_empty_state(icon: str, title: str, text: str):
    """Rendert einen Empty State"""
    st.markdown(f"""
    <div class="empty-state">
        <div class="empty-state-icon">{icon}</div>
        <div class="empty-state-title">{title}</div>
        <div class="empty-state-text">{text}</div>
    </div>
    """, unsafe_allow_html=True)


def render_status_badge(text: str, status: str = "info"):
    """Rendert ein Status Badge"""
    return f'<span class="status-badge status-{status}">{text}</span>'


def render_avatar(name: str, size: str = ""):
    """Rendert einen Avatar mit Initialen"""
    initials = "".join([n[0].upper() for n in name.split()[:2]]) if name else "?"
    size_class = f"avatar-{size}" if size else ""
    return f'<div class="avatar {size_class}">{initials}</div>'

# ============================================================================
# AKTENTASCHE - UI FUNKTIONEN
# ============================================================================

def get_or_create_aktentasche(user_id: str) -> 'Aktentasche':
    """Holt oder erstellt die Aktentasche eines Benutzers"""
    if 'aktentaschen' not in st.session_state:
        st.session_state.aktentaschen = {}

    if user_id not in st.session_state.aktentaschen:
        from dataclasses import dataclass, field
        st.session_state.aktentaschen[user_id] = Aktentasche(user_id=user_id)

    return st.session_state.aktentaschen[user_id]

def add_to_aktentasche(
    user_id: str,
    inhalt_typ: str,
    titel: str,
    beschreibung: str = "",
    referenz_id: str = "",
    referenz_typ: str = "",
    dateiname: str = "",
    dateigr√∂√üe: int = 0,
    pdf_data: bytes = None,
    projekt_id: str = "",
    projekt_name: str = ""
) -> str:
    """F√ºgt ein Element zur Aktentasche hinzu"""
    aktentasche = get_or_create_aktentasche(user_id)

    inhalt_id = f"akt_{user_id}_{len(aktentasche.inhalte)}_{datetime.now().strftime('%Y%m%d%H%M%S')}"

    inhalt = AktentascheInhalt(
        inhalt_id=inhalt_id,
        inhalt_typ=inhalt_typ,
        titel=titel,
        beschreibung=beschreibung,
        referenz_id=referenz_id,
        referenz_typ=referenz_typ,
        dateiname=dateiname,
        dateigr√∂√üe=dateigr√∂√üe,
        pdf_data=pdf_data,
        projekt_id=projekt_id,
        projekt_name=projekt_name
    )

    aktentasche.inhalte[inhalt_id] = inhalt
    aktentasche.zuletzt_geaendert = datetime.now()

    return inhalt_id

def remove_from_aktentasche(user_id: str, inhalt_id: str) -> bool:
    """Entfernt ein Element aus der Aktentasche"""
    aktentasche = get_or_create_aktentasche(user_id)

    if inhalt_id in aktentasche.inhalte:
        del aktentasche.inhalte[inhalt_id]
        aktentasche.zuletzt_geaendert = datetime.now()
        return True
    return False

def get_projekt_beteiligte(projekt_id: str) -> List[Dict[str, str]]:
    """Holt alle Beteiligten eines Projekts f√ºr die Freigabe"""
    beteiligte = []
    projekt = st.session_state.projekte.get(projekt_id)

    if not projekt:
        return beteiligte

    # Makler
    if projekt.makler_id:
        makler = st.session_state.users.get(projekt.makler_id)
        if makler:
            beteiligte.append({
                "user_id": makler.user_id,
                "name": makler.name,
                "rolle": "Makler",
                "email": makler.email
            })

    # K√§ufer
    for kid in projekt.kaeufer_ids:
        kaeufer = st.session_state.users.get(kid)
        if kaeufer:
            beteiligte.append({
                "user_id": kaeufer.user_id,
                "name": kaeufer.name,
                "rolle": "K√§ufer",
                "email": kaeufer.email
            })

    # Verk√§ufer
    for vid in projekt.verkaeufer_ids:
        verkaeufer = st.session_state.users.get(vid)
        if verkaeufer:
            beteiligte.append({
                "user_id": verkaeufer.user_id,
                "name": verkaeufer.name,
                "rolle": "Verk√§ufer",
                "email": verkaeufer.email
            })

    # Finanzierer
    for fid in projekt.finanzierer_ids:
        finanzierer = st.session_state.users.get(fid)
        if finanzierer:
            beteiligte.append({
                "user_id": finanzierer.user_id,
                "name": finanzierer.name,
                "rolle": "Finanzierer",
                "email": finanzierer.email
            })

    # Notar
    if projekt.notar_id:
        notar = st.session_state.users.get(projekt.notar_id)
        if notar:
            beteiligte.append({
                "user_id": notar.user_id,
                "name": notar.name,
                "rolle": "Notar",
                "email": notar.email
            })

    return beteiligte

def render_aktentasche_sidebar(user_id: str, aktives_projekt_id: str = ""):
    """Rendert die Aktentasche in der Sidebar"""
    aktentasche = get_or_create_aktentasche(user_id)
    anzahl_inhalte = len(aktentasche.inhalte)

    # Aktentasche-Button mit Badge
    with st.sidebar:
        st.markdown("---")

        # Expander f√ºr die Aktentasche
        with st.expander(f"üíº Aktentasche ({anzahl_inhalte})", expanded=False):
            if anzahl_inhalte == 0:
                st.info("Ihre Aktentasche ist leer.\n\nF√ºgen Sie Dokumente, Angebote oder andere Inhalte hinzu, um sie sp√§ter zu teilen oder herunterzuladen.")
            else:
                # Filter-Optionen
                filter_typ = st.selectbox(
                    "Filter",
                    options=["Alle", "Dokumente", "Angebote", "Finanzierungsangebote", "Expos√©s", "Sonstiges"],
                    key="aktentasche_filter"
                )

                # Inhalte filtern
                inhalte_liste = list(aktentasche.inhalte.values())

                if filter_typ != "Alle":
                    typ_mapping = {
                        "Dokumente": AktentascheInhaltTyp.DOKUMENT.value,
                        "Angebote": AktentascheInhaltTyp.ANGEBOT.value,
                        "Finanzierungsangebote": AktentascheInhaltTyp.FINANZIERUNGSANGEBOT.value,
                        "Expos√©s": AktentascheInhaltTyp.EXPOSE.value,
                        "Sonstiges": AktentascheInhaltTyp.SONSTIGES.value
                    }
                    inhalte_liste = [i for i in inhalte_liste if i.inhalt_typ == typ_mapping.get(filter_typ, "")]

                # Sortieren nach Datum (neueste zuerst)
                inhalte_liste.sort(key=lambda x: x.hinzugefuegt_am, reverse=True)

                # Checkbox f√ºr Mehrfachauswahl
                if 'aktentasche_auswahl' not in st.session_state:
                    st.session_state.aktentasche_auswahl = []

                st.markdown("##### Inhalte")

                for inhalt in inhalte_liste:
                    col1, col2 = st.columns([0.15, 0.85])

                    with col1:
                        selected = st.checkbox(
                            "",
                            key=f"akt_sel_{inhalt.inhalt_id}",
                            value=inhalt.inhalt_id in st.session_state.aktentasche_auswahl
                        )
                        if selected and inhalt.inhalt_id not in st.session_state.aktentasche_auswahl:
                            st.session_state.aktentasche_auswahl.append(inhalt.inhalt_id)
                        elif not selected and inhalt.inhalt_id in st.session_state.aktentasche_auswahl:
                            st.session_state.aktentasche_auswahl.remove(inhalt.inhalt_id)

                    with col2:
                        # Icon basierend auf Typ
                        typ_icons = {
                            AktentascheInhaltTyp.DOKUMENT.value: "üìÑ",
                            AktentascheInhaltTyp.ANGEBOT.value: "üí∞",
                            AktentascheInhaltTyp.FINANZIERUNGSANGEBOT.value: "üè¶",
                            AktentascheInhaltTyp.EXPOSE.value: "üè†",
                            AktentascheInhaltTyp.VERTRAG.value: "üìú",
                            AktentascheInhaltTyp.NACHRICHT.value: "‚úâÔ∏è",
                            AktentascheInhaltTyp.SONSTIGES.value: "üìé"
                        }
                        icon = typ_icons.get(inhalt.inhalt_typ, "üìé")

                        st.markdown(f"**{icon} {inhalt.titel}**")
                        if inhalt.projekt_name:
                            st.caption(f"{inhalt.projekt_name}")
                        st.caption(f"{inhalt.hinzugefuegt_am.strftime('%d.%m.%Y %H:%M')}")

                # Aktionen f√ºr ausgew√§hlte Elemente
                if st.session_state.aktentasche_auswahl:
                    st.markdown("---")
                    st.markdown(f"**{len(st.session_state.aktentasche_auswahl)} ausgew√§hlt**")

                    col1, col2, col3 = st.columns(3)

                    with col1:
                        if st.button("üì§ Teilen", key="akt_teilen", use_container_width=True):
                            st.session_state.aktentasche_teilen_dialog = True

                    with col2:
                        if st.button("‚¨áÔ∏è Download", key="akt_download", use_container_width=True):
                            st.session_state.aktentasche_download = True

                    with col3:
                        if st.button("üóëÔ∏è Entfernen", key="akt_entfernen", use_container_width=True):
                            for inhalt_id in st.session_state.aktentasche_auswahl:
                                remove_from_aktentasche(user_id, inhalt_id)
                            st.session_state.aktentasche_auswahl = []
                            st.rerun()

def render_aktentasche_teilen_dialog(user_id: str):
    """Rendert den Dialog zum Teilen von Aktentasche-Inhalten"""
    if not st.session_state.get('aktentasche_teilen_dialog', False):
        return

    aktentasche = get_or_create_aktentasche(user_id)
    ausgewaehlte_ids = st.session_state.get('aktentasche_auswahl', [])

    if not ausgewaehlte_ids:
        st.session_state.aktentasche_teilen_dialog = False
        return

    st.markdown("### üì§ Inhalte teilen")

    # Ausgew√§hlte Inhalte anzeigen
    st.markdown("**Ausgew√§hlte Inhalte:**")
    for inhalt_id in ausgewaehlte_ids:
        inhalt = aktentasche.inhalte.get(inhalt_id)
        if inhalt:
            st.markdown(f"- {inhalt.titel}")

    st.markdown("---")

    # Versand-Methode w√§hlen
    versand_methode = st.radio(
        "Versand an",
        options=["üë• Projektbeteiligte", "üìß E-Mail an Dritte", "üîó Download-Link erstellen"],
        key="teilen_methode"
    )

    if versand_methode == "üë• Projektbeteiligte":
        # Projekt ausw√§hlen falls mehrere
        user = st.session_state.users.get(user_id)
        projekte = [st.session_state.projekte.get(pid) for pid in user.projekt_ids if st.session_state.projekte.get(pid)]

        if projekte:
            projekt_auswahl = st.selectbox(
                "Projekt",
                options=[p.name for p in projekte],
                key="teilen_projekt"
            )

            ausgewaehltes_projekt = next((p for p in projekte if p.name == projekt_auswahl), None)

            if ausgewaehltes_projekt:
                beteiligte = get_projekt_beteiligte(ausgewaehltes_projekt.projekt_id)
                # Eigenen User ausschlie√üen
                beteiligte = [b for b in beteiligte if b['user_id'] != user_id]

                if beteiligte:
                    st.markdown("**Empf√§nger ausw√§hlen:**")
                    empfaenger_auswahl = []

                    for b in beteiligte:
                        if st.checkbox(f"{b['name']} ({b['rolle']})", key=f"empf_{b['user_id']}"):
                            empfaenger_auswahl.append(b['user_id'])

                    nachricht = st.text_area(
                        "Nachricht (optional)",
                        placeholder="F√ºgen Sie eine pers√∂nliche Nachricht hinzu...",
                        key="teilen_nachricht"
                    )

                    col1, col2 = st.columns(2)
                    with col1:
                        if st.button("üì§ Senden", type="primary", use_container_width=True):
                            if empfaenger_auswahl:
                                # Benachrichtigungen erstellen
                                absender = st.session_state.users.get(user_id)
                                for emp_id in empfaenger_auswahl:
                                    titel_liste = [aktentasche.inhalte[i].titel for i in ausgewaehlte_ids if i in aktentasche.inhalte]
                                    create_notification(
                                        user_id=emp_id,
                                        titel="üíº Dokumente aus Aktentasche erhalten",
                                        nachricht=f"{absender.name} hat Ihnen {len(titel_liste)} Dokument(e) gesendet: {', '.join(titel_liste[:3])}{'...' if len(titel_liste) > 3 else ''}",
                                        typ=NotificationType.INFO.value
                                    )

                                    # Inhalte zur Aktentasche des Empf√§ngers kopieren
                                    for inhalt_id in ausgewaehlte_ids:
                                        original = aktentasche.inhalte.get(inhalt_id)
                                        if original:
                                            add_to_aktentasche(
                                                user_id=emp_id,
                                                inhalt_typ=original.inhalt_typ,
                                                titel=f"{original.titel} (von {absender.name})",
                                                beschreibung=original.beschreibung,
                                                referenz_id=original.referenz_id,
                                                referenz_typ=original.referenz_typ,
                                                dateiname=original.dateiname,
                                                dateigr√∂√üe=original.dateigr√∂√üe,
                                                pdf_data=original.pdf_data,
                                                projekt_id=original.projekt_id,
                                                projekt_name=original.projekt_name
                                            )

                                st.success(f"‚úÖ An {len(empfaenger_auswahl)} Empf√§nger gesendet!")
                                st.session_state.aktentasche_teilen_dialog = False
                                st.session_state.aktentasche_auswahl = []
                                st.rerun()
                            else:
                                st.warning("Bitte w√§hlen Sie mindestens einen Empf√§nger.")

                    with col2:
                        if st.button("‚ùå Abbrechen", use_container_width=True):
                            st.session_state.aktentasche_teilen_dialog = False
                            st.rerun()
                else:
                    st.info("Keine anderen Projektbeteiligten gefunden.")
        else:
            st.info("Sie sind an keinem Projekt beteiligt.")

    elif versand_methode == "üìß E-Mail an Dritte":
        empfaenger_email = st.text_input(
            "E-Mail-Adresse",
            placeholder="empfaenger@beispiel.de",
            key="teilen_email"
        )
        empfaenger_name = st.text_input(
            "Name des Empf√§ngers",
            placeholder="Max Mustermann",
            key="teilen_email_name"
        )
        betreff = st.text_input(
            "Betreff",
            value="Dokumente aus der Immobilien-Transaktionsplattform",
            key="teilen_betreff"
        )
        nachricht = st.text_area(
            "Nachricht",
            placeholder="Sehr geehrte/r...",
            key="teilen_email_nachricht"
        )

        # G√ºltigkeitsdauer
        gueltigkeit = st.selectbox(
            "Link g√ºltig f√ºr",
            options=["7 Tage", "14 Tage", "30 Tage", "Unbegrenzt"],
            key="teilen_gueltigkeit"
        )

        col1, col2 = st.columns(2)
        with col1:
            if st.button("üìß E-Mail senden", type="primary", use_container_width=True):
                if empfaenger_email and "@" in empfaenger_email:
                    # Hier w√ºrde die E-Mail-Versand-Logik implementiert
                    st.success(f"‚úÖ E-Mail wurde an {empfaenger_email} gesendet!")
                    st.info("üí° Hinweis: In der Demo-Version wird keine echte E-Mail versendet.")
                    st.session_state.aktentasche_teilen_dialog = False
                    st.session_state.aktentasche_auswahl = []
                    st.rerun()
                else:
                    st.warning("Bitte geben Sie eine g√ºltige E-Mail-Adresse ein.")

        with col2:
            if st.button("‚ùå Abbrechen", use_container_width=True, key="email_abbrechen"):
                st.session_state.aktentasche_teilen_dialog = False
                st.rerun()

    else:  # Download-Link erstellen
        st.info("Ein Download-Link wird erstellt, den Sie kopieren und teilen k√∂nnen.")

        gueltigkeit = st.selectbox(
            "Link g√ºltig f√ºr",
            options=["24 Stunden", "7 Tage", "14 Tage", "30 Tage"],
            key="download_gueltigkeit"
        )

        col1, col2 = st.columns(2)
        with col1:
            if st.button("üîó Link erstellen", type="primary", use_container_width=True):
                # Generiere einen simulierten Download-Link
                link_id = uuid.uuid4().hex[:12]
                download_link = f"https://immo-plattform.de/download/{link_id}"

                st.success("‚úÖ Download-Link erstellt!")
                st.code(download_link)
                st.info("üí° Kopieren Sie den Link und teilen Sie ihn mit dem Empf√§nger.")

        with col2:
            if st.button("‚ùå Abbrechen", use_container_width=True, key="link_abbrechen"):
                st.session_state.aktentasche_teilen_dialog = False
                st.rerun()

def render_aktentasche_download(user_id: str):
    """Rendert den Download-Dialog f√ºr Aktentasche-Inhalte"""
    if not st.session_state.get('aktentasche_download', False):
        return

    aktentasche = get_or_create_aktentasche(user_id)
    ausgewaehlte_ids = st.session_state.get('aktentasche_auswahl', [])

    if not ausgewaehlte_ids:
        st.session_state.aktentasche_download = False
        return

    st.markdown("### ‚¨áÔ∏è Inhalte herunterladen")

    # Sammle alle Download-f√§higen Inhalte
    downloadable = []
    for inhalt_id in ausgewaehlte_ids:
        inhalt = aktentasche.inhalte.get(inhalt_id)
        if inhalt and inhalt.pdf_data:
            downloadable.append(inhalt)

    if downloadable:
        st.markdown(f"**{len(downloadable)} Dokument(e) zum Download verf√ºgbar:**")

        for inhalt in downloadable:
            st.download_button(
                label=f"üì• {inhalt.dateiname or inhalt.titel}",
                data=inhalt.pdf_data,
                file_name=inhalt.dateiname or f"{inhalt.titel}.pdf",
                mime="application/pdf",
                key=f"dl_{inhalt.inhalt_id}"
            )
    else:
        st.info("Die ausgew√§hlten Elemente enthalten keine herunterladbaren Dateien.")

    if st.button("‚úÖ Fertig", use_container_width=True):
        st.session_state.aktentasche_download = False
        st.session_state.aktentasche_auswahl = []
        st.rerun()

def render_zur_aktentasche_button(
    user_id: str,
    inhalt_typ: str,
    titel: str,
    beschreibung: str = "",
    referenz_id: str = "",
    referenz_typ: str = "",
    dateiname: str = "",
    dateigr√∂√üe: int = 0,
    pdf_data: bytes = None,
    projekt_id: str = "",
    projekt_name: str = "",
    key_suffix: str = ""
):
    """Rendert einen Button zum Hinzuf√ºgen zur Aktentasche"""
    if st.button(f"üíº Zur Aktentasche", key=f"zur_akt_{referenz_id}_{key_suffix}", help="In die Aktentasche legen"):
        add_to_aktentasche(
            user_id=user_id,
            inhalt_typ=inhalt_typ,
            titel=titel,
            beschreibung=beschreibung,
            referenz_id=referenz_id,
            referenz_typ=referenz_typ,
            dateiname=dateiname,
            dateigr√∂√üe=dateigr√∂√üe,
            pdf_data=pdf_data,
            projekt_id=projekt_id,
            projekt_name=projekt_name
        )
        st.success(f"‚úÖ '{titel}' zur Aktentasche hinzugef√ºgt!")
        st.rerun()

# ============================================================================
# ENUMS UND KONSTANTEN
# ============================================================================

class UserRole(Enum):
    MAKLER = "Makler"
    KAEUFER = "K√§ufer"
    VERKAEUFER = "Verk√§ufer"
    FINANZIERER = "Finanzierer"
    NOTAR = "Notar"

class DocumentType(Enum):
    MAKLERAUFTRAG = "Maklerauftrag"
    DATENSCHUTZ = "Datenschutzerkl√§rung"
    WIDERRUFSBELEHRUNG = "Widerrufsbelehrung"
    WIDERRUFSVERZICHT = "Verzicht auf Widerruf"
    BWA = "BWA"
    STEUERBESCHEID = "Steuerbescheid"
    GEHALTSABRECHNUNG = "Gehaltsabrechnung"
    VERMOEGENSNACHWEIS = "Verm√∂gensnachweis"
    SONSTIGE = "Sonstige Bonit√§tsunterlage"
    EXPOSE = "Expos√©"

class FinanzierungsStatus(Enum):
    ENTWURF = "Entwurf"
    GESENDET = "An K√§ufer gesendet"
    ANGENOMMEN = "Vom K√§ufer angenommen"
    ZURUECKGEZOGEN = "Zur√ºckgezogen / gegenstandslos"
    ABGELAUFEN = "Abgelaufen"

class FinanziererEinladungStatus(Enum):
    EINGELADEN = "Eingeladen"
    REGISTRIERT = "Registriert"
    AKTIV = "Aktiv"
    DEAKTIVIERT = "Deaktiviert"

class ProjektStatus(Enum):
    VORBEREITUNG = "Vorbereitung"
    EXPOSE_ERSTELLT = "Expos√© erstellt"
    TEILNEHMER_EINGELADEN = "Teilnehmer eingeladen"
    ONBOARDING_LAUFEND = "Onboarding l√§uft"
    DOKUMENTE_VOLLSTAENDIG = "Dokumente vollst√§ndig"
    WIRTSCHAFTSDATEN_HOCHGELADEN = "Wirtschaftsdaten hochgeladen"
    FINANZIERUNG_ANGEFRAGT = "Finanzierung angefragt"
    FINANZIERUNG_GESICHERT = "Finanzierung gesichert"
    NOTARTERMIN_VEREINBART = "Notartermin vereinbart"
    KAUFVERTRAG_UNTERZEICHNET = "Kaufvertrag unterzeichnet"
    ABGESCHLOSSEN = "Abgeschlossen"

class NotificationType(Enum):
    INFO = "info"
    SUCCESS = "success"
    WARNING = "warning"
    ERROR = "error"

class PropertyType(Enum):
    """Objektarten"""
    WOHNUNG = "Wohnung"
    HAUS = "Haus"
    MFH = "Mehrfamilienhaus"
    LAND = "Grundst√ºck/Land"

class DocumentCategory(Enum):
    """Dokumenten-Kategorien"""
    PERSON = "Personenbezogene Unterlagen"
    OBJEKT_BASIS = "Objektunterlagen Grunds√§tzlich"
    WEG_SPEZIAL = "Wohnung/Teileigentum Spezial"
    LAND_SPEZIAL = "Land/Acker/Wald Spezial"
    FINANZIERUNG = "Finanzierungsunterlagen"
    NOTAR = "Notarielle Dokumente"

class ChecklistType(Enum):
    """Notarielle Checklisten-Typen"""
    KAUFVERTRAG = "Checkliste Kaufvertrag Grundst√ºck/Wohnung"
    UEBERLASSUNG = "Checkliste √úberlassungsvertrag"
    MANDANT = "Mandantenfragebogen Notariat"
    DATENSCHUTZ = "Datenschutz-Info Notariat"
    VERBRAUCHER = "Verbraucher-Informationsblatt"

class DocumentRequestStatus(Enum):
    """Status einer Dokumentenanforderung"""
    ANGEFORDERT = "Angefordert"
    BEREITGESTELLT = "Bereitgestellt"
    FEHLT = "Fehlt noch"
    NICHT_RELEVANT = "Nicht relevant"

class NotarMitarbeiterRolle(Enum):
    """Rollen f√ºr Notar-Mitarbeiter"""
    VOLLZUGRIFF = "Vollzugriff"
    SACHBEARBEITER = "Sachbearbeiter"
    NUR_LESEN = "Nur Lesen"
    CHECKLISTEN_VERWALTER = "Checklisten-Verwalter"

class Verk√§uferDokumentTyp(Enum):
    """Dokumenttypen f√ºr Verk√§ufer"""
    GRUNDBUCHAUSZUG = "Grundbuchauszug"
    TEILUNGSERKLARUNG = "Teilungserkl√§rung"
    WEG_PROTOKOLLE = "WEG-Protokolle"
    ENERGIEAUSWEIS = "Energieausweis"
    LAGEPLAN = "Lageplan"
    GRUNDRISS = "Grundriss"
    BAUGENEHMIGUNG = "Baugenehmigung"
    FLURKARTE = "Flurkarte"
    WIRTSCHAFTSPLAN = "Wirtschaftsplan (WEG)"
    HAUSVERWALTUNG_BESCHEINIGUNG = "Bescheinigung Hausverwaltung"
    MIETVERTR√ÑGE = "Mietvertr√§ge (bei vermieteten Objekten)"
    NEBENKOSTENABRECHNUNG = "Nebenkostenabrechnung"
    MODERNISIERUNGSNACHWEISE = "Modernisierungsnachweise"
    WOHNFLACHENBERECHNUNG = "Wohnfl√§chenberechnung"
    SONSTIGES = "Sonstige Dokumente"

# ============================================================================
# DATENMODELLE
# ============================================================================

@dataclass
class LegalDocument:
    """Rechtliche Dokumente vom Makler"""
    doc_type: str
    version: str
    content_text: str
    pdf_data: Optional[bytes] = None
    created_at: datetime = field(default_factory=datetime.now)

@dataclass
class DocumentAcceptance:
    """Akzeptanz-Protokoll f√ºr rechtliche Dokumente"""
    user_id: str
    document_type: str
    document_version: str
    accepted_at: datetime
    ip_address: Optional[str] = None
    role: str = ""

@dataclass
class FinancingOffer:
    """Finanzierungsangebot"""
    offer_id: str
    finanzierer_id: str
    projekt_id: str
    darlehensbetrag: float
    zinssatz: float
    sollzinsbindung: int
    tilgungssatz: float
    gesamtlaufzeit: int
    monatliche_rate: float
    besondere_bedingungen: str
    status: str
    pdf_data: Optional[bytes] = None
    created_at: datetime = field(default_factory=datetime.now)
    accepted_at: Optional[datetime] = None
    fuer_notar_markiert: bool = False
    # Neue Felder f√ºr erweiterte Funktionalit√§t
    gueltig_bis: Optional[datetime] = None  # Befristung
    auto_delete: bool = False  # Automatisch l√∂schen wenn abgelaufen
    sondertilgung_prozent: float = 0.0  # Sondertilgung in % p.a.
    sondertilgung_max_betrag: float = 0.0  # Max. Sondertilgungsbetrag
    bereitstellungszinsen_frei_monate: int = 0  # Bereitstellungszinsfreie Zeit
    effektivzins: float = 0.0  # Effektiver Jahreszins
    produktname: str = ""  # Name des Finanzierungsprodukts
    angebot_nummer: int = 1  # Angebotsnummer f√ºr mehrere Angebote

@dataclass
class FinanziererEinladung:
    """Einladung f√ºr Finanzierer durch K√§ufer/Makler/Notar"""
    einladung_id: str
    projekt_id: str
    eingeladen_von: str  # User-ID
    finanzierer_email: str
    finanzierer_name: str = ""
    firmenname: str = ""
    status: str = FinanziererEinladungStatus.EINGELADEN.value
    eingeladen_am: datetime = field(default_factory=datetime.now)
    registriert_am: Optional[datetime] = None
    onboarding_token: str = ""
    finanzierer_user_id: str = ""  # Nach Registrierung
    notiz: str = ""

@dataclass
class FinanzierungsAnfrage:
    """Finanzierungsanfrage vom K√§ufer"""
    anfrage_id: str
    projekt_id: str
    kaeufer_id: str
    kaufpreis: float
    eigenkapital: float
    finanzierungsbetrag: float
    wunsch_zinssatz: Optional[float] = None
    wunsch_tilgung: Optional[float] = None
    wunsch_laufzeit: Optional[int] = None
    sondertilgung_gewuenscht: bool = False
    vollfinanzierung: bool = False
    erstellt_am: datetime = field(default_factory=datetime.now)
    dokumente_freigegeben: bool = False
    notizen: str = ""
    # NEU: Verkn√ºpfung mit Finanzierungsmodell
    modell_id: Optional[str] = None  # Referenz auf Finanzierungsmodell
    # NEU: Ausgew√§hlte Finanzierer f√ºr die Anfrage
    finanzierer_ids: List[str] = field(default_factory=list)
    an_alle_finanzierer: bool = False
    anfrage_status: str = "Entwurf"  # Entwurf, Gesendet, Beantwortet


@dataclass
class FinanzierungsanfrageAnFinanzierer:
    """Einzelne Anfrage an einen bestimmten Finanzierer"""
    anfrage_einzeln_id: str
    hauptanfrage_id: str  # Referenz auf FinanzierungsAnfrage
    modell_id: str  # Referenz auf Finanzierungsmodell
    finanzierer_id: str
    kaeufer_id: str
    projekt_id: str
    gesendet_am: datetime = field(default_factory=datetime.now)
    status: str = "Gesendet"  # Gesendet, Gelesen, Angebot_erstellt, Abgelehnt
    finanzierer_notizen: str = ""
    angebot_id: Optional[str] = None  # Referenz auf erhaltenes Angebot

class FinanzierungsmodellStatus(Enum):
    """Status eines Finanzierungsmodells"""
    ENTWURF = "Entwurf"
    FAVORIT = "Favorit"
    ANGEFORDERT = "Bei Finanzierer angefordert"
    ANGEBOT_ERHALTEN = "Angebot erhalten"
    ABGELEHNT = "Abgelehnt"
    ANGENOMMEN = "Angenommen"

class FinanzierungsmodellQuelle(Enum):
    """Quelle eines Finanzierungsmodells"""
    EIGENE_BERECHNUNG = "Eigene Berechnung"
    FINANZIERER_ANGEBOT = "Finanzierer-Angebot"
    IMPORT_PDF = "Import aus PDF"
    IMPORT_CSV = "Import aus CSV"
    IMPORT_EXCEL = "Import aus Excel"

@dataclass
class Finanzierungsmodell:
    """Gespeichertes Finanzierungsmodell f√ºr Vergleich und Anfragen"""
    modell_id: str
    projekt_id: str
    kaeufer_id: str
    name: str
    # Basisdaten
    kaufpreis: float
    nebenkosten: float
    finanzierungsbedarf: float
    eigenkapital: float
    darlehensbetrag: float
    # Konditionen
    zinssatz: float
    tilgungssatz: float
    monatliche_rate: float
    sollzinsbindung: int  # Jahre
    # Optionale Konditionen
    sondertilgung_prozent: float = 0.0
    bereitstellungszinsen: float = 0.0
    effektivzins: float = 0.0
    # Berechnungsergebnisse
    restschuld_nach_zinsbindung: float = 0.0
    gesamtlaufzeit_jahre: float = 0.0
    gesamtzinsen: float = 0.0
    gesamtkosten: float = 0.0
    # Tilgungsplan (als JSON-String gespeichert)
    tilgungsplan_json: str = ""
    # Metadaten
    status: str = FinanzierungsmodellStatus.ENTWURF.value
    quelle: str = FinanzierungsmodellQuelle.EIGENE_BERECHNUNG.value
    finanzierer_id: Optional[str] = None
    finanzierer_name: str = ""
    angebot_pdf_data: Optional[bytes] = None
    notizen: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)
    geaendert_am: datetime = field(default_factory=datetime.now)
    ist_favorit: bool = False

@dataclass
class MarktanalyseErgebnis:
    """Ergebnis einer automatischen Marktanalyse"""
    analyse_id: str
    projekt_id: str
    durchgefuehrt_von: str  # User-ID
    durchgefuehrt_am: datetime
    # Suchkriterien
    plz: str
    ort: str
    objekttyp: str  # Wohnung, Haus, etc.
    wohnflaeche_von: float
    wohnflaeche_bis: float
    zimmer_von: int
    zimmer_bis: int
    umkreis_km: int
    # Ergebnisse
    vergleichsobjekte: List[Dict[str, Any]] = field(default_factory=list)
    durchschnitt_preis: float = 0.0
    durchschnitt_preis_qm: float = 0.0
    min_preis: float = 0.0
    max_preis: float = 0.0
    min_preis_qm: float = 0.0
    max_preis_qm: float = 0.0
    anzahl_objekte: int = 0
    # Preisempfehlung
    empfohlener_preis: float = 0.0
    preis_spanne_von: float = 0.0
    preis_spanne_bis: float = 0.0

@dataclass
class MarktpreisHistorie:
    """Historische Marktpreisdaten f√ºr Charts"""
    eintrag_id: str
    projekt_id: str
    erfasst_am: datetime
    durchschnitt_preis_qm: float
    anzahl_vergleichsobjekte: int
    min_preis_qm: float
    max_preis_qm: float


# ===== DATENERMITTLUNG F√úR NOTAR =====

class DatenermittlungStatus(Enum):
    """Status einer Datenermittlung"""
    AUSSTEHEND = "Ausstehend"
    ANGEFRAGT = "Angefragt"
    IN_BEARBEITUNG = "In Bearbeitung"
    ERHALTEN = "Erhalten"
    FEHLER = "Fehler"
    NICHT_VERFUEGBAR = "Nicht verf√ºgbar"


@dataclass
class FlurkartAnfrage:
    """Anfrage f√ºr elektronische Flurkarte"""
    anfrage_id: str
    projekt_id: str
    notar_id: str
    # Grundst√ºcksdaten
    bundesland: str
    landkreis: str
    gemeinde: str
    gemarkung: str
    flur: str
    flurstueck: str
    # Status
    status: str = DatenermittlungStatus.AUSSTEHEND.value
    angefragt_am: Optional[datetime] = None
    erhalten_am: Optional[datetime] = None
    # Kosten
    kosten: float = 0.0
    bezahlt: bool = False
    # Dokument
    flurkarte_pdf: Optional[bytes] = None
    flurkarte_dateiname: str = ""
    # Portal
    portal_name: str = ""  # z.B. "BORIS", "Geoportal Bayern"
    portal_url: str = ""
    notizen: str = ""


@dataclass
class GrundbuchAnfrage:
    """Anfrage f√ºr elektronisches Grundbuch"""
    anfrage_id: str
    projekt_id: str
    notar_id: str
    # Grundbuchdaten
    bundesland: str
    amtsgericht: str
    grundbuchbezirk: str
    grundbuchblatt: str
    # Status
    status: str = DatenermittlungStatus.AUSSTEHEND.value
    angefragt_am: Optional[datetime] = None
    erhalten_am: Optional[datetime] = None
    # Unterst√ºtzung
    egvp_unterstuetzt: bool = True  # Elektronisches Gerichts- und Verwaltungspostfach
    solum_star_unterstuetzt: bool = False  # SolumSTAR System
    # Kosten
    kosten: float = 0.0
    bezahlt: bool = False
    # Dokumente
    grundbuchauszug_pdf: Optional[bytes] = None
    grundbuchauszug_dateiname: str = ""
    abteilung_1: str = ""  # Eigent√ºmer
    abteilung_2: str = ""  # Lasten und Beschr√§nkungen
    abteilung_3: str = ""  # Hypotheken, Grundschulden
    notizen: str = ""


@dataclass
class BaulastenAnfrage:
    """Anfrage f√ºr Baulastenverzeichnis"""
    anfrage_id: str
    projekt_id: str
    notar_id: str
    # Objektdaten
    bundesland: str
    landkreis: str
    gemeinde: str
    strasse: str
    hausnummer: str
    plz: str
    # Zust√§ndiges Bauamt
    bauamt_name: str = ""
    bauamt_adresse: str = ""
    bauamt_telefon: str = ""
    bauamt_email: str = ""
    bauamt_url: str = ""
    # Status
    status: str = DatenermittlungStatus.AUSSTEHEND.value
    angefragt_am: Optional[datetime] = None
    erhalten_am: Optional[datetime] = None
    # Ergebnis
    baulasten_vorhanden: bool = False
    baulasten_beschreibung: str = ""
    auskunft_pdf: Optional[bytes] = None
    kosten: float = 0.0
    notizen: str = ""


@dataclass
class SteuerIDAbfrage:
    """Steuer-ID Abfrage f√ºr K√§ufer/Verk√§ufer"""
    abfrage_id: str
    projekt_id: str
    notar_id: str
    # Person
    person_typ: str  # "K√§ufer" oder "Verk√§ufer"
    person_id: str
    person_name: str
    # Adressdaten (f√ºr Finanzamt-Zuordnung)
    plz: str
    ort: str
    bundesland: str
    # Steuer-ID
    steuer_id: str = ""
    steuer_id_bestaetigt: bool = False
    # Zust√§ndiges Finanzamt
    finanzamt_name: str = ""
    finanzamt_adresse: str = ""
    finanzamt_telefon: str = ""
    finanzamt_email: str = ""
    finanzamt_nummer: str = ""  # Beh√∂rdennummer
    # Status
    status: str = DatenermittlungStatus.AUSSTEHEND.value
    erfasst_am: datetime = field(default_factory=datetime.now)
    notizen: str = ""


@dataclass
class GrunderwerbsteuerMeldung:
    """Meldung an Finanzamt f√ºr Grunderwerbsteuer"""
    meldung_id: str
    projekt_id: str
    notar_id: str
    # Kaufvertragsdaten
    kaufpreis: float
    kaufvertrag_datum: Optional[date] = None
    urkundennummer: str = ""
    # Parteien
    kaeufer_ids: List[str] = field(default_factory=list)
    verkaeufer_ids: List[str] = field(default_factory=list)
    # Objekt
    objekt_adresse: str = ""
    gemarkung: str = ""
    flur: str = ""
    flurstueck: str = ""
    grundbuchblatt: str = ""
    # Zust√§ndiges Finanzamt (Grunderwerbsteuer-Stelle)
    finanzamt_name: str = ""
    finanzamt_adresse: str = ""
    finanzamt_aktenzeichen: str = ""
    # Steuersatz nach Bundesland
    bundesland: str = ""
    steuersatz: float = 0.0  # z.B. 6.5 f√ºr 6,5%
    geschaetzte_steuer: float = 0.0
    # Status
    status: str = DatenermittlungStatus.AUSSTEHEND.value
    gemeldet_am: Optional[datetime] = None
    bescheid_erhalten_am: Optional[datetime] = None
    bescheid_pdf: Optional[bytes] = None
    steuerbetrag_festgesetzt: float = 0.0
    faellig_am: Optional[date] = None
    bezahlt: bool = False
    bezahlt_am: Optional[date] = None
    unbedenklichkeitsbescheinigung: Optional[bytes] = None
    notizen: str = ""


@dataclass
class VorkaufsrechtAnfrage:
    """Anfrage auf Vorkaufsrecht an Gemeinde/Stadt"""
    anfrage_id: str
    projekt_id: str
    notar_id: str
    # Gemeinde/Stadt
    gemeinde_name: str
    gemeinde_adresse: str = ""
    gemeinde_telefon: str = ""
    gemeinde_email: str = ""
    gemeinde_ansprechpartner: str = ""
    # Objektdaten
    objekt_adresse: str = ""
    gemarkung: str = ""
    flur: str = ""
    flurstueck: str = ""
    grundstuecksgroesse_qm: float = 0.0
    # Kaufvertragsdaten
    kaufpreis: float = 0.0
    urkundennummer: str = ""
    kaufvertrag_datum: Optional[date] = None
    # Status
    status: str = DatenermittlungStatus.AUSSTEHEND.value
    angefragt_am: Optional[datetime] = None
    frist_bis: Optional[date] = None  # 2 Monate nach Anfrage
    # Ergebnis
    vorkaufsrecht_ausgeubt: Optional[bool] = None  # None = noch nicht beantwortet
    antwort_erhalten_am: Optional[datetime] = None
    negativzeugnis_pdf: Optional[bytes] = None  # Verzichtserkl√§rung
    # Grund f√ºr Vorkaufsrecht (falls ausge√ºbt)
    vorkaufsrecht_grund: str = ""  # z.B. "st√§dtebauliche Ma√ünahme"
    notizen: str = ""


# ============================================================================
# DOKUMENTEN-MANAGEMENT-SYSTEM MIT KAMERA-SCANNER
# ============================================================================

class DokumentTyp(Enum):
    """Typen von Dokumenten f√ºr automatische Zuordnung"""
    PERSONALAUSWEIS = "Personalausweis"
    REISEPASS = "Reisepass"
    GRUNDBUCHAUSZUG = "Grundbuchauszug"
    FLURKARTE = "Flurkarte"
    ENERGIEAUSWEIS = "Energieausweis"
    KAUFVERTRAG = "Kaufvertrag"
    FINANZIERUNGSBESTAETIGUNG = "Finanzierungsbest√§tigung"
    GEHALTSNACHWEIS = "Gehaltsnachweis"
    STEUERBESCHEID = "Steuerbescheid"
    KONTOAUSZUG = "Kontoauszug"
    BAULASTENVERZEICHNIS = "Baulastenverzeichnis"
    TEILUNGSERKLAERUNG = "Teilungserkl√§rung"
    PROTOKOLL_WEG = "Protokoll WEG"
    WIRTSCHAFTSPLAN = "Wirtschaftsplan"
    EXPOSE = "Expos√©"
    VOLLMACHT = "Vollmacht"
    SONSTIGES = "Sonstiges"


# Standard-Ordnerstruktur pro Rolle
STANDARD_ORDNER = {
    UserRole.KAEUFER.value: [
        {"name": "Pers√∂nliche Dokumente", "typen": [DokumentTyp.PERSONALAUSWEIS, DokumentTyp.REISEPASS]},
        {"name": "Finanzierung", "typen": [DokumentTyp.FINANZIERUNGSBESTAETIGUNG, DokumentTyp.GEHALTSNACHWEIS, DokumentTyp.STEUERBESCHEID, DokumentTyp.KONTOAUSZUG]},
        {"name": "Kaufunterlagen", "typen": [DokumentTyp.KAUFVERTRAG, DokumentTyp.GRUNDBUCHAUSZUG]},
        {"name": "Objektdokumente", "typen": [DokumentTyp.ENERGIEAUSWEIS, DokumentTyp.FLURKARTE, DokumentTyp.EXPOSE]},
        {"name": "Sonstiges", "typen": [DokumentTyp.SONSTIGES]}
    ],
    UserRole.VERKAEUFER.value: [
        {"name": "Pers√∂nliche Dokumente", "typen": [DokumentTyp.PERSONALAUSWEIS, DokumentTyp.REISEPASS]},
        {"name": "Objektdokumente", "typen": [DokumentTyp.GRUNDBUCHAUSZUG, DokumentTyp.FLURKARTE, DokumentTyp.ENERGIEAUSWEIS, DokumentTyp.BAULASTENVERZEICHNIS]},
        {"name": "WEG-Unterlagen", "typen": [DokumentTyp.TEILUNGSERKLAERUNG, DokumentTyp.PROTOKOLL_WEG, DokumentTyp.WIRTSCHAFTSPLAN]},
        {"name": "Kaufvertrag", "typen": [DokumentTyp.KAUFVERTRAG, DokumentTyp.VOLLMACHT]},
        {"name": "Sonstiges", "typen": [DokumentTyp.SONSTIGES]}
    ],
    UserRole.MAKLER.value: [
        {"name": "Expos√© & Marketing", "typen": [DokumentTyp.EXPOSE]},
        {"name": "Objektdokumente", "typen": [DokumentTyp.GRUNDBUCHAUSZUG, DokumentTyp.FLURKARTE, DokumentTyp.ENERGIEAUSWEIS]},
        {"name": "Vertragsdokumente", "typen": [DokumentTyp.KAUFVERTRAG, DokumentTyp.VOLLMACHT]},
        {"name": "Kundendokumente", "typen": [DokumentTyp.PERSONALAUSWEIS, DokumentTyp.REISEPASS]},
        {"name": "Sonstiges", "typen": [DokumentTyp.SONSTIGES]}
    ],
    UserRole.NOTAR.value: [
        {"name": "Ausweisdokumente", "typen": [DokumentTyp.PERSONALAUSWEIS, DokumentTyp.REISEPASS]},
        {"name": "Grundbuch & Kataster", "typen": [DokumentTyp.GRUNDBUCHAUSZUG, DokumentTyp.FLURKARTE, DokumentTyp.BAULASTENVERZEICHNIS]},
        {"name": "Kaufvertrag", "typen": [DokumentTyp.KAUFVERTRAG]},
        {"name": "WEG-Unterlagen", "typen": [DokumentTyp.TEILUNGSERKLAERUNG, DokumentTyp.PROTOKOLL_WEG]},
        {"name": "Finanzierung", "typen": [DokumentTyp.FINANZIERUNGSBESTAETIGUNG]},
        {"name": "Vollmachten", "typen": [DokumentTyp.VOLLMACHT]},
        {"name": "Sonstiges", "typen": [DokumentTyp.SONSTIGES]}
    ],
    UserRole.FINANZIERER.value: [
        {"name": "Bonit√§tsunterlagen", "typen": [DokumentTyp.GEHALTSNACHWEIS, DokumentTyp.STEUERBESCHEID, DokumentTyp.KONTOAUSZUG]},
        {"name": "Objektdokumente", "typen": [DokumentTyp.GRUNDBUCHAUSZUG, DokumentTyp.FLURKARTE, DokumentTyp.ENERGIEAUSWEIS, DokumentTyp.EXPOSE]},
        {"name": "Pers√∂nliche Dokumente", "typen": [DokumentTyp.PERSONALAUSWEIS, DokumentTyp.REISEPASS]},
        {"name": "Vertragsdokumente", "typen": [DokumentTyp.KAUFVERTRAG, DokumentTyp.FINANZIERUNGSBESTAETIGUNG]},
        {"name": "Sonstiges", "typen": [DokumentTyp.SONSTIGES]}
    ]
}


@dataclass
class DokumentenOrdner:
    """Ordner f√ºr Dokumente eines Benutzers"""
    ordner_id: str
    user_id: str
    projekt_id: str = ""
    name: str = ""
    beschreibung: str = ""
    standard_dokument_typen: List[str] = field(default_factory=list)
    dokument_ids: List[str] = field(default_factory=list)
    erstellt_am: datetime = field(default_factory=datetime.now)
    ist_system_ordner: bool = False  # True = kann nicht gel√∂scht werden


@dataclass
class GescanntesDokument:
    """Ein gescanntes oder hochgeladenes Dokument"""
    dokument_id: str
    user_id: str
    projekt_id: str = ""
    ordner_id: str = ""
    # Datei-Informationen
    dateiname: str = ""
    original_dateiname: str = ""
    dateityp: str = ""  # pdf, jpg, png
    dateigroesse_bytes: int = 0
    datei_inhalt: Optional[bytes] = None
    # Dokumenten-Klassifizierung
    dokument_typ: str = DokumentTyp.SONSTIGES.value
    dokument_typ_erkannt: bool = False  # True = automatisch erkannt
    # OCR & PDF-A
    ist_ocr_verarbeitet: bool = False
    ocr_text: str = ""
    ist_pdf_a: bool = False
    pdf_a_version: str = ""  # z.B. "PDF/A-1b"
    # Scan-Informationen
    gescannt_mit_kamera: bool = False
    kamera_typ: str = ""  # "front" oder "back"
    scan_qualitaet: str = ""  # "hoch", "mittel", "niedrig"
    # Metadaten
    hochgeladen_am: datetime = field(default_factory=datetime.now)
    geaendert_am: Optional[datetime] = None
    notizen: str = ""
    tags: List[str] = field(default_factory=list)


# Schl√ºsselw√∂rter f√ºr automatische Dokumenttyp-Erkennung
DOKUMENT_ERKENNUNGS_KEYWORDS = {
    DokumentTyp.PERSONALAUSWEIS.value: ["personalausweis", "identity card", "ausweisnummer", "g√ºltig bis", "staatsangeh√∂rigkeit"],
    DokumentTyp.REISEPASS.value: ["reisepass", "passport", "passnummer", "nationality"],
    DokumentTyp.GRUNDBUCHAUSZUG.value: ["grundbuch", "abteilung i", "abteilung ii", "abteilung iii", "eigent√ºmer", "flur", "flurst√ºck"],
    DokumentTyp.FLURKARTE.value: ["flurkarte", "liegenschaftskarte", "kataster", "gemarkung", "flurst√ºck"],
    DokumentTyp.ENERGIEAUSWEIS.value: ["energieausweis", "energiebedarf", "energieverbrauch", "kwh", "endenergie", "prim√§renergie"],
    DokumentTyp.KAUFVERTRAG.value: ["kaufvertrag", "verkauf", "ver√§u√üerung", "√ºbereignung", "auflassung", "notar"],
    DokumentTyp.FINANZIERUNGSBESTAETIGUNG.value: ["finanzierungsbest√§tigung", "darlehen", "kredit", "finanzierung zugesagt", "kreditbetrag"],
    DokumentTyp.GEHALTSNACHWEIS.value: ["gehaltsabrechnung", "lohnabrechnung", "brutto", "netto", "steuerklasse", "arbeitgeber"],
    DokumentTyp.STEUERBESCHEID.value: ["steuerbescheid", "einkommensteuer", "finanzamt", "steuernummer", "festsetzung"],
    DokumentTyp.KONTOAUSZUG.value: ["kontoauszug", "kontostand", "saldo", "buchung", "iban", "bic"],
    DokumentTyp.BAULASTENVERZEICHNIS.value: ["baulastenverzeichnis", "baulast", "bauamt", "bauordnung"],
    DokumentTyp.TEILUNGSERKLAERUNG.value: ["teilungserkl√§rung", "wohnungseigentum", "miteigentum", "sondereigentum", "gemeinschaftseigentum"],
    DokumentTyp.PROTOKOLL_WEG.value: ["eigent√ºmerversammlung", "protokoll", "weg", "beschluss", "wohnungseigent√ºmer"],
    DokumentTyp.WIRTSCHAFTSPLAN.value: ["wirtschaftsplan", "hausgeld", "r√ºcklage", "instandhaltung", "betriebskosten"],
    DokumentTyp.EXPOSE.value: ["expos√©", "objekt", "immobilie", "verkaufspreis", "wohnfl√§che", "zimmer"],
    DokumentTyp.VOLLMACHT.value: ["vollmacht", "bevollm√§chtigt", "vertretung", "handeln im namen"]
}


def erkenne_dokument_typ(text: str, dateiname: str = "") -> Tuple[str, float]:
    """
    Erkennt den Dokumenttyp anhand von OCR-Text und Dateiname.
    Gibt Dokumenttyp und Konfidenz (0-1) zur√ºck.
    """
    text_lower = text.lower()
    dateiname_lower = dateiname.lower()

    beste_treffer = []

    for dok_typ, keywords in DOKUMENT_ERKENNUNGS_KEYWORDS.items():
        treffer = 0
        for keyword in keywords:
            if keyword in text_lower or keyword in dateiname_lower:
                treffer += 1

        if treffer > 0:
            konfidenz = min(treffer / len(keywords), 1.0)
            beste_treffer.append((dok_typ, konfidenz))

    if beste_treffer:
        beste_treffer.sort(key=lambda x: x[1], reverse=True)
        return beste_treffer[0]

    return DokumentTyp.SONSTIGES.value, 0.0


def ordner_fuer_dokument_typ(user_rolle: str, dokument_typ: str) -> str:
    """Findet den passenden Ordner f√ºr einen Dokumenttyp basierend auf der Benutzerrolle"""
    ordner_config = STANDARD_ORDNER.get(user_rolle, STANDARD_ORDNER[UserRole.KAEUFER.value])

    for ordner in ordner_config:
        typen_values = [t.value if isinstance(t, DokumentTyp) else t for t in ordner['typen']]
        if dokument_typ in typen_values:
            return ordner['name']

    return "Sonstiges"


def initialisiere_benutzer_ordner(user_id: str, user_rolle: str, projekt_id: str = "") -> List[DokumentenOrdner]:
    """Erstellt die Standard-Ordnerstruktur f√ºr einen Benutzer"""
    ordner_liste = []
    ordner_config = STANDARD_ORDNER.get(user_rolle, STANDARD_ORDNER[UserRole.KAEUFER.value])

    for idx, config in enumerate(ordner_config):
        ordner = DokumentenOrdner(
            ordner_id=f"ord_{user_id}_{projekt_id}_{idx}",
            user_id=user_id,
            projekt_id=projekt_id,
            name=config['name'],
            standard_dokument_typen=[t.value if isinstance(t, DokumentTyp) else t for t in config['typen']],
            ist_system_ordner=True
        )
        ordner_liste.append(ordner)

    return ordner_liste


def konvertiere_zu_pdf_a(datei_inhalt: bytes, dateiname: str) -> Tuple[bytes, bool, str]:
    """
    Konvertiert ein Dokument zu PDF/A Format.
    In Produktion w√ºrde hier eine echte PDF/A-Konvertierung erfolgen (z.B. mit ghostscript).
    Gibt (konvertierte_bytes, erfolg, pdf_a_version) zur√ºck.
    """
    # Simulation - in Produktion mit ghostscript oder √§hnlichem
    # gs -dPDFA -dBATCH -dNOPAUSE -sProcessColorModel=DeviceRGB -sDEVICE=pdfwrite
    #    -sPDFACompatibilityPolicy=1 -sOutputFile=output.pdf input.pdf

    if dateiname.lower().endswith('.pdf'):
        # PDF bereits vorhanden, markiere als PDF/A (Simulation)
        return datei_inhalt, True, "PDF/A-1b"
    elif dateiname.lower().endswith(('.jpg', '.jpeg', '.png')):
        # Bild zu PDF konvertieren (Simulation)
        # In Produktion: Pillow + reportlab oder √§hnlich
        return datei_inhalt, True, "PDF/A-1b"
    else:
        return datei_inhalt, False, ""


def render_kamera_scanner(key_prefix: str, context: str = "dokument") -> Optional[Dict]:
    """
    Rendert einen Kamera-Scanner mit Auswahl von Vorder-/R√ºckkamera.
    Gibt die gescannten Daten zur√ºck oder None.
    """
    st.markdown("#### üì∑ Dokument mit Kamera scannen")

    # Kamera-Auswahl
    col_cam1, col_cam2 = st.columns(2)
    with col_cam1:
        kamera_auswahl = st.radio(
            "Kamera ausw√§hlen",
            options=["üì± R√ºckkamera (Hauptkamera)", "ü§≥ Frontkamera"],
            key=f"{key_prefix}_kamera_auswahl",
            horizontal=True,
            help="Die R√ºckkamera (Hauptkamera) liefert meist bessere Qualit√§t f√ºr Dokumente"
        )

    with col_cam2:
        qualitaet = st.select_slider(
            "Scan-Qualit√§t",
            options=["Niedrig", "Mittel", "Hoch"],
            value="Hoch",
            key=f"{key_prefix}_qualitaet",
            help="H√∂here Qualit√§t = gr√∂√üere Datei, bessere OCR-Erkennung"
        )

    # Kamera-Facing bestimmen
    facing_mode = "environment" if "R√ºck" in kamera_auswahl else "user"

    # JavaScript f√ºr Kamera-Zugriff einbetten
    kamera_html = f"""
    <style>
        .camera-container {{
            text-align: center;
            margin: 10px 0;
        }}
        .camera-video {{
            width: 100%;
            max-width: 400px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }}
        .camera-btn {{
            margin: 10px 5px;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
        }}
        .capture-btn {{
            background-color: #4CAF50;
            color: white;
            border: none;
        }}
        .switch-btn {{
            background-color: #2196F3;
            color: white;
            border: none;
        }}
    </style>
    <div class="camera-container" id="camera_{key_prefix}">
        <p>üì∑ Klicken Sie auf "Kamera starten" um ein Dokument zu scannen</p>
        <p><small>Kamera: {kamera_auswahl} | Qualit√§t: {qualitaet}</small></p>
    </div>
    """

    st.markdown(kamera_html, unsafe_allow_html=True)

    # Streamlit native Kamera-Input als Fallback
    st.markdown("---")
    st.markdown("**Alternative: Datei hochladen oder Foto aufnehmen**")

    camera_input = st.camera_input(
        f"üì∏ Foto aufnehmen ({context})",
        key=f"{key_prefix}_camera_input",
        help="Nutzen Sie die Kamera Ihres Ger√§ts"
    )

    if camera_input:
        # Bild wurde aufgenommen
        return {
            'datei': camera_input,
            'dateiname': f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jpg",
            'kamera_typ': "back" if "R√ºck" in kamera_auswahl else "front",
            'qualitaet': qualitaet.lower(),
            'gescannt': True
        }

    return None


def render_dokument_upload_mit_scanner(
    key_prefix: str,
    user_id: str,
    user_rolle: str,
    projekt_id: str = "",
    erlaubte_typen: List[str] = None,
    auto_ordner: bool = True,
    kontext: str = "Dokument"
) -> Optional[GescanntesDokument]:
    """
    Universelle Dokument-Upload-Komponente mit Kamera-Scanner und automatischer Zuordnung.
    """
    if erlaubte_typen is None:
        erlaubte_typen = ["pdf", "jpg", "jpeg", "png", "tiff", "bmp"]

    st.markdown(f"### üìÑ {kontext} hochladen oder scannen")

    # Tabs f√ºr Upload-Methoden
    upload_tabs = st.tabs(["üìÅ Datei hochladen", "üì∑ Mit Kamera scannen"])

    datei_daten = None
    scan_info = None

    with upload_tabs[0]:
        # Klassischer Datei-Upload
        uploaded_file = st.file_uploader(
            f"{kontext} ausw√§hlen",
            type=erlaubte_typen,
            key=f"{key_prefix}_file_upload",
            help=f"Erlaubte Formate: {', '.join(erlaubte_typen)}"
        )

        if uploaded_file:
            datei_daten = {
                'datei': uploaded_file,
                'dateiname': uploaded_file.name,
                'gescannt': False
            }

    with upload_tabs[1]:
        # Kamera-Scanner
        scan_result = render_kamera_scanner(key_prefix, kontext)
        if scan_result:
            datei_daten = scan_result
            scan_info = {
                'kamera_typ': scan_result.get('kamera_typ', ''),
                'qualitaet': scan_result.get('qualitaet', '')
            }

    if not datei_daten:
        return None

    # Datei verarbeiten
    datei = datei_daten['datei']
    dateiname = datei_daten['dateiname']
    datei_bytes = datei.getvalue() if hasattr(datei, 'getvalue') else datei.read()

    st.success(f"‚úÖ Datei geladen: {dateiname} ({len(datei_bytes) / 1024:.1f} KB)")

    # OCR durchf√ºhren (simuliert)
    st.markdown("---")
    with st.expander("üîç Dokumenterkennung & OCR", expanded=True):
        ocr_text = ""

        if st.button("üîç Dokument analysieren", key=f"{key_prefix}_analyze"):
            with st.spinner("Analysiere Dokument..."):
                # Simulierte OCR-Analyse
                ocr_text = f"[OCR-Text f√ºr {dateiname}]"

                # Dokumenttyp erkennen
                erkannter_typ, konfidenz = erkenne_dokument_typ(ocr_text, dateiname)

                st.info(f"üìã **Erkannter Dokumenttyp:** {erkannter_typ} (Konfidenz: {konfidenz*100:.0f}%)")

                # Ordner-Vorschlag
                if auto_ordner:
                    vorgeschlagener_ordner = ordner_fuer_dokument_typ(user_rolle, erkannter_typ)
                    st.info(f"üìÅ **Empfohlener Ordner:** {vorgeschlagener_ordner}")

    # Dokumenttyp manuell w√§hlen/best√§tigen
    st.markdown("---")
    st.markdown("#### üìã Dokumentdetails")

    col_typ, col_ordner = st.columns(2)

    with col_typ:
        dokument_typ = st.selectbox(
            "Dokumenttyp",
            options=[t.value for t in DokumentTyp],
            key=f"{key_prefix}_dok_typ",
            help="W√§hlen Sie den passenden Dokumenttyp"
        )

    with col_ordner:
        # Ordner-Auswahl basierend auf Rolle
        ordner_optionen = [o['name'] for o in STANDARD_ORDNER.get(user_rolle, STANDARD_ORDNER[UserRole.KAEUFER.value])]
        vorgeschlagener = ordner_fuer_dokument_typ(user_rolle, dokument_typ)
        default_idx = ordner_optionen.index(vorgeschlagener) if vorgeschlagener in ordner_optionen else 0

        ordner_name = st.selectbox(
            "Zielordner",
            options=ordner_optionen,
            index=default_idx,
            key=f"{key_prefix}_ordner",
            help="Der Ordner wird automatisch vorgeschlagen, kann aber ge√§ndert werden"
        )

    # PDF-A Konvertierung
    st.markdown("---")
    col_pdfa, col_ocr = st.columns(2)

    with col_pdfa:
        als_pdf_a = st.checkbox(
            "üìÑ Als PDF/A speichern (archivierbar)",
            value=True,
            key=f"{key_prefix}_pdfa",
            help="PDF/A ist ein ISO-Standard f√ºr langfristige Archivierung"
        )

    with col_ocr:
        mit_ocr = st.checkbox(
            "üîç OCR durchf√ºhren (durchsuchbar)",
            value=True,
            key=f"{key_prefix}_ocr",
            help="Text im Dokument wird erkannt und durchsuchbar gemacht"
        )

    # Notizen
    notizen = st.text_area(
        "Notizen (optional)",
        placeholder="Zus√§tzliche Informationen zum Dokument...",
        key=f"{key_prefix}_notizen"
    )

    # Speichern
    if st.button("üíæ Dokument speichern", type="primary", key=f"{key_prefix}_save"):
        # PDF-A Konvertierung
        if als_pdf_a:
            datei_bytes, pdf_a_erfolg, pdf_a_version = konvertiere_zu_pdf_a(datei_bytes, dateiname)
            if not dateiname.lower().endswith('.pdf'):
                dateiname = dateiname.rsplit('.', 1)[0] + '.pdf'
        else:
            pdf_a_erfolg = False
            pdf_a_version = ""

        # Dokument erstellen
        dok_id = f"dok_{datetime.now().strftime('%Y%m%d%H%M%S')}_{user_id[:8]}"

        neues_dokument = GescanntesDokument(
            dokument_id=dok_id,
            user_id=user_id,
            projekt_id=projekt_id,
            ordner_id="",  # Wird sp√§ter zugewiesen
            dateiname=dateiname,
            original_dateiname=datei_daten['dateiname'],
            dateityp=dateiname.rsplit('.', 1)[-1].lower(),
            dateigroesse_bytes=len(datei_bytes),
            datei_inhalt=datei_bytes,
            dokument_typ=dokument_typ,
            dokument_typ_erkannt=False,
            ist_ocr_verarbeitet=mit_ocr,
            ocr_text=ocr_text if mit_ocr else "",
            ist_pdf_a=pdf_a_erfolg,
            pdf_a_version=pdf_a_version if pdf_a_erfolg else "",
            gescannt_mit_kamera=datei_daten.get('gescannt', False),
            kamera_typ=scan_info.get('kamera_typ', '') if scan_info else "",
            scan_qualitaet=scan_info.get('qualitaet', '') if scan_info else "",
            notizen=notizen
        )

        st.success(f"‚úÖ Dokument '{dateiname}' wurde gespeichert!")

        if pdf_a_erfolg:
            st.info(f"üìÑ Konvertiert zu {pdf_a_version}")

        return neues_dokument

    return None


def render_ordner_verwaltung(user_id: str, user_rolle: str, projekt_id: str = ""):
    """Zeigt die Ordner-Verwaltung mit allen Dokumenten und Dateimanagement"""
    st.markdown("### üìÅ Dokumenten-Verwaltung")

    # Initialisiere Ordner im Session State falls n√∂tig
    ordner_key = f"dokument_ordner_{user_id}_{projekt_id}"
    if ordner_key not in st.session_state:
        st.session_state[ordner_key] = initialisiere_benutzer_ordner(user_id, user_rolle, projekt_id)

    dokumente_key = f"dokumente_{user_id}_{projekt_id}"
    if dokumente_key not in st.session_state:
        st.session_state[dokumente_key] = {}

    ordner_liste = st.session_state[ordner_key]
    dokumente = st.session_state[dokumente_key]

    # Ordner als Sidebar oder Tabs
    ordner_namen = [o.name for o in ordner_liste]
    selected_ordner_name = st.selectbox(
        "üìÅ Ordner ausw√§hlen",
        options=ordner_namen,
        key=f"ordner_select_{user_id}_{projekt_id}"
    )

    selected_ordner = next((o for o in ordner_liste if o.name == selected_ordner_name), None)

    if not selected_ordner:
        return

    st.markdown(f"#### üìÇ {selected_ordner.name}")

    # Dokumente in diesem Ordner
    ordner_dokumente = [d for d in dokumente.values() if d.ordner_id == selected_ordner.ordner_id]

    if ordner_dokumente:
        for dok in ordner_dokumente:
            with st.expander(f"üìÑ {dok.dateiname} ({dok.dokument_typ})"):
                col1, col2 = st.columns([2, 1])

                with col1:
                    st.write(f"**Typ:** {dok.dokument_typ}")
                    st.write(f"**Gr√∂√üe:** {dok.dateigroesse_bytes / 1024:.1f} KB")
                    st.write(f"**Hochgeladen:** {dok.hochgeladen_am.strftime('%d.%m.%Y %H:%M')}")

                    if dok.ist_pdf_a:
                        st.success(f"‚úÖ PDF/A ({dok.pdf_a_version})")
                    if dok.ist_ocr_verarbeitet:
                        st.success("‚úÖ OCR durchsuchbar")
                    if dok.gescannt_mit_kamera:
                        st.info(f"üì∑ Gescannt mit {dok.kamera_typ}-Kamera")

                with col2:
                    # Download
                    if dok.datei_inhalt:
                        st.download_button(
                            "üì• Download",
                            data=dok.datei_inhalt,
                            file_name=dok.dateiname,
                            key=f"dl_{dok.dokument_id}"
                        )

                # Dateimanagement-Aktionen
                st.markdown("---")
                st.markdown("**Aktionen:**")
                col_move, col_copy, col_del = st.columns(3)

                with col_move:
                    ziel_ordner = st.selectbox(
                        "Verschieben nach",
                        options=[o.name for o in ordner_liste if o.ordner_id != selected_ordner.ordner_id],
                        key=f"move_{dok.dokument_id}"
                    )
                    if st.button("üì¶ Verschieben", key=f"move_btn_{dok.dokument_id}"):
                        ziel = next((o for o in ordner_liste if o.name == ziel_ordner), None)
                        if ziel:
                            dok.ordner_id = ziel.ordner_id
                            st.success(f"‚úÖ Verschoben nach '{ziel_ordner}'")
                            st.rerun()

                with col_copy:
                    kopie_ordner = st.selectbox(
                        "Kopieren nach",
                        options=[o.name for o in ordner_liste if o.ordner_id != selected_ordner.ordner_id],
                        key=f"copy_{dok.dokument_id}"
                    )
                    if st.button("üìã Kopieren", key=f"copy_btn_{dok.dokument_id}"):
                        ziel = next((o for o in ordner_liste if o.name == kopie_ordner), None)
                        if ziel:
                            # Kopie erstellen
                            kopie_id = f"dok_{datetime.now().strftime('%Y%m%d%H%M%S')}_copy"
                            kopie = GescanntesDokument(
                                dokument_id=kopie_id,
                                user_id=dok.user_id,
                                projekt_id=dok.projekt_id,
                                ordner_id=ziel.ordner_id,
                                dateiname=f"Kopie_{dok.dateiname}",
                                original_dateiname=dok.original_dateiname,
                                dateityp=dok.dateityp,
                                dateigroesse_bytes=dok.dateigroesse_bytes,
                                datei_inhalt=dok.datei_inhalt,
                                dokument_typ=dok.dokument_typ,
                                ist_ocr_verarbeitet=dok.ist_ocr_verarbeitet,
                                ocr_text=dok.ocr_text,
                                ist_pdf_a=dok.ist_pdf_a,
                                pdf_a_version=dok.pdf_a_version
                            )
                            dokumente[kopie_id] = kopie
                            st.success(f"‚úÖ Kopiert nach '{kopie_ordner}'")
                            st.rerun()

                with col_del:
                    if st.button("üóëÔ∏è L√∂schen", key=f"del_btn_{dok.dokument_id}", type="secondary"):
                        if dok.dokument_id in dokumente:
                            del dokumente[dok.dokument_id]
                            st.success("‚úÖ Dokument gel√∂scht")
                            st.rerun()
    else:
        st.info("üì≠ Dieser Ordner ist leer.")

    # Neues Dokument hochladen
    st.markdown("---")
    with st.expander("‚ûï Neues Dokument hinzuf√ºgen", expanded=False):
        neues_dok = render_dokument_upload_mit_scanner(
            key_prefix=f"upload_{selected_ordner.ordner_id}",
            user_id=user_id,
            user_rolle=user_rolle,
            projekt_id=projekt_id,
            kontext="Dokument"
        )

        if neues_dok:
            neues_dok.ordner_id = selected_ordner.ordner_id
            dokumente[neues_dok.dokument_id] = neues_dok
            st.rerun()


# Bundesland-spezifische Grunderwerbsteuers√§tze (Stand 2024)
GRUNDERWERBSTEUER_SAETZE = {
    "Baden-W√ºrttemberg": 5.0,
    "Bayern": 3.5,
    "Berlin": 6.0,
    "Brandenburg": 6.5,
    "Bremen": 5.0,
    "Hamburg": 5.5,
    "Hessen": 6.0,
    "Mecklenburg-Vorpommern": 6.0,
    "Niedersachsen": 5.0,
    "Nordrhein-Westfalen": 6.5,
    "Rheinland-Pfalz": 5.0,
    "Saarland": 6.5,
    "Sachsen": 5.5,
    "Sachsen-Anhalt": 5.0,
    "Schleswig-Holstein": 6.5,
    "Th√ºringen": 5.0
}

# Bundesl√§nder mit elektronischem Grundbuch (EGVP/SolumSTAR)
ELEKTRONISCHES_GRUNDBUCH_SUPPORT = {
    "Baden-W√ºrttemberg": {"egvp": True, "solum_star": True, "portal": "Grundbuchportal BW"},
    "Bayern": {"egvp": True, "solum_star": True, "portal": "Bayern-Portal"},
    "Berlin": {"egvp": True, "solum_star": False, "portal": "Berlin.de"},
    "Brandenburg": {"egvp": True, "solum_star": False, "portal": "Service Brandenburg"},
    "Bremen": {"egvp": True, "solum_star": False, "portal": "Bremen.de"},
    "Hamburg": {"egvp": True, "solum_star": False, "portal": "Hamburg.de"},
    "Hessen": {"egvp": True, "solum_star": True, "portal": "Service Hessen"},
    "Mecklenburg-Vorpommern": {"egvp": True, "solum_star": False, "portal": "MV-Portal"},
    "Niedersachsen": {"egvp": True, "solum_star": True, "portal": "Niedersachsen.de"},
    "Nordrhein-Westfalen": {"egvp": True, "solum_star": True, "portal": "NRW Geoportal"},
    "Rheinland-Pfalz": {"egvp": True, "solum_star": True, "portal": "RLP-Portal"},
    "Saarland": {"egvp": True, "solum_star": False, "portal": "Saarland.de"},
    "Sachsen": {"egvp": True, "solum_star": True, "portal": "Amt24 Sachsen"},
    "Sachsen-Anhalt": {"egvp": True, "solum_star": False, "portal": "Sachsen-Anhalt.de"},
    "Schleswig-Holstein": {"egvp": True, "solum_star": True, "portal": "SH-Portal"},
    "Th√ºringen": {"egvp": True, "solum_star": False, "portal": "Th√ºringen.de"}
}

# Geoportale f√ºr Flurkarten nach Bundesland
GEOPORTALE = {
    "Baden-W√ºrttemberg": {"name": "Geoportal BW", "url": "https://www.geoportal-bw.de/"},
    "Bayern": {"name": "BayernAtlas", "url": "https://geoportal.bayern.de/bayernatlas/"},
    "Berlin": {"name": "FIS-Broker", "url": "https://fbinter.stadt-berlin.de/fb/"},
    "Brandenburg": {"name": "Geoportal Brandenburg", "url": "https://geoportal.brandenburg.de/"},
    "Bremen": {"name": "GeoPortal Bremen", "url": "https://geoportal.bremen.de/"},
    "Hamburg": {"name": "Geoportal Hamburg", "url": "https://geoportal-hamburg.de/"},
    "Hessen": {"name": "Geoportal Hessen", "url": "https://www.geoportal.hessen.de/"},
    "Mecklenburg-Vorpommern": {"name": "GeoPortal.MV", "url": "https://www.geoportal-mv.de/"},
    "Niedersachsen": {"name": "LGLN", "url": "https://www.lgln.niedersachsen.de/"},
    "Nordrhein-Westfalen": {"name": "TIM-online", "url": "https://www.tim-online.nrw.de/"},
    "Rheinland-Pfalz": {"name": "Geoportal RLP", "url": "https://www.geoportal.rlp.de/"},
    "Saarland": {"name": "Geoportal Saarland", "url": "https://geoportal.saarland.de/"},
    "Sachsen": {"name": "GeoSN", "url": "https://geoportal.sachsen.de/"},
    "Sachsen-Anhalt": {"name": "Geodatenportal ST", "url": "https://www.geodatenportal.sachsen-anhalt.de/"},
    "Schleswig-Holstein": {"name": "Digitaler Atlas Nord", "url": "https://danord.gdi-sh.de/"},
    "Th√ºringen": {"name": "Geoproxy Th√ºringen", "url": "https://www.geoportal-th.de/"}
}


class TodoKategorie(Enum):
    """Kategorien f√ºr K√§ufer-Todos"""
    FINANZIERUNG = "Finanzierung"
    KAUFVERTRAG = "Kaufvertrag"
    DOKUMENTE = "Dokumente"
    AUSSTATTUNG = "Ausstattung & Ideen"
    UMZUG = "Umzug"
    SONSTIGES = "Sonstiges"

class TodoPrioritaet(Enum):
    """Priorit√§t f√ºr Todos"""
    HOCH = "Hoch"
    MITTEL = "Mittel"
    NIEDRIG = "Niedrig"

@dataclass
class KaeuferTodo:
    """Todo-Eintrag f√ºr K√§ufer"""
    todo_id: str
    kaeufer_id: str
    projekt_id: str
    titel: str
    beschreibung: str = ""
    kategorie: str = TodoKategorie.SONSTIGES.value
    prioritaet: str = TodoPrioritaet.MITTEL.value
    erledigt: bool = False
    erstellt_am: datetime = field(default_factory=datetime.now)
    erledigt_am: Optional[datetime] = None
    faellig_am: Optional[date] = None
    ist_system_todo: bool = False  # True = automatisch generiert, False = vom User erstellt
    system_typ: str = ""  # z.B. "finanzierung_anfrage", "dokument_hochladen"


class HandwerkerKategorie(Enum):
    """Kategorien f√ºr Handwerker-Empfehlungen"""
    ELEKTRIKER = "Elektriker"
    SANITAER = "Sanit√§r & Heizung"
    MALER = "Maler & Lackierer"
    TISCHLER = "Tischler & Schreiner"
    BODENLEGER = "Bodenleger"
    FLIESENLEGER = "Fliesenleger"
    DACHDECKER = "Dachdecker"
    GARTENBAU = "Garten- & Landschaftsbau"
    KUECHEN = "K√ºchenbau"
    FENSTER = "Fenster & T√ºren"
    UMZUG = "Umzugsunternehmen"
    REINIGUNG = "Reinigungsservice"
    ARCHITEKT = "Architekt & Planung"
    INNENAUSSTATTUNG = "Innenausstattung & Design"
    SONSTIGES = "Sonstiges"


class IdeenKategorie(Enum):
    """Kategorien f√ºr das Ideenboard"""
    EINRICHTUNG = "Einrichtung & M√∂bel"
    RENOVIERUNG = "Renovierung"
    LICHT = "Lichtkonzept"
    KUECHE = "K√ºche"
    BAD = "Bad & Sanit√§r"
    GARTEN = "Garten & Au√üenbereich"
    SMARTHOME = "Smart Home"
    FARBEN = "Farben & Wandgestaltung"
    BOEDEN = "B√∂den"
    SONSTIGES = "Sonstige Ideen"


@dataclass
class Handwerker:
    """Handwerker-Empfehlung vom Notar"""
    handwerker_id: str
    notar_id: str  # Wer hat ihn angelegt
    firmenname: str
    kategorie: str
    kontaktperson: str = ""
    telefon: str = ""
    email: str = ""
    adresse: str = ""
    webseite: str = ""
    beschreibung: str = ""
    bewertung: int = 0  # Durchschnittsbewertung 1-5 Sterne
    empfohlen: bool = True  # Vom Notar freigegeben
    erstellt_am: datetime = field(default_factory=datetime.now)
    notizen: str = ""
    anzahl_bewertungen: int = 0  # VERBESSERUNG 7: Anzahl der K√§ufer-Bewertungen

@dataclass
class HandwerkerBewertung:
    """VERBESSERUNG 7: Einzelbewertung eines Handwerkers durch K√§ufer"""
    bewertung_id: str
    handwerker_id: str
    kaeufer_id: str
    projekt_id: str  # In welchem Projekt kontaktiert
    sterne: int  # 1-5
    kommentar: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)


@dataclass
class IdeenboardEintrag:
    """Eintrag im Ideenboard des K√§ufers"""
    idee_id: str
    kaeufer_id: str
    projekt_id: str
    titel: str
    beschreibung: str = ""
    kategorie: str = IdeenKategorie.SONSTIGES.value
    bild_data: Optional[bytes] = None  # Optionales Inspirationsbild
    bild_url: str = ""  # Oder URL zu einem Bild
    prioritaet: str = TodoPrioritaet.MITTEL.value
    geschaetzte_kosten: float = 0.0
    notizen: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)
    umgesetzt: bool = False
    umgesetzt_am: Optional[datetime] = None


@dataclass
class WirtschaftsdatenDokument:
    """Wirtschaftsdaten des K√§ufers"""
    doc_id: str
    kaeufer_id: str
    doc_type: str
    filename: str
    upload_date: datetime
    pdf_data: bytes
    kategorie: str = "Noch zuzuordnen"
    ocr_text: str = ""
    sichtbar_fuer_makler: bool = False
    sichtbar_fuer_notar: bool = False
    freigegeben_fuer_notar: bool = False

@dataclass
class Notification:
    """Benachrichtigung"""
    notif_id: str
    user_id: str
    titel: str
    nachricht: str
    typ: str
    created_at: datetime
    gelesen: bool = False
    link: Optional[str] = None

@dataclass
class Comment:
    """Kommentar/Nachricht"""
    comment_id: str
    projekt_id: str
    user_id: str
    nachricht: str
    created_at: datetime
    sichtbar_fuer: List[str] = field(default_factory=list)

@dataclass
class Invitation:
    """Einladung"""
    invitation_id: str
    projekt_id: str
    email: str
    rolle: str
    eingeladen_von: str
    token: str
    created_at: datetime
    verwendet: bool = False

@dataclass
class User:
    """Benutzer"""
    user_id: str
    name: str
    email: str
    role: str
    password_hash: str
    projekt_ids: List[str] = field(default_factory=list)
    onboarding_complete: bool = False
    document_acceptances: List[DocumentAcceptance] = field(default_factory=list)
    notifications: List[str] = field(default_factory=list)
    # Personalausweis-Daten
    personal_daten: Optional['PersonalDaten'] = None
    ausweis_foto: Optional[bytes] = None  # Foto des Ausweises

@dataclass
class PersonalDaten:
    """Pers√∂nliche Daten aus Personalausweis/Reisepass"""
    # Aus dem Ausweis extrahierte Daten
    vorname: str = ""
    nachname: str = ""
    geburtsname: str = ""
    geburtsdatum: Optional[date] = None
    geburtsort: str = ""
    nationalitaet: str = "DEUTSCH"

    # Adresse
    strasse: str = ""
    hausnummer: str = ""
    plz: str = ""
    ort: str = ""

    # Ausweis-Infos
    ausweisnummer: str = ""
    ausweisart: str = "Personalausweis"  # oder "Reisepass"
    ausstellungsbehoerde: str = ""
    ausstellungsdatum: Optional[date] = None
    gueltig_bis: Optional[date] = None

    # Zus√§tzliche Infos
    augenfarbe: str = ""
    groesse_cm: int = 0
    geschlecht: str = ""  # "M", "W", "D"

    # OCR-Metadaten
    ocr_vertrauenswuerdigkeit: float = 0.0  # 0-1
    ocr_durchgefuehrt_am: Optional[datetime] = None
    manuell_bestaetigt: bool = False
    bestaetigt_am: Optional[datetime] = None

class PreisangebotStatus(Enum):
    """Status f√ºr Preisangebote"""
    OFFEN = "Offen"
    ANGENOMMEN = "Angenommen"
    ABGELEHNT = "Abgelehnt"
    GEGENANGEBOT = "Gegenangebot"
    ZURUECKGEZOGEN = "Zur√ºckgezogen"

@dataclass
class Preisangebot:
    """Preisangebot f√ºr Verhandlung zwischen K√§ufer und Verk√§ufer"""
    angebot_id: str
    projekt_id: str
    von_user_id: str  # Wer das Angebot macht
    von_rolle: str  # "K√§ufer" oder "Verk√§ufer"
    betrag: float  # Angebotener Preis
    nachricht: str = ""  # Optionale Nachricht/Begr√ºndung
    status: str = PreisangebotStatus.OFFEN.value
    erstellt_am: datetime = field(default_factory=datetime.now)
    beantwortet_am: Optional[datetime] = None
    antwort_nachricht: str = ""

@dataclass
class TimelineEvent:
    """Timeline-Event"""
    event_id: str
    projekt_id: str
    titel: str
    beschreibung: str
    status: str
    completed: bool
    completed_at: Optional[datetime] = None
    position: int = 0
    wartet_auf: Optional[str] = None

@dataclass
class Projekt:
    """Immobilien-Projekt/Transaktion"""
    projekt_id: str
    name: str
    beschreibung: str
    adresse: str = ""
    kaufpreis: float = 0.0
    expose_pdf: Optional[bytes] = None
    makler_id: str = ""
    kaeufer_ids: List[str] = field(default_factory=list)
    verkaeufer_ids: List[str] = field(default_factory=list)
    finanzierer_ids: List[str] = field(default_factory=list)
    notar_id: str = ""
    status: str = ProjektStatus.VORBEREITUNG.value
    expose_nach_akzeptanz: bool = True
    rechtsdokumente_erforderlich: bool = True  # M√ºssen K√§ufer/Verk√§ufer Datenschutz/AGB akzeptieren?
    preisverhandlung_erlaubt: bool = False  # K√∂nnen K√§ufer/Verk√§ufer √ºber Preis verhandeln?
    created_at: datetime = field(default_factory=datetime.now)
    timeline_events: List[str] = field(default_factory=list)
    notartermin: Optional[datetime] = None
    property_type: str = PropertyType.WOHNUNG.value  # Objektart
    expose_data_id: Optional[str] = None  # Verweis auf ExposeData
    termine: List[str] = field(default_factory=list)  # Liste von Termin-IDs

    # NEU: Verkn√ºpfung zur Notar-Akte
    akte_id: str = ""  # Verweis auf ImportierteAkte beim Notar
    aktenzeichen: str = ""  # z.B. "123/2025 M√ºller / Schmidt"

    # NEU: Strukturierte Parteien (ersetzt teilweise kaeufer_ids/verkaeufer_ids)
    parteien: List[str] = field(default_factory=list)  # Liste von Partei-IDs
    gesellschaften: List[str] = field(default_factory=list)  # Liste von Gesellschaft-IDs

    # NEU: Vertragstyp f√ºr Aktenbezeichnung
    vertragstyp: str = "Kaufvertrag"  # Kaufvertrag, √úberlassungsvertrag, Schenkung, etc.

class TerminTyp(Enum):
    """Termin-Typen"""
    BESICHTIGUNG = "Besichtigung"
    UEBERGABE = "√úbergabe"
    BEURKUNDUNG = "Beurkundung"
    KAUFPREISFAELLIGKEIT = "Kaufpreisf√§lligkeit"
    SCHLUESSELUEBERGABE = "Schl√ºssel√ºbergabe"
    DATENEINREICHUNG_FRIST = "Frist Dateneinreichung"
    FINANZIERUNGSZUSAGE = "Finanzierungszusage"
    GRUNDBUCHEINTRAG = "Grundbucheintrag"
    NOTARTERMIN_VORBESPRECHUNG = "Notartermin Vorbesprechung"
    WIDERRUFSENDE = "Ende Widerrufsfrist"
    SONSTIGES = "Sonstiges"

class TerminStatus(Enum):
    """Termin-Status"""
    VORGESCHLAGEN = "Vorgeschlagen"  # Notar hat Termine vorgeschlagen
    ANGEFRAGT = "Angefragt"  # Makler/K√§ufer/Verk√§ufer hat Termin angefragt
    AUSSTEHEND = "Ausstehend"  # Wartet auf Best√§tigung aller Parteien
    TEILWEISE_BESTAETIGT = "Teilweise best√§tigt"  # Einige haben best√§tigt
    BESTAETIGT = "Best√§tigt"  # Alle Parteien haben best√§tigt
    ABGESAGT = "Abgesagt"
    ABGESCHLOSSEN = "Abgeschlossen"

@dataclass
class Termin:
    """Termin f√ºr Besichtigung, √úbergabe oder Beurkundung"""
    termin_id: str
    projekt_id: str
    termin_typ: str  # TerminTyp value
    datum: date
    uhrzeit_start: str  # Format: "HH:MM"
    uhrzeit_ende: str  # Format: "HH:MM"
    tageszeit: str = ""  # "Vormittag" oder "Nachmittag"
    ort: str = ""  # Adresse/Ort des Termins
    beschreibung: str = ""
    status: str = TerminStatus.ANGEFRAGT.value

    # Ersteller und Beteiligte
    erstellt_von: str = ""  # User ID
    erstellt_am: datetime = field(default_factory=datetime.now)

    # Best√§tigungen (User ID -> Best√§tigungszeitpunkt)
    bestaetigt_von_makler: Optional[datetime] = None
    bestaetigt_von_kaeufer: List[str] = field(default_factory=list)  # Liste der K√§ufer-IDs die best√§tigt haben
    bestaetigt_von_verkaeufer: List[str] = field(default_factory=list)  # Liste der Verk√§ufer-IDs
    bestaetigt_von_notar: Optional[datetime] = None

    # F√ºr Outlook-Integration
    outlook_event_id: Optional[str] = None
    outlook_status: str = ""  # "provisorisch", "best√§tigt"

    # Kontaktdaten f√ºr Termin-Notizen
    kontakte: List[Dict[str, str]] = field(default_factory=list)  # Liste von {name, telefon, rolle}

    # Erinnerungen
    erinnerung_gesendet: bool = False
    erinnerung_gesendet_am: Optional[datetime] = None

    # Erweiterte Erinnerungen
    erinnerung_tage_vorher: List[int] = field(default_factory=lambda: [1])  # Standard: 1 Tag vorher
    alle_erinnerungen_gesendet: Dict[int, datetime] = field(default_factory=dict)  # Tage -> Zeitpunkt

    # Wer hat den Termin gesetzt
    gesetzt_von_rolle: str = ""  # "Notar", "Makler", "Finanzierer", "K√§ufer", "Verk√§ufer"

    # Sichtbarkeit f√ºr Rollen
    sichtbar_fuer: List[str] = field(default_factory=lambda: ["Makler", "K√§ufer", "Verk√§ufer", "Notar", "Finanzierer"])

    # Farbe f√ºr Kalenderanzeige (basierend auf Typ)
    farbe: str = "#3498db"  # Standard: Blau

@dataclass
class TerminVorschlag:
    """Terminvorschlag vom Notar"""
    vorschlag_id: str
    projekt_id: str
    termin_typ: str
    vorschlaege: List[Dict[str, Any]] = field(default_factory=list)  # Liste von {datum, uhrzeit_start, uhrzeit_ende, tageszeit}
    erstellt_am: datetime = field(default_factory=datetime.now)
    erstellt_von: str = ""  # Notar User ID
    status: str = "offen"  # "offen", "angenommen", "abgelehnt"
    ausgewaehlt_index: int = -1  # Welcher Vorschlag wurde gew√§hlt

@dataclass
class MaklerAgent:
    """Makler-Team-Mitglied"""
    agent_id: str
    name: str
    position: str  # z.B. "Gesch√§ftsf√ºhrer", "Immobilienberater"
    telefon: str
    email: str
    foto: Optional[bytes] = None

@dataclass
class MaklerProfile:
    """Makler-Profil"""
    profile_id: str
    makler_id: str
    firmenname: str
    adresse: str
    telefon: str
    email: str
    website: str = ""
    logo: Optional[bytes] = None
    team_mitglieder: List[MaklerAgent] = field(default_factory=list)
    backoffice_kontakt: str = ""
    backoffice_email: str = ""
    backoffice_telefon: str = ""
    created_at: datetime = field(default_factory=datetime.now)
    # Erweiterte Felder f√ºr Makler-Onboarding
    kurzvita: str = ""  # Kurze Beschreibung f√ºr Verk√§ufer
    spezialisierung: List[str] = field(default_factory=list)  # z.B. ["Ferienimmobilien", "Luxusimmobilien"]
    regionen: List[str] = field(default_factory=list)  # z.B. ["Mallorca", "Ibiza"]
    provision_kaeufer_prozent: float = 0.0
    provision_verkaeufer_prozent: float = 0.0
    agb_text: str = ""
    widerrufsbelehrung_text: str = ""
    datenschutz_text: str = ""
    maklervertrag_vorlage: str = ""
    # Notar-Empfehlung
    empfohlen_von_notar: bool = False
    empfohlen_am: Optional[datetime] = None
    empfohlen_von_notar_id: str = ""
    empfehlung_aktiv: bool = False
    # Onboarding-Status
    onboarding_token: str = ""
    onboarding_abgeschlossen: bool = False
    onboarding_email_gesendet: bool = False

class MaklerEmpfehlungStatus(Enum):
    """Status einer Makler-Empfehlung"""
    EINGELADEN = "Eingeladen"
    DATEN_EINGEGEBEN = "Daten eingegeben"
    FREIGEGEBEN = "Vom Notar freigegeben"
    ABGELEHNT = "Abgelehnt"
    DEAKTIVIERT = "Deaktiviert"

@dataclass
class MaklerEmpfehlung:
    """Makler-Empfehlung durch Notar f√ºr Verk√§ufer"""
    empfehlung_id: str
    notar_id: str
    makler_email: str
    makler_name: str = ""
    firmenname: str = ""
    status: str = MaklerEmpfehlungStatus.EINGELADEN.value
    eingeladen_am: datetime = field(default_factory=datetime.now)
    onboarding_token: str = ""
    makler_user_id: str = ""  # Nach Registrierung
    # Vom Makler eingegebene Daten
    kurzvita: str = ""
    telefon: str = ""
    website: str = ""
    adresse: str = ""
    spezialisierung: List[str] = field(default_factory=list)
    regionen: List[str] = field(default_factory=list)
    provision_kaeufer_prozent: float = 0.0
    provision_verkaeufer_prozent: float = 0.0
    agb_text: str = ""
    widerrufsbelehrung_text: str = ""
    datenschutz_text: str = ""
    logo: Optional[bytes] = None
    freigegeben_am: Optional[datetime] = None
    notiz_notar: str = ""  # Interne Notiz des Notars

@dataclass
class ExposeData:
    """Expos√©-Daten f√ºr PDF und Web-Generierung"""
    expose_id: str
    projekt_id: str

    # Basis-Informationen
    objekttitel: str = ""
    objektbeschreibung: str = ""
    lage_beschreibung: str = ""

    # Adresse
    strasse: str = ""
    hausnummer: str = ""
    plz: str = ""
    ort: str = ""
    land: str = "Deutschland"
    adresse_validiert: bool = False
    adresse_vorschlag: str = ""  # Vorschlag aus Internet-Validierung

    # Objektdaten
    objektart: str = PropertyType.WOHNUNG.value
    wohnflaeche: float = 0.0
    grundstuecksflaeche: float = 0.0
    anzahl_zimmer: float = 0.0
    anzahl_schlafzimmer: int = 0
    anzahl_badezimmer: int = 0
    anzahl_etagen: int = 0
    etage: str = ""
    baujahr: int = 0
    zustand: str = ""  # z.B. "Erstbezug", "Renoviert", "Sanierungsbed√ºrftig"
    ausstattung: str = ""  # Freitext

    # Nutzungsart
    nutzungsart: str = "Keine Angabe"  # "Ferienvermietung", "Dauerwohnen", "Zweitwohnung", "Keine Angabe"
    ferienvermietung_erlaubt: str = "Keine Angabe"  # "Ja", "Nein", "Keine Angabe"
    dauerwohnen_erlaubt: str = "Keine Angabe"
    zweitwohnung_erlaubt: str = "Keine Angabe"

    # Ausstattungsmerkmale (Boolean-Flags)
    hat_balkon: bool = False
    hat_terrasse: bool = False
    hat_garten: bool = False
    hat_garage: bool = False
    hat_tiefgarage: bool = False
    hat_stellplatz: bool = False
    hat_sauna: bool = False
    hat_gemeinschaftssauna: bool = False
    hat_schwimmbad: bool = False
    hat_gemeinschaftspool: bool = False
    hat_fahrstuhl: bool = False
    hat_meerblick: bool = False
    hat_bergblick: bool = False
    hat_seeblick: bool = False
    nichtraucher: bool = False
    haustiere_erlaubt: str = "Keine Angabe"  # "Ja", "Nein", "Auf Anfrage", "Keine Angabe"

    # Entfernungen
    entfernung_stadt_m: int = 0  # Meter zur n√§chsten Stadt
    entfernung_strand_m: int = 0  # Meter zum Strand
    entfernung_zentrum_m: int = 0  # Meter zum Ortszentrum
    entfernung_supermarkt_m: int = 0
    entfernung_arzt_m: int = 0
    entfernung_flughafen_km: int = 0

    # Preise
    kaufpreis: float = 0.0
    kaufpreis_vorschlag: float = 0.0  # Basierend auf Vergleichsdaten
    provision: str = ""
    hausgeld: float = 0.0
    grundsteuer: float = 0.0
    preis_pro_qm: float = 0.0  # Wird berechnet

    # Energie
    energieausweis_typ: str = ""  # "Verbrauch" oder "Bedarf"
    energieeffizienzklasse: str = ""
    endenergieverbrauch: float = 0.0
    wesentliche_energietraeger: str = ""
    baujahr_energieausweis: int = 0
    gueltig_bis: Optional[date] = None

    # Besonderheiten
    besonderheiten: str = ""
    verfuegbar_ab: Optional[date] = None

    # WEG-spezifisch (f√ºr Wohnungen)
    weg_verwaltung: str = ""
    ruecklage: float = 0.0

    # Marktanalyse / Vergleichsobjekte
    vergleichsobjekte: List[Dict[str, Any]] = field(default_factory=list)
    # Format: [{"titel": "...", "url": "...", "preis": 0, "qm": 0, "quelle": "immoscout/immowelt/..."}]

    # Bilder und Dokumente
    titelbild: Optional[bytes] = None
    weitere_bilder: List[bytes] = field(default_factory=list)
    grundrisse: List[bytes] = field(default_factory=list)
    lageplan: Optional[bytes] = None

    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

@dataclass
class DocumentRequest:
    """Dokumenten-Anforderung"""
    request_id: str
    projekt_id: str
    dokument_typ: str
    angefordert_von: str  # user_id
    angefordert_bei: str  # user_id
    status: str = DocumentRequestStatus.ANGEFORDERT.value
    nachricht: str = ""
    created_at: datetime = field(default_factory=datetime.now)
    bereitgestellt_am: Optional[datetime] = None
    dokument_id: Optional[str] = None

@dataclass
class NotarChecklist:
    """Notarielle Checklisten"""
    checklist_id: str
    projekt_id: str
    checklist_typ: str  # ChecklistType
    partei: str  # "K√§ufer" oder "Verk√§ufer"

    # Daten-Dictionary (flexibel f√ºr verschiedene Checklisten)
    daten: Dict[str, Any] = field(default_factory=dict)

    # Status
    vollstaendig: bool = False
    freigegeben: bool = False
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

@dataclass
class BankFolder:
    """Bankenmappe"""
    folder_id: str
    projekt_id: str
    erstellt_von: str  # user_id

    # Enthaltene Dokumente (IDs)
    expose_id: Optional[str] = None
    grundrisse_ids: List[str] = field(default_factory=list)
    dokument_ids: List[str] = field(default_factory=list)

    # Generiertes PDF
    pdf_data: Optional[bytes] = None

    created_at: datetime = field(default_factory=datetime.now)
    status: str = "Entwurf"

@dataclass
class NotarMitarbeiter:
    """Notar-Mitarbeiter mit Zugriffsrechten"""
    mitarbeiter_id: str
    notar_id: str  # Zugeh√∂riger Notar
    name: str
    email: str
    password_hash: str
    rolle: str  # NotarMitarbeiterRolle

    # Berechtigungen
    kann_checklisten_bearbeiten: bool = False
    kann_dokumente_freigeben: bool = False
    kann_termine_verwalten: bool = False
    kann_finanzierung_sehen: bool = False

    # Zugewiesene Projekte
    projekt_ids: List[str] = field(default_factory=list)

    created_at: datetime = field(default_factory=datetime.now)
    aktiv: bool = True

@dataclass
class Verk√§uferDokument:
    """Dokumente vom Verk√§ufer"""
    dokument_id: str
    verkaeufer_id: str
    projekt_id: str
    dokument_typ: str  # Verk√§uferDokumentTyp
    dateiname: str
    dateigr√∂√üe: int
    pdf_data: bytes

    # Metadaten
    beschreibung: str = ""
    gueltig_bis: Optional[date] = None

    # Freigaben
    freigegeben_fuer_makler: bool = False
    freigegeben_fuer_notar: bool = False
    freigegeben_fuer_finanzierer: bool = False
    freigegeben_fuer_kaeufer: bool = False

    upload_datum: datetime = field(default_factory=datetime.now)
    status: str = "Hochgeladen"  # Hochgeladen, Gepr√ºft, Freigegeben, Abgelehnt

# ============================================================================
# AKTENIMPORT - NOTAR AKTEN√úBERNAHME
# ============================================================================

class AktenDokumentTyp(Enum):
    """Standard-Dokumenttypen in einer Notarakte"""
    KAUFVERTRAG = "Kaufvertrag"
    KAUFVERTRAG_ENTWURF = "Kaufvertragsentwurf"
    GRUNDBUCHAUSZUG = "Grundbuchauszug"
    FLURKARTE = "Flurkarte"
    TEILUNGSERKLAERUNG = "Teilungserkl√§rung"
    BAULASTENVERZEICHNIS = "Baulastenverzeichnis"
    VOLLMACHT = "Vollmacht"
    PERSONALAUSWEIS = "Personalausweis/Pass"
    FINANZIERUNGSBESTAETIGUNG = "Finanzierungsbest√§tigung"
    GRUNDSCHULDBESTELLUNG = "Grundschuldbestellung"
    LOESCHUNGSBEWILLIGUNG = "L√∂schungsbewilligung"
    VORKAUFSRECHTSVERZICHT = "Vorkaufsrechtsverzicht"
    UNBEDENKLICHKEITSBESCHEINIGUNG = "Unbedenklichkeitsbescheinigung"
    ERBSCHEIN = "Erbschein"
    HANDELSREGISTERAUSZUG = "Handelsregisterauszug"
    GESELLSCHAFTERBESCHLUSS = "Gesellschafterbeschluss"
    KORRESPONDENZ = "Korrespondenz"
    NOTIZEN = "Notizen/Vermerke"
    SONSTIGES = "Sonstiges"

class AktenStatus(Enum):
    """Status einer Akte"""
    IMPORTIERT = "Importiert"
    NEU = "Neu angelegt"
    IN_BEARBEITUNG = "In Bearbeitung"
    WARTET_AUF_UNTERLAGEN = "Wartet auf Unterlagen"
    VOLLSTAENDIG = "Vollst√§ndig"
    BEURKUNDUNG_VORBEREITET = "Beurkundung vorbereitet"
    BEURKUNDET = "Beurkundet"
    VOLLZUG = "Im Vollzug"
    ABGESCHLOSSEN = "Abgeschlossen"
    ARCHIVIERT = "Archiviert"
    STORNIERT = "Storniert"

@dataclass
class AktenDokument:
    """Ein Dokument innerhalb einer importierten Akte"""
    dokument_id: str
    akte_id: str
    ordner_name: str  # Zugeh√∂riger Ordner in der Akte
    titel: str  # Dokumenttitel (Pflichtfeld)

    # Optionale Felder
    ordner_id: str = ""  # ID des zugeh√∂rigen Ordners
    dokument_typ: str = AktenDokumentTyp.SONSTIGES.value
    dateiname: str = ""
    dateigr√∂√üe: int = 0
    pdf_data: Optional[bytes] = None

    # Aus der Original-PDF extrahiert
    seiten_von: int = 0  # Startseite im Original-PDF
    seiten_bis: int = 0  # Endseite im Original-PDF

    # Metadaten
    beschreibung: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)
    geaendert_am: datetime = field(default_factory=datetime.now)

    # Status
    geprueft: bool = False
    geprueft_von: str = ""
    geprueft_am: Optional[datetime] = None
    notizen: str = ""

@dataclass
class AktenOrdner:
    """Ein Ordner/Kategorie innerhalb einer Akte"""
    ordner_id: str
    akte_id: str
    name: str
    beschreibung: str = ""
    reihenfolge: int = 0  # F√ºr Sortierung
    dokument_ids: List[str] = field(default_factory=list)

    # Standard-Ordner f√ºr Notarakten
    ist_standard_ordner: bool = False

# ============================================================================
# GESELLSCHAFTEN & PARTEIEN-VERWALTUNG
# ============================================================================

class Rechtsform(Enum):
    """Rechtsformen f√ºr Gesellschaften"""
    NATUERLICHE_PERSON = "Nat√ºrliche Person"
    GMBH = "GmbH"
    UG = "UG (haftungsbeschr√§nkt)"
    AG = "AG"
    KG = "KG"
    OHG = "OHG"
    GMBH_CO_KG = "GmbH & Co. KG"
    EINZELUNTERNEHMEN = "Einzelunternehmen"
    GBR = "GbR"
    VEREIN = "Verein e.V."
    STIFTUNG = "Stiftung"
    ERBENGEMEINSCHAFT = "Erbengemeinschaft"
    WEG = "WEG"
    SONSTIGE = "Sonstige"

class OrganTyp(Enum):
    """Arten von Organen/Vertretungsberechtigten"""
    GESCHAEFTSFUEHRER = "Gesch√§ftsf√ºhrer"
    VORSTAND = "Vorstand"
    PROKURIST = "Prokurist"
    KOMPLEMENTAER = "Komplement√§r"
    GESELLSCHAFTER = "Gesellschafter"
    BEVOLLMAECHTIGTER = "Bevollm√§chtigter"
    VERWALTER = "Verwalter"
    TESTAMENTSVOLLSTRECKER = "Testamentsvollstrecker"
    BETREUER = "Betreuer"
    SONSTIGER = "Sonstiger Vertreter"

@dataclass
class Organ:
    """Ein Organ/Vertretungsberechtigter einer Gesellschaft"""
    organ_id: str
    gesellschaft_id: str

    # Pers√∂nliche Daten
    name: str
    vorname: str = ""
    geburtsdatum: str = ""
    geburtsort: str = ""

    # Adresse
    strasse: str = ""
    hausnummer: str = ""
    plz: str = ""
    ort: str = ""
    land: str = "Deutschland"

    # Funktion
    organ_typ: str = OrganTyp.GESCHAEFTSFUEHRER.value
    einzelvertretungsberechtigt: bool = False
    vertretungsbeschraenkung: str = ""  # z.B. "Nur mit einem weiteren GF"

    # Legitimation
    ausweis_typ: str = ""  # Personalausweis, Reisepass
    ausweis_nummer: str = ""
    ausweis_gueltig_bis: str = ""
    ausweis_daten: Optional[bytes] = None  # Kopie des Ausweises

    # Metadaten
    erfasst_am: datetime = field(default_factory=datetime.now)
    geprueft: bool = False

@dataclass
class HandelsregisterEintrag:
    """Handelsregister-Informationen einer Gesellschaft"""
    hr_id: str
    gesellschaft_id: str

    # Registerdaten
    registergericht: str = ""
    registerart: str = "HRB"  # HRA, HRB, GnR, PR, VR
    registernummer: str = ""

    # Abfragedaten
    abfrage_datum: Optional[datetime] = None
    abfrage_pdf: Optional[bytes] = None

    # Extrahierte Daten
    firma: str = ""
    sitz: str = ""
    geschaeftsanschrift: str = ""
    gegenstand: str = ""
    stammkapital: float = 0.0
    waehrung: str = "EUR"
    gruendungsdatum: str = ""

    # Status
    ist_aktuell: bool = True
    letzte_eintragung: str = ""

@dataclass
class Gesellschaft:
    """Eine juristische Person/Gesellschaft als Vertragspartei"""
    gesellschaft_id: str
    firma: str  # Vollst√§ndiger Firmenname (required)

    # Optional fields
    projekt_id: str = ""  # Verkn√ºpfung zum Projekt

    # Firmendaten
    firma_kurz: str = ""  # Kurzbezeichnung
    rechtsform: str = Rechtsform.GMBH.value

    # Sitz und Anschrift
    sitz: str = ""  # Rechtlicher Sitz
    strasse: str = ""
    hausnummer: str = ""
    plz: str = ""
    ort: str = ""
    land: str = "Deutschland"

    # Registerdaten
    registergericht: str = ""
    registernummer: str = ""  # z.B. "HRB 12345"
    steuernummer: str = ""
    ust_id: str = ""  # USt-IdNr.

    # Vertretung
    organe: List[str] = field(default_factory=list)  # Liste von Organ-IDs
    vertretungsregelung: str = ""  # z.B. "Zwei GF gemeinsam"

    # Handelsregister
    hr_eintrag_id: str = ""  # Verweis auf HandelsregisterEintrag
    hr_abfrage_erforderlich: bool = True
    hr_abfrage_erfolgt: bool = False

    # Metadaten
    erfasst_am: datetime = field(default_factory=datetime.now)
    erfasst_von: str = ""
    notizen: str = ""

@dataclass
class Partei:
    """Eine Vertragspartei - kann nat√ºrliche Person oder Gesellschaft sein"""
    partei_id: str
    projekt_id: str

    # Art der Partei
    ist_gesellschaft: bool = False

    # Referenz zur Person oder Gesellschaft
    user_id: str = ""  # Falls nat√ºrliche Person (User-ID)
    gesellschaft_id: str = ""  # Falls Gesellschaft

    # Rolle im Vertrag
    rolle: str = ""  # "Verk√§ufer", "K√§ufer", "√úberlasser", "Empf√§nger"

    # Bei nat√ºrlichen Personen: erweiterte Daten
    familienstand: str = ""  # ledig, verheiratet, geschieden, verwitwet
    gueterstand: str = ""  # Zugewinngemeinschaft, G√ºtertrennung, etc.
    ehepartner_user_id: str = ""  # Falls verheiratet und Ehepartner beteiligt

    # Sortierung/Anzeige
    reihenfolge: int = 0

    # Metadaten
    hinzugefuegt_am: datetime = field(default_factory=datetime.now)

@dataclass
class NotarAktenzeichen:
    """Verwaltung der fortlaufenden Aktenzeichen pro Notar"""
    notar_id: str
    jahr: int
    letzte_nummer: int = 0  # Letzte vergebene Nummer in diesem Jahr

# ===== KOMMUNIKATIONS-ERWEITERUNGEN =====

class NachrichtenPrioritaet(Enum):
    """Priorit√§t einer Nachricht"""
    NORMAL = "Normal"
    HOCH = "Hoch"
    DRINGEND = "Dringend"

class NachrichtenKategorie(Enum):
    """Kategorie einer Nachricht"""
    ANFRAGE = "Anfrage"
    INFORMATION = "Information"
    DOKUMENT = "Dokument"
    TERMIN = "Termin"
    FREIGABE = "Freigabe"
    ERINNERUNG = "Erinnerung"

class Sicherheitsstufe(Enum):
    """Sicherheitsstufe f√ºr Dokumente und Nachrichten"""
    OEFFENTLICH = "√ñffentlich"
    INTERN = "Intern"
    VERTRAULICH = "Vertraulich"
    STRENG_VERTRAULICH = "Streng vertraulich"

class MaklerBerechtigungTyp(Enum):
    """Berechtigungen f√ºr Makler-Mitarbeiter"""
    PROJEKTE_ANSEHEN = "Projekte ansehen"
    PROJEKTE_ERSTELLEN = "Projekte erstellen"
    PROJEKTE_BEARBEITEN = "Projekte bearbeiten"
    PROJEKTE_LOESCHEN = "Projekte l√∂schen"
    NACHRICHTEN_SENDEN = "Nachrichten senden"
    NACHRICHTEN_LESEN = "Alle Nachrichten lesen"
    IM_NAMEN_KOMMUNIZIEREN = "Im Namen des Maklers kommunizieren"
    DOKUMENTE_HOCHLADEN = "Dokumente hochladen"
    DOKUMENTE_LOESCHEN = "Dokumente l√∂schen"
    EXPOSE_ERSTELLEN = "Expos√©s erstellen"
    TEILNEHMER_EINLADEN = "Teilnehmer einladen"
    TEILNEHMER_VERWALTEN = "Teilnehmer verwalten"
    TERMINE_ERSTELLEN = "Termine erstellen"
    TERMINE_BESTAETIGEN = "Termine best√§tigen"
    PREISE_SEHEN = "Preise sehen"
    PREISE_VERHANDELN = "Preisverhandlungen f√ºhren"
    MITARBEITER_VERWALTEN = "Mitarbeiter verwalten"
    EINSTELLUNGEN_AENDERN = "Einstellungen √§ndern"

class MaklerMitarbeiterRolle(Enum):
    """Rollen f√ºr Makler-Mitarbeiter"""
    MITARBEITER = "Mitarbeiter"
    TEAMLEITER = "Teamleiter"
    PARTNER = "Partner"

# ============================================================================
# BENACHRICHTIGUNGS-CENTER DATENSTRUKTUREN
# ============================================================================

class EingangTyp(Enum):
    """Typen von Eing√§ngen im Benachrichtigungs-Center"""
    NACHRICHT = "Nachricht"
    DOKUMENT = "Dokument"
    TERMIN = "Termin"
    FREIGABE = "Freigabe"
    FRIST = "Frist"
    ANFORDERUNG = "Anforderung"
    SYSTEM = "System"

class EingangStatus(Enum):
    """Status von Eing√§ngen"""
    NEU = "Neu"
    GELESEN = "Gelesen"
    BEARBEITET = "Bearbeitet"
    ERLEDIGT = "Erledigt"
    ARCHIVIERT = "Archiviert"

class FristTyp(Enum):
    """Typen von Fristen"""
    WIDERRUFSFRIST = "Widerrufsfrist"
    ZAHLUNGSFRIST = "Zahlungsfrist"
    GRUNDBUCHEINTRAGUNG = "Grundbucheintragung"
    DOKUMENTENEINREICHUNG = "Dokumenteneinreichung"
    BEURKUNDUNGSTERMIN = "Beurkundungstermin"
    FINANZIERUNGSZUSAGE = "Finanzierungszusage"
    KAUFPREISZAHLUNG = "Kaufpreiszahlung"
    UEBERGABE = "√úbergabe"
    CUSTOM = "Benutzerdefiniert"

class GatingStatus(Enum):
    """Status f√ºr Finanzierungs- und Legal-Gating"""
    OFFEN = "Offen"
    IN_PRUEFUNG = "In Pr√ºfung"
    FREIGEGEBEN = "Freigegeben"
    ABGELEHNT = "Abgelehnt"
    WARTET = "Wartet auf Vorg√§nger"

class DokumentVersion(Enum):
    """Status einer Dokumentenversion"""
    ENTWURF = "Entwurf"
    ZUR_PRUEFUNG = "Zur Pr√ºfung"
    FREIGEGEBEN = "Freigegeben"
    SIGNIERT = "Signiert"
    ARCHIVIERT = "Archiviert"

@dataclass
class Eingang:
    """Ein Eingang im Benachrichtigungs-Center"""
    eingang_id: str
    empfaenger_id: str
    typ: str  # EingangTyp
    titel: str

    # Optionale Felder mit Defaults
    beschreibung: str = ""
    absender_id: str = ""
    projekt_id: str = ""
    akte_id: str = ""
    referenz_id: str = ""  # ID des verlinkten Objekts
    referenz_typ: str = ""  # Typ des verlinkten Objekts
    status: str = EingangStatus.NEU.value
    prioritaet: str = NachrichtenPrioritaet.NORMAL.value
    erstellt_am: datetime = field(default_factory=datetime.now)
    gelesen_am: datetime = None
    bearbeitet_am: datetime = None
    faellig_am: datetime = None
    antwort_vorlage_id: str = ""
    metadata: Dict = field(default_factory=dict)

@dataclass
class AntwortVorlage:
    """Vorlage f√ºr Schnellantworten"""
    vorlage_id: str
    name: str
    kategorie: str  # z.B. "Best√§tigung", "Ablehnung", "Nachfrage"

    betreff_template: str = ""
    text_template: str = ""
    platzhalter: List[str] = field(default_factory=list)
    fuer_typen: List[str] = field(default_factory=list)  # EingangTyp
    ist_system: bool = False
    erstellt_von: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)

@dataclass
class Frist:
    """Eine Frist im System"""
    frist_id: str
    projekt_id: str
    typ: str  # FristTyp
    bezeichnung: str

    faellig_am: datetime = None
    erinnerung_tage: int = 3  # Tage vor F√§lligkeit erinnern
    verantwortlich_id: str = ""
    status: str = "offen"  # offen, erledigt, ueberfaellig
    notizen: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)
    erledigt_am: datetime = None
    automatisch_berechnet: bool = False
    basis_datum: datetime = None  # Datum von dem aus berechnet wird
    tage_offset: int = 0  # Tage nach Basisdatum

@dataclass
class GatingPruefung:
    """Pr√ºfung im Gating-Prozess"""
    pruefung_id: str
    projekt_id: str
    user_id: str  # Wer muss pr√ºfen/best√§tigen
    typ: str  # "legal", "finanzierung", "dokument"
    bezeichnung: str

    status: str = GatingStatus.OFFEN.value
    reihenfolge: int = 0  # F√ºr sequenzielle Pr√ºfungen
    vorgaenger_ids: List[str] = field(default_factory=list)
    erforderlich: bool = True
    geprueft_von: str = ""
    geprueft_am: datetime = None
    kommentar: str = ""
    dokument_ids: List[str] = field(default_factory=list)
    erstellt_am: datetime = field(default_factory=datetime.now)

# ============================================================================
# VERTRAGSVERSIONEN & VERGLEICH
# ============================================================================

class AenderungsTyp(Enum):
    """Typen von Text√§nderungen"""
    HINZUGEFUEGT = "Hinzugef√ºgt"
    GELOESCHT = "Gel√∂scht"
    GEAENDERT = "Ge√§ndert"
    UNVERAENDERT = "Unver√§ndert"

@dataclass
class TextAenderung:
    """Einzelne Text√§nderung mit Metadaten"""
    aenderung_id: str
    version_id: str
    typ: str  # AenderungsTyp
    position_start: int = 0
    position_ende: int = 0
    alter_text: str = ""
    neuer_text: str = ""
    geaendert_von: str = ""
    geaendert_am: datetime = field(default_factory=datetime.now)
    grund: str = ""  # Begr√ºndung f√ºr die √Ñnderung
    referenz_dokument_id: str = ""  # Verweis auf Anfrage-Dokument
    referenz_dokument_typ: str = ""  # z.B. "K√§uferanfrage", "Verk√§uferanfrage"
    referenz_sichtbar: bool = False  # Notar-Freigabe f√ºr Referenzanzeige

@dataclass
class VertragsVersion:
    """Version eines Vertragstextes f√ºr Vergleich"""
    version_id: str
    vertrag_id: str  # Projekt-ID oder Vertrag-ID
    version_nummer: int

    titel: str = ""
    text_inhalt: str = ""  # Der vollst√§ndige Vertragstext
    status: str = DokumentVersion.ENTWURF.value
    erstellt_von: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)
    aenderungen: List[str] = field(default_factory=list)  # Liste von TextAenderung-IDs
    aenderungsbeschreibung: str = ""
    freigegeben_von: str = ""
    freigegeben_am: datetime = None
    referenz_freigabe_durch_notar: bool = False  # Notar erlaubt Anzeige von Referenz-Dokumenten
    basiert_auf_version: str = ""  # Vorg√§nger-Version-ID

@dataclass
class DokumentVersionierung:
    """Versionierte Dokumentenverwaltung"""
    version_id: str
    dokument_id: str
    version_nummer: int

    dateiname: str = ""
    datei_data: bytes = None
    dateityp: str = ""
    dateigroesse: int = 0
    status: str = DokumentVersion.ENTWURF.value
    aenderungen: str = ""  # Beschreibung der √Ñnderungen
    erstellt_von: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)
    freigegeben_von: str = ""
    freigegeben_am: datetime = None
    signatur_data: bytes = None
    signiert_von: str = ""
    signiert_am: datetime = None
    wasserzeichen: bool = True  # Bei Entw√ºrfen

# ============================================================================
# REPORTING & KPI DATENSTRUKTUREN
# ============================================================================

@dataclass
class KPISnapshot:
    """Snapshot von KPIs f√ºr Reporting"""
    snapshot_id: str
    user_id: str
    datum: datetime

    # Projekt-KPIs
    projekte_gesamt: int = 0
    projekte_aktiv: int = 0
    projekte_abgeschlossen: int = 0
    durchschnittliche_dauer_tage: float = 0.0

    # Umsatz-KPIs (f√ºr Makler)
    umsatz_monat: float = 0.0
    umsatz_quartal: float = 0.0
    umsatz_jahr: float = 0.0
    provision_offen: float = 0.0

    # Aktivit√§ts-KPIs
    dokumente_hochgeladen: int = 0
    nachrichten_gesendet: int = 0
    termine_durchgefuehrt: int = 0

    # Qualit√§ts-KPIs
    durchschnittliche_reaktionszeit_std: float = 0.0
    kundenzufriedenheit: float = 0.0

    metadata: Dict = field(default_factory=dict)

@dataclass
class BerichtKonfiguration:
    """Konfiguration f√ºr automatische Berichte"""
    bericht_id: str
    user_id: str
    name: str

    typ: str = "standard"  # standard, custom
    intervall: str = "monatlich"  # taeglich, woechentlich, monatlich
    empfaenger_emails: List[str] = field(default_factory=list)
    format: str = "pdf"  # pdf, excel, html
    sektionen: List[str] = field(default_factory=list)
    filter_kriterien: Dict = field(default_factory=dict)
    aktiv: bool = True
    letzter_versand: datetime = None
    naechster_versand: datetime = None


@dataclass
class Briefkopf:
    """Briefkopf f√ºr Dokumente und Korrespondenz"""
    briefkopf_id: str
    inhaber_id: str  # User oder Firma-ID
    inhaber_typ: str  # "user", "firma", "kanzlei", "maklerb√ºro"

    # Logo
    logo_data: bytes = None
    logo_position: str = "links"  # links, rechts, zentriert
    logo_groesse: int = 100  # Pixel H√∂he

    # Kopfdaten
    firmenname: str = ""
    zusatz: str = ""  # z.B. "Notariat", "Immobilienmakler"
    inhaber_name: str = ""

    # Adresse
    strasse: str = ""
    hausnummer: str = ""
    plz: str = ""
    ort: str = ""
    land: str = "Deutschland"

    # Kontakt
    telefon: str = ""
    fax: str = ""
    email: str = ""
    website: str = ""

    # Rechtliches
    steuernummer: str = ""
    ust_id: str = ""
    handelsregister: str = ""

    # Bankverbindung
    bank_name: str = ""
    iban: str = ""
    bic: str = ""

    # Design
    schriftart: str = "Arial"
    primaerfarbe: str = "#000000"
    sekundaerfarbe: str = "#666666"

    # Fu√üzeile
    fusszeile_text: str = ""
    fusszeile_zeile2: str = ""

    ist_aktiv: bool = True
    erstellt_am: datetime = field(default_factory=datetime.now)
    aktualisiert_am: datetime = field(default_factory=datetime.now)

@dataclass
class EmailSignatur:
    """E-Mail-Signatur f√ºr Benutzer"""
    signatur_id: str
    user_id: str
    name: str  # z.B. "Standard", "Formal", "Kurz"

    # Inhalt
    text_signatur: str = ""  # Plaintext-Version
    html_signatur: str = ""  # HTML-Version mit Formatierung

    # Optionen
    bild_einbetten: bool = True
    visitenkarte_anhaengen: bool = False

    # Verwendung
    ist_standard: bool = False
    fuer_neue_nachrichten: bool = True
    fuer_antworten: bool = True

    erstellt_am: datetime = field(default_factory=datetime.now)
    aktualisiert_am: datetime = field(default_factory=datetime.now)

@dataclass
class MaklerMitarbeiter:
    """Mitarbeiter eines Maklerb√ºros"""
    mitarbeiter_id: str
    makler_id: str  # B√ºro-Inhaber (User-ID)

    # Pers√∂nliche Daten
    name: str
    vorname: str = ""
    email: str = ""
    telefon: str = ""
    password_hash: str = ""

    # Rolle und Berechtigungen
    rolle: str = MaklerMitarbeiterRolle.MITARBEITER.value
    berechtigungen: List[str] = field(default_factory=list)

    # Projektzuordnung
    projekt_ids: List[str] = field(default_factory=list)
    kann_alle_projekte_sehen: bool = False

    # Status
    ist_aktiv: bool = True
    eingestellt_am: datetime = field(default_factory=datetime.now)

    # Kommunikation
    kann_im_namen_kommunizieren: bool = False
    eigene_signatur: bool = True
    signatur_id: str = ""

    # K√ºrzel f√ºr Aktenzeichen
    kuerzel: str = ""

@dataclass
class KommunikationsAnlage:
    """Anlage einer Nachricht"""
    anlage_id: str
    nachricht_id: str
    projekt_id: str = ""

    # Datei-Informationen
    dateiname: str = ""
    dateityp: str = ""  # PDF, DOCX, JPG, etc.
    dateigroesse: int = 0
    datei_data: bytes = None

    # Metadaten
    hochgeladen_von: str = ""
    hochgeladen_am: datetime = field(default_factory=datetime.now)
    beschreibung: str = ""

    # Sicherheit
    sicherheitsstufe: str = Sicherheitsstufe.INTERN.value
    ist_vertraulich: bool = False

    # Ordner-Zuordnung
    ordner_pfad: str = ""  # z.B. "/Kaufvertrag/Entw√ºrfe"
    akte_id: str = ""  # Verkn√ºpfung zur Akte

@dataclass
class KommunikationsNachricht:
    """Eine Nachricht im Kommunikationssystem"""
    nachricht_id: str
    projekt_id: str = ""
    akte_id: str = ""

    # Absender/Empf√§nger
    absender_id: str = ""
    absender_typ: str = "user"  # "user", "mitarbeiter"
    empfaenger_ids: List[str] = field(default_factory=list)
    cc_ids: List[str] = field(default_factory=list)

    # Inhalt
    betreff: str = ""
    inhalt: str = ""  # Kann HTML/Markdown enthalten
    inhalt_plaintext: str = ""

    # Klassifizierung
    prioritaet: str = NachrichtenPrioritaet.NORMAL.value
    kategorie: str = NachrichtenKategorie.INFORMATION.value
    sicherheitsstufe: str = Sicherheitsstufe.INTERN.value

    # Anlagen
    anlage_ids: List[str] = field(default_factory=list)

    # Status
    gelesen_von: List[str] = field(default_factory=list)
    ist_entwurf: bool = False
    ist_archiviert: bool = False
    ist_geloescht: bool = False

    # Verkn√ºpfungen
    antwort_auf_id: str = ""  # Falls Antwort auf eine Nachricht
    aktenzeichen: str = ""

    # Zeitstempel
    erstellt_am: datetime = field(default_factory=datetime.now)
    gesendet_am: datetime = None
    aktualisiert_am: datetime = field(default_factory=datetime.now)

@dataclass
class AktenOrdner:
    """Ordner innerhalb einer Akte"""
    ordner_id: str
    akte_id: str
    name: str
    pfad: str  # z.B. "/01_Stammdaten" oder "/05_Korrespondenz/Eingehend"

    # Hierarchie
    parent_ordner_id: str = ""
    reihenfolge: int = 0

    # Metadaten
    beschreibung: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)
    erstellt_von: str = ""

    # Automatische Zuordnung
    auto_zuordnung_typen: List[str] = field(default_factory=list)  # Dokumenttypen die automatisch hier landen

@dataclass
class GespeicherteSuche:
    """Gespeicherte Suchanfrage"""
    suche_id: str
    user_id: str
    name: str  # z.B. "Offene Kaufvertr√§ge 2025"

    # Suchkriterien
    suchbegriff: str = ""
    filter_kriterien: Dict = field(default_factory=dict)
    sortierung: str = "datum_desc"

    # Einstellungen
    ist_standard: bool = False
    in_schnellzugriff: bool = False

    erstellt_am: datetime = field(default_factory=datetime.now)
    zuletzt_verwendet: datetime = field(default_factory=datetime.now)

@dataclass
class AuditLogEintrag:
    """Eintrag im Aktivit√§tsprotokoll"""
    log_id: str
    timestamp: datetime

    # Wer
    user_id: str
    user_name: str = ""
    user_rolle: str = ""

    # Was
    aktion: str = ""  # "angesehen", "bearbeitet", "heruntergeladen", "gesendet"
    objekt_typ: str = ""  # "dokument", "nachricht", "akte", "projekt"
    objekt_id: str = ""
    objekt_name: str = ""

    # Kontext
    projekt_id: str = ""
    akte_id: str = ""

    # Details
    details: str = ""
    ip_adresse: str = ""

# Standard-Ordnerstruktur f√ºr Akten
AKTEN_ORDNER_TEMPLATES = {
    "Kaufvertrag": [
        ("01_Stammdaten", "Personalausweise, HR-Ausz√ºge, Vollmachten"),
        ("01_Stammdaten/Personalausweise", ""),
        ("01_Stammdaten/Handelsregisterauszuege", ""),
        ("01_Stammdaten/Vollmachten", ""),
        ("02_Kaufgegenstand", "Grundbuch, Flurkarte, Baulastenverzeichnis"),
        ("02_Kaufgegenstand/Grundbuch", ""),
        ("02_Kaufgegenstand/Flurkarten", ""),
        ("02_Kaufgegenstand/Baulasten", ""),
        ("03_Finanzierung", "Finanzierungsbest√§tigung, Grundschuld"),
        ("04_Vertragsentwuerfe", "Alle Versionen des Kaufvertrags"),
        ("05_Korrespondenz", "Ein- und ausgehende Kommunikation"),
        ("05_Korrespondenz/Eingehend", ""),
        ("05_Korrespondenz/Ausgehend", ""),
        ("06_Beurkundung", "Protokoll, unterschriebene Dokumente"),
        ("07_Vollzug", "Grundbuchanmeldung, Finanzamtsmeldung"),
        ("08_Abrechnung", "Kostenrechnung, Zahlungen"),
    ],
    "Testament": [
        ("01_Stammdaten", "Personalausweise, Familiendaten"),
        ("02_Verfuegungen", "Testamentarische Verf√ºgungen"),
        ("03_Entwuerfe", "Entw√ºrfe"),
        ("04_Korrespondenz", "Ein- und ausgehende Kommunikation"),
        ("04_Korrespondenz/Eingehend", ""),
        ("04_Korrespondenz/Ausgehend", ""),
        ("05_Beurkundung", "Beurkundungsdokumente"),
        ("06_Verwahrung", "Verwahrungsdokumentation"),
    ],
    "Gesellschaftsgruendung": [
        ("01_Stammdaten", "Personalausweise, Gesellschafterdaten"),
        ("02_Gesellschaftsvertrag", "Satzung, Gesellschaftsvertrag"),
        ("03_Handelsregister", "HR-Anmeldung, Eintragung"),
        ("04_Korrespondenz", "Ein- und ausgehende Kommunikation"),
        ("04_Korrespondenz/Eingehend", ""),
        ("04_Korrespondenz/Ausgehend", ""),
        ("05_Beurkundung", "Beurkundungsdokumente"),
    ],
    "Erbvertrag": [
        ("01_Stammdaten", "Personalausweise, Familiendaten"),
        ("02_Vermoegens√ºbersicht", "Verm√∂gensaufstellung"),
        ("03_Entwuerfe", "Vertragsentw√ºrfe"),
        ("04_Korrespondenz", "Ein- und ausgehende Kommunikation"),
        ("04_Korrespondenz/Eingehend", ""),
        ("04_Korrespondenz/Ausgehend", ""),
        ("05_Beurkundung", "Beurkundungsdokumente"),
    ],
}

# Automatische Dokumenten-Zuordnung
DOKUMENT_AUTO_ZUORDNUNG = {
    "Personalausweis": "01_Stammdaten/Personalausweise",
    "Reisepass": "01_Stammdaten/Personalausweise",
    "Handelsregisterauszug": "01_Stammdaten/Handelsregisterauszuege",
    "Vollmacht": "01_Stammdaten/Vollmachten",
    "Grundbuchauszug": "02_Kaufgegenstand/Grundbuch",
    "Flurkarte": "02_Kaufgegenstand/Flurkarten",
    "Baulastenverzeichnis": "02_Kaufgegenstand/Baulasten",
    "Finanzierungsbest√§tigung": "03_Finanzierung",
    "Grundschuldbestellung": "03_Finanzierung",
    "Kaufvertrag": "04_Vertragsentwuerfe",
    "Vertragsentwurf": "04_Vertragsentwuerfe",
    "Kostenrechnung": "08_Abrechnung",
}

@dataclass
class ImportierteAkte:
    """Eine aus PDF importierte Notarakte"""
    akte_id: str
    notar_id: str  # Welcher Notar hat importiert

    # Aktenbezeichnung
    aktenzeichen: str  # z.B. "UR 123/2024"
    bezeichnung: str  # z.B. "Kaufvertrag M√ºller/Schmidt"

    # Original-PDF
    original_pdf_name: str = ""
    original_pdf_gr√∂√üe: int = 0
    original_pdf_data: Optional[bytes] = None
    original_seitenanzahl: int = 0

    # Struktur
    ordner: Dict[str, AktenOrdner] = field(default_factory=dict)
    dokumente: Dict[str, AktenDokument] = field(default_factory=dict)

    # Verkn√ºpfung mit Projekt (optional)
    projekt_id: str = ""  # Falls mit bestehendem Projekt verkn√ºpft
    als_projekt_erstellt: bool = False

    # Beteiligte (aus Akte extrahiert)
    kaeufer_namen: List[str] = field(default_factory=list)
    verkaeufer_namen: List[str] = field(default_factory=list)
    objekt_adresse: str = ""
    kaufpreis: float = 0.0

    # Status und Timestamps
    status: str = AktenStatus.IMPORTIERT.value
    importiert_am: datetime = field(default_factory=datetime.now)
    zuletzt_bearbeitet: datetime = field(default_factory=datetime.now)

    # Import-Analyse
    erkannte_struktur: Dict[str, Any] = field(default_factory=dict)  # Erkannte Inhaltsverzeichnis-Struktur
    import_protokoll: List[str] = field(default_factory=list)  # Log des Imports

# Standard-Ordnerstruktur f√ºr Notarakten
STANDARD_AKTEN_ORDNER = [
    {"name": "Vertragsentw√ºrfe", "beschreibung": "Kaufvertragsentw√ºrfe und √Ñnderungen"},
    {"name": "Grundbuch", "beschreibung": "Grundbuchausz√ºge und -unterlagen"},
    {"name": "Flurkarten & Pl√§ne", "beschreibung": "Flurkarten, Lagepl√§ne, Teilungspl√§ne"},
    {"name": "Finanzierung", "beschreibung": "Finanzierungsbest√§tigungen, Grundschulden"},
    {"name": "Personalien K√§ufer", "beschreibung": "Ausweise, Vollmachten K√§ufer"},
    {"name": "Personalien Verk√§ufer", "beschreibung": "Ausweise, Vollmachten Verk√§ufer"},
    {"name": "Beh√∂rdliche Unterlagen", "beschreibung": "Vorkaufsrecht, Unbedenklichkeit, etc."},
    {"name": "Korrespondenz", "beschreibung": "Schriftverkehr und E-Mails"},
    {"name": "Abrechnung", "beschreibung": "Kostenrechnungen und Zahlungsnachweise"},
    {"name": "Sonstiges", "beschreibung": "Weitere Unterlagen"},
]

# ============================================================================
# AKTENTASCHE - MOBILER DOKUMENTENORDNER
# ============================================================================

class AktentascheInhaltTyp(Enum):
    """Typen von Inhalten in der Aktentasche"""
    DOKUMENT = "Dokument"
    ANGEBOT = "Angebot"
    FINANZIERUNGSANGEBOT = "Finanzierungsangebot"
    EXPOSE = "Expos√©"
    VERTRAG = "Vertrag"
    NACHRICHT = "Nachricht"
    SONSTIGES = "Sonstiges"

@dataclass
class AktentascheInhalt:
    """Ein Element in der Aktentasche"""
    inhalt_id: str
    inhalt_typ: str  # AktentascheInhaltTyp
    titel: str
    beschreibung: str = ""

    # Referenz zum Original-Objekt
    referenz_id: str = ""  # ID des Originaldokuments/Angebots
    referenz_typ: str = ""  # z.B. "Verk√§uferDokument", "Preisangebot", "FinancingOffer"

    # Datei-Daten (falls Dokument)
    dateiname: str = ""
    dateigr√∂√üe: int = 0
    pdf_data: Optional[bytes] = None

    # Projekt-Bezug
    projekt_id: str = ""
    projekt_name: str = ""

    hinzugefuegt_am: datetime = field(default_factory=datetime.now)
    notizen: str = ""

@dataclass
class AktentascheFreigabe:
    """Protokolliert eine Freigabe/Versand aus der Aktentasche"""
    freigabe_id: str
    aktentasche_user_id: str
    inhalt_ids: List[str]  # Liste der freigegebenen Inhalte

    # Empf√§nger
    empfaenger_typ: str  # "projektbeteiligter", "email", "download"
    empfaenger_user_ids: List[str] = field(default_factory=list)  # Bei Projektbeteiligten
    empfaenger_email: str = ""  # Bei Email-Versand
    empfaenger_name: str = ""  # Name des externen Empf√§ngers

    betreff: str = ""
    nachricht: str = ""

    freigabe_datum: datetime = field(default_factory=datetime.now)
    abgelaufen_am: Optional[datetime] = None  # Optional: Ablaufdatum f√ºr Zugriff
    download_link: str = ""  # Generierter Download-Link

@dataclass
class Aktentasche:
    """Die pers√∂nliche Aktentasche eines Benutzers"""
    user_id: str
    inhalte: Dict[str, AktentascheInhalt] = field(default_factory=dict)
    freigaben: List[AktentascheFreigabe] = field(default_factory=list)

    # Einstellungen
    sortierung: str = "datum_absteigend"  # datum_absteigend, datum_aufsteigend, name, typ
    filter_typ: str = "alle"  # alle, dokumente, angebote, etc.

    erstellt_am: datetime = field(default_factory=datetime.now)
    zuletzt_geaendert: datetime = field(default_factory=datetime.now)


# VERTRAGSARCHIV & TEXTBAUSTEINE
# ============================================================================

class VertragsTyp(Enum):
    """Vertragstypen f√ºr Kategorisierung von Textbausteinen"""
    KAUFVERTRAG = "Kaufvertrag"
    UEBERLASSUNGSVERTRAG = "√úberlassungsvertrag"
    ERBVERTRAG = "Erbvertrag"
    SCHENKUNGSVERTRAG = "Schenkungsvertrag"
    MIETVERTRAG = "Mietvertrag"
    GRUNDSTUECKSKAUFVERTRAG = "Grundst√ºckskaufvertrag"
    WOHNUNGSKAUFVERTRAG = "Wohnungskaufvertrag"
    BAUTRAEGERVERTRAG = "Bautr√§gervertrag"
    TEILUNGSERKLAERUNG = "Teilungserkl√§rung"
    VOLLMACHT = "Vollmacht"
    SONSTIGES = "Sonstiges"

class TextbausteinKategorie(Enum):
    """Kategorien f√ºr Textbausteine (Regelungsinhalte)"""
    VERTRAGSPARTEIEN = "Vertragsparteien"
    KAUFGEGENSTAND = "Kaufgegenstand"
    KAUFPREIS = "Kaufpreis & Zahlung"
    ZAHLUNGSMODALITAETEN = "Zahlungsmodalit√§ten"
    F√ÑLLIGKEIT = "F√§lligkeit"
    AUFLASSUNG = "Auflassung & Eigentums√ºbergang"
    BESITZUEBERGANG = "Besitz√ºbergang"
    HAFTUNG = "Haftung & Gew√§hrleistung"
    MAENGEL = "M√§ngelhaftung"
    RUECKTRITT = "R√ºcktritt & Aufhebung"
    VERTRAGSSTRAFE = "Vertragsstrafe"
    KOSTEN = "Kosten & Steuern"
    BELASTUNGEN = "Belastungen & Lasten"
    GRUNDBUCH = "Grundbuch"
    ERSCHLIESSUNG = "Erschlie√üung"
    BAULAST = "Baulasten"
    VORKAUFSRECHT = "Vorkaufsrecht"
    VOLLMACHTEN = "Vollmachten"
    SCHLUSSBESTIMMUNGEN = "Schlussbestimmungen"
    SALVATORISCH = "Salvatorische Klausel"
    SONSTIGES = "Sonstiges"

class TextbausteinStatus(Enum):
    """Status eines Textbausteins"""
    ENTWURF = "Entwurf"  # Neu hochgeladen, nicht gepr√ºft
    PRUEFUNG = "In Pr√ºfung"  # Vom Notar zur Pr√ºfung markiert
    FREIGEGEBEN = "Freigegeben"  # Vom Notar freigegeben
    AKTUALISIERUNG = "Update verf√ºgbar"  # KI hat Update gefunden
    ABGELEHNT = "Abgelehnt"  # Vom Notar abgelehnt
    ARCHIVIERT = "Archiviert"  # Nicht mehr verwendet


# ============================================================================
# AKTENMANAGEMENT
# ============================================================================

class AktenHauptbereich(Enum):
    """Hauptbereiche f√ºr Notarakten"""
    ERBRECHT = "Erbrecht"
    GESELLSCHAFTSRECHT = "Gesellschaftsrecht"
    ZIVILRECHT = "Zivilrecht"
    SONSTIGE = "Sonstige"


class AktenTypErbrecht(Enum):
    """Untertypen f√ºr Erbrecht"""
    TESTAMENT_GEMEINSCHAFTLICH = "Gemeinschaftliches Testament (Eheleute)"
    TESTAMENT_EINZEL = "Einzeltestament"
    ERBVERTRAG = "Erbvertrag"
    ERBAUSSCHLAGUNG = "Erbausschlagung"
    ERBSCHEIN = "Erbschein"


class AktenTypGesellschaftsrecht(Enum):
    """Untertypen f√ºr Gesellschaftsrecht"""
    GRUENDUNG = "Gr√ºndung einer Gesellschaft"
    LIQUIDATION = "Liquidation einer Gesellschaft"
    VERKAUF_ANTEILE = "Verkauf von Gesellschaftsanteilen"
    ABTRETUNG_ANTEILE = "Abtretung von Gesellschaftsanteilen"


class AktenTypZivilrecht(Enum):
    """Untertypen f√ºr Zivilrecht"""
    IMMOBILIENKAUFVERTRAG = "Notarieller Immobilienkaufvertrag"
    UEBERLASSUNGSVERTRAG = "√úberlassungsvertrag"
    EHEVERTRAG = "Ehevertrag"
    SCHEIDUNGSFOLGENVEREINBARUNG = "Scheidungsfolgenvereinbarung"
    VORSORGEVERTRAG = "Vorsorgevertrag (Betreuungs- & Patientenverf√ºgung)"
    SORGERECHTSVERFUEGUNG = "Sorgerechtsverf√ºgung"


# AktenStatus ist bereits oben definiert (Zeile ~3713)
# Enth√§lt: IMPORTIERT, IN_BEARBEITUNG, VOLLSTAENDIG, BEURKUNDET, ABGESCHLOSSEN, ARCHIVIERT


# Mapping von Hauptbereich zu Untertypen
AKTEN_UNTERTYPEN = {
    AktenHauptbereich.ERBRECHT.value: [e.value for e in AktenTypErbrecht],
    AktenHauptbereich.GESELLSCHAFTSRECHT.value: [e.value for e in AktenTypGesellschaftsrecht],
    AktenHauptbereich.ZIVILRECHT.value: [e.value for e in AktenTypZivilrecht],
    AktenHauptbereich.SONSTIGE.value: ["Sonstiges"],
}


@dataclass
class Akte:
    """Notarielle Akte"""
    akte_id: str
    notar_id: str  # Notar, dem die Akte geh√∂rt
    sachbearbeiter_id: Optional[str] = None  # Mitarbeiter-ID

    # Aktenzeichen-Komponenten
    aktennummer: int = 0
    aktenjahr: int = 24  # 2-stellig
    verkaeufer_nachname: str = ""
    kaeufer_nachname: str = ""
    notar_kuerzel: str = ""
    mitarbeiter_kuerzel: str = ""

    # Generierte Bezeichnungen
    aktenzeichen: str = ""  # z.B. "Krug ./. M√ºller 333/24 SQ-Go"
    kurzbezeichnung: str = ""  # z.B. "Krug ./. M√ºller 333/24"

    # Kategorisierung
    hauptbereich: str = ""  # Erbrecht, Gesellschaftsrecht, Zivilrecht
    untertyp: str = ""  # Spezifischer Typ
    benutzerdefinierte_kategorie: str = ""  # Falls benutzerdefiniert

    # Verkn√ºpfung mit Projekt (falls Immobilientransaktion)
    projekt_id: Optional[str] = None

    # Parteien
    parteien: List[Dict[str, Any]] = field(default_factory=list)

    # Status
    status: str = AktenStatus.NEU.value

    # Beschreibung
    betreff: str = ""
    interne_notizen: str = ""

    # Termine
    beurkundungstermin: Optional[datetime] = None
    naechste_wiedervorlage: Optional[date] = None

    # Finanzen
    geschaeftswert: float = 0.0
    gebuehren: float = 0.0
    gebuehren_bezahlt: bool = False

    # Dokumente und Nachrichten (IDs)
    dokument_ids: List[str] = field(default_factory=list)
    nachricht_ids: List[str] = field(default_factory=list)
    textbaustein_ids: List[str] = field(default_factory=list)

    # Timestamps
    erstellt_am: datetime = field(default_factory=datetime.now)
    aktualisiert_am: datetime = field(default_factory=datetime.now)
    abgeschlossen_am: Optional[datetime] = None

    def generiere_aktenzeichen(self) -> str:
        """Generiert das vollst√§ndige Aktenzeichen"""
        vk = self.verkaeufer_nachname or "N.N."
        kf = self.kaeufer_nachname or "N.N."
        basis = f"{vk} ./. {kf} {self.aktennummer}/{self.aktenjahr:02d}"
        if self.notar_kuerzel and self.mitarbeiter_kuerzel:
            return f"{basis} {self.notar_kuerzel}-{self.mitarbeiter_kuerzel}"
        elif self.notar_kuerzel:
            return f"{basis} {self.notar_kuerzel}"
        return basis

    def generiere_kurzbezeichnung(self) -> str:
        """Generiert die Kurzbezeichnung f√ºr Kommunikation"""
        vk = self.verkaeufer_nachname or "N.N."
        kf = self.kaeufer_nachname or "N.N."
        return f"{vk} ./. {kf} {self.aktennummer}/{self.aktenjahr:02d}"


@dataclass
class BenutzerdefiniertKategorie:
    """Benutzerdefinierte Akten-Kategorie"""
    kategorie_id: str
    notar_id: str
    hauptbereich: str
    name: str
    beschreibung: str = ""
    erstellt_von_id: str = ""
    freigegeben: bool = False
    freigegeben_am: Optional[datetime] = None
    freigegeben_von_id: Optional[str] = None
    ist_aktiv: bool = True
    erstellt_am: datetime = field(default_factory=datetime.now)


@dataclass
class AktenNachricht:
    """Nachricht zu einer Akte"""
    nachricht_id: str
    akte_id: str
    absender_id: str
    empfaenger_ids: List[str] = field(default_factory=list)
    betreff: str = ""  # Wird automatisch mit Aktenzeichen pr√§fixiert
    nachricht: str = ""
    nachrichtentyp: str = "intern"  # intern, extern, notiz
    kanal: str = "portal"  # email, portal, telefon, fax
    anhaenge: List[Dict[str, Any]] = field(default_factory=list)
    gelesen: bool = False
    gelesen_am: Optional[datetime] = None
    erstellt_am: datetime = field(default_factory=datetime.now)


# Vertragstyp-Templates: Definiert die typische Reihenfolge der Kategorien f√ºr jeden Vertragstyp
# Bei "alternativen" k√∂nnen verschiedene Bausteine der gleichen Kategorie ausgew√§hlt werden
VERTRAGSTYP_TEMPLATES = {
    VertragsTyp.KAUFVERTRAG.value: {
        "name": "Kaufvertrag",
        "beschreibung": "Standard-Kaufvertrag f√ºr Immobilien",
        "kategorien_reihenfolge": [
            {"kategorie": TextbausteinKategorie.VERTRAGSPARTEIEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.KAUFGEGENSTAND.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.GRUNDBUCH.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.BELASTUNGEN.value, "pflicht": False, "mehrfach": True},
            {"kategorie": TextbausteinKategorie.KAUFPREIS.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.ZAHLUNGSMODALITAETEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.F√ÑLLIGKEIT.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.AUFLASSUNG.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.BESITZUEBERGANG.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.HAFTUNG.value, "pflicht": False, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.MAENGEL.value, "pflicht": False, "mehrfach": True},
            {"kategorie": TextbausteinKategorie.VORKAUFSRECHT.value, "pflicht": False, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.KOSTEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.VOLLMACHTEN.value, "pflicht": False, "mehrfach": True},
            {"kategorie": TextbausteinKategorie.SCHLUSSBESTIMMUNGEN.value, "pflicht": False, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.SALVATORISCH.value, "pflicht": False, "mehrfach": False},
        ]
    },
    VertragsTyp.UEBERLASSUNGSVERTRAG.value: {
        "name": "√úberlassungsvertrag",
        "beschreibung": "Vertrag zur √úberlassung von Grundst√ºcken/Immobilien",
        "kategorien_reihenfolge": [
            {"kategorie": TextbausteinKategorie.VERTRAGSPARTEIEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.KAUFGEGENSTAND.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.GRUNDBUCH.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.BELASTUNGEN.value, "pflicht": False, "mehrfach": True},
            {"kategorie": TextbausteinKategorie.AUFLASSUNG.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.BESITZUEBERGANG.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.HAFTUNG.value, "pflicht": False, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.KOSTEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.SCHLUSSBESTIMMUNGEN.value, "pflicht": False, "mehrfach": False},
        ]
    },
    VertragsTyp.ERBVERTRAG.value: {
        "name": "Erbvertrag",
        "beschreibung": "Notarieller Erbvertrag",
        "kategorien_reihenfolge": [
            {"kategorie": TextbausteinKategorie.VERTRAGSPARTEIEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.SONSTIGES.value, "pflicht": True, "mehrfach": True},
            {"kategorie": TextbausteinKategorie.KOSTEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.SCHLUSSBESTIMMUNGEN.value, "pflicht": False, "mehrfach": False},
        ]
    },
    VertragsTyp.SCHENKUNGSVERTRAG.value: {
        "name": "Schenkungsvertrag",
        "beschreibung": "Vertrag √ºber Schenkung von Immobilien",
        "kategorien_reihenfolge": [
            {"kategorie": TextbausteinKategorie.VERTRAGSPARTEIEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.KAUFGEGENSTAND.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.GRUNDBUCH.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.BELASTUNGEN.value, "pflicht": False, "mehrfach": True},
            {"kategorie": TextbausteinKategorie.AUFLASSUNG.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.BESITZUEBERGANG.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.RUECKTRITT.value, "pflicht": False, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.KOSTEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.SCHLUSSBESTIMMUNGEN.value, "pflicht": False, "mehrfach": False},
        ]
    },
    VertragsTyp.TEILUNGSERKLAERUNG.value: {
        "name": "Teilungserkl√§rung",
        "beschreibung": "WEG-Teilungserkl√§rung",
        "kategorien_reihenfolge": [
            {"kategorie": TextbausteinKategorie.VERTRAGSPARTEIEN.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.KAUFGEGENSTAND.value, "pflicht": True, "mehrfach": True},
            {"kategorie": TextbausteinKategorie.GRUNDBUCH.value, "pflicht": True, "mehrfach": False},
            {"kategorie": TextbausteinKategorie.SONSTIGES.value, "pflicht": True, "mehrfach": True},
            {"kategorie": TextbausteinKategorie.KOSTEN.value, "pflicht": True, "mehrfach": False},
        ]
    },
}

# Farben f√ºr die visuelle Baustein-Hervorhebung (wechselnde Farben)
BAUSTEIN_FARBEN = [
    "#E3F2FD",  # Hellblau
    "#E8F5E9",  # Hellgr√ºn
    "#FFEBEE",  # Hellrot/Rosa
    "#FFF3E0",  # Hellorange
    "#F3E5F5",  # Helllila
    "#E0F7FA",  # Hellcyan
]

@dataclass
class Textbaustein:
    """Ein Textbaustein (Klausel) f√ºr Vertr√§ge"""
    baustein_id: str
    notar_id: str  # Eigent√ºmer/Ersteller

    # Inhalt
    titel: str  # √úberschrift des Bausteins
    text: str  # Der eigentliche Klauseltext
    zusammenfassung: str = ""  # KI-generierte Kurzbeschreibung

    # Kategorisierung
    kategorie: str = TextbausteinKategorie.SONSTIGES.value  # Regelungsinhalt
    vertragstypen: List[str] = field(default_factory=list)  # In welchen Vertragsarten verwendbar

    # Herkunft & Kontext
    quelle_dokument_id: Optional[str] = None  # Falls aus Vertrag extrahiert
    position_im_dokument: int = 0  # Position im Ursprungsdokument
    start_index: int = 0  # Startposition im Ursprungstext (Zeichenindex)
    end_index: int = 0  # Endposition im Ursprungstext (Zeichenindex)
    vorgaenger_baustein_id: Optional[str] = None  # Vorheriger Baustein im Ursprung
    nachfolger_baustein_id: Optional[str] = None  # N√§chster Baustein im Ursprung

    # Status & Freigabe
    status: str = TextbausteinStatus.ENTWURF.value
    freigegeben_am: Optional[datetime] = None
    freigegeben_von: str = ""  # User-ID des Notars

    # Verkn√ºpfungen
    verwendet_in_vertraegen: List[str] = field(default_factory=list)  # Vertrags-IDs
    duplikat_von: Optional[str] = None  # Falls als Duplikat erkannt
    aehnliche_bausteine: List[str] = field(default_factory=list)  # √Ñhnliche Baustein-IDs

    # KI-Metadaten
    ki_generiert: bool = False  # Wurde Titel/Zusammenfassung von KI erstellt
    ki_kategorisiert: bool = False  # Wurde Kategorie von KI vorgeschlagen
    ki_update_vorschlag: str = ""  # Vorgeschlagenes Update von KI
    ki_update_quelle: str = ""  # Quelle des Updates
    ki_update_datum: Optional[datetime] = None

    # Versionen
    version: int = 1
    vorherige_version_id: Optional[str] = None  # F√ºr Versionsverlauf

    # Metadaten
    erstellt_am: datetime = field(default_factory=datetime.now)
    aktualisiert_am: datetime = field(default_factory=datetime.now)
    erstellt_von: str = ""  # User-ID des Erstellers (Mitarbeiter oder Notar)
    notizen: str = ""  # Interne Notizen

    # Text-Hash f√ºr Duplikaterkennung
    text_hash: str = ""

@dataclass
class VertragsDokument:
    """Ein hochgeladenes Vertragsdokument"""
    dokument_id: str
    notar_id: str

    # Datei-Informationen
    dateiname: str
    dateityp: str  # "docx", "pdf", "image"
    dateigroesse: int
    datei_bytes: Optional[bytes] = None

    # Extrahierter Text
    volltext: str = ""
    ocr_durchgefuehrt: bool = False

    # Kategorisierung
    vertragstyp: str = VertragsTyp.SONSTIGES.value
    beschreibung: str = ""

    # Zerlegung in Bausteine
    zerlegt: bool = False  # Wurde in Bausteine aufgeteilt
    baustein_ids: List[str] = field(default_factory=list)  # Extrahierte Bausteine
    anzahl_erkannte_klauseln: int = 0

    # Status
    status: str = "Hochgeladen"  # Hochgeladen, In Verarbeitung, Verarbeitet, Fehler
    fehler_meldung: str = ""

    # Metadaten
    hochgeladen_am: datetime = field(default_factory=datetime.now)
    hochgeladen_von: str = ""  # User-ID
    verarbeitet_am: Optional[datetime] = None

@dataclass
class VertragsVorlage:
    """Eine Vertragsvorlage aus Textbausteinen"""
    vorlage_id: str
    notar_id: str

    # Basis-Informationen
    name: str
    beschreibung: str = ""
    vertragstyp: str = VertragsTyp.KAUFVERTRAG.value

    # Struktur: Liste von Baustein-IDs in Reihenfolge
    baustein_ids: List[str] = field(default_factory=list)

    # Oder: Freier Text mit Platzhaltern
    vorlage_text: str = ""  # Falls nicht aus Bausteinen zusammengesetzt

    # Platzhalter-Definitionen
    platzhalter: Dict[str, str] = field(default_factory=dict)  # {name: beschreibung}

    # Status
    freigegeben: bool = False
    freigegeben_am: Optional[datetime] = None

    # Metadaten
    erstellt_am: datetime = field(default_factory=datetime.now)
    aktualisiert_am: datetime = field(default_factory=datetime.now)
    erstellt_von: str = ""
    version: int = 1

class VertragsentwurfStatus(Enum):
    """Status eines Vertragsentwurfs"""
    ENTWURF = "Entwurf"
    IN_BEARBEITUNG = "In Bearbeitung"
    PRUEFUNG = "Zur Pr√ºfung"
    FREIGEGEBEN = "Freigegeben"
    VERSENDET = "Versendet"
    UNTERZEICHNET = "Unterzeichnet"
    ARCHIVIERT = "Archiviert"

@dataclass
class Vertragsentwurf:
    """Ein konkreter Vertragsentwurf f√ºr ein Projekt"""
    entwurf_id: str
    notar_id: str
    projekt_id: str  # Zugeh√∂riges Immobilien-Projekt

    # Basis-Informationen
    name: str
    vertragstyp: str = VertragsTyp.KAUFVERTRAG.value

    # Inhalt
    volltext: str = ""  # Der vollst√§ndige Vertragstext
    baustein_ids: List[str] = field(default_factory=list)  # Verwendete Bausteine
    vorlage_id: Optional[str] = None  # Falls aus Vorlage erstellt

    # Parteien-spezifische Daten (ausgef√ºllte Platzhalter)
    platzhalter_werte: Dict[str, str] = field(default_factory=dict)

    # Besondere W√ºnsche
    kaeufer_wuensche: List[str] = field(default_factory=list)
    verkaeufer_wuensche: List[str] = field(default_factory=list)

    # Status & Workflow
    status: str = VertragsentwurfStatus.ENTWURF.value
    freigegeben_am: Optional[datetime] = None
    freigegeben_von: str = ""

    # Versand
    versendet_an: List[str] = field(default_factory=list)  # User-IDs
    versendet_am: Optional[datetime] = None

    # PDF-Version
    pdf_data: Optional[bytes] = None
    pdf_generiert_am: Optional[datetime] = None

    # KI-Generiert
    ki_generiert: bool = False
    ki_prompt: str = ""  # Falls KI-generiert, der verwendete Prompt

    # Versionen
    version: int = 1
    vorherige_version_id: Optional[str] = None
    aenderungshistorie: List[Dict[str, Any]] = field(default_factory=list)

    # Metadaten
    erstellt_am: datetime = field(default_factory=datetime.now)
    aktualisiert_am: datetime = field(default_factory=datetime.now)
    erstellt_von: str = ""
    notizen: str = ""

# ============================================================================
# SESSION PERSISTENZ (COOKIES/LOCAL STORAGE)
# ============================================================================

def inject_session_persistence():
    """Injiziert JavaScript f√ºr Session-Persistenz √ºber Browser-Refreshes"""
    st.markdown("""
    <script>
    (function() {
        // Session Token aus localStorage lesen und URL aktualisieren
        const sessionData = localStorage.getItem('immo_session');
        if (sessionData) {
            try {
                const data = JSON.parse(sessionData);
                const url = new URL(window.location.href);

                // Nur hinzuf√ºgen wenn noch nicht vorhanden
                if (!url.searchParams.has('session_email') && data.email && data.token) {
                    url.searchParams.set('session_email', data.email);
                    url.searchParams.set('session_token', data.token);

                    // URL aktualisieren ohne Seite neu zu laden (falls m√∂glich)
                    if (window.history && window.history.replaceState) {
                        window.history.replaceState({}, '', url.toString());
                        // Seite neu laden um Session zu aktivieren
                        window.location.reload();
                    }
                }
            } catch (e) {
                console.log('Session parse error:', e);
            }
        }
    })();

    // Funktion zum Speichern der Session
    window.saveImmoSession = function(email, token) {
        const data = {email: email, token: token, timestamp: Date.now()};
        localStorage.setItem('immo_session', JSON.stringify(data));

        // URL mit Session-Parametern aktualisieren
        const url = new URL(window.location.href);
        url.searchParams.set('session_email', email);
        url.searchParams.set('session_token', token);
        window.history.replaceState({}, '', url.toString());
    };

    // Funktion zum L√∂schen der Session
    window.clearImmoSession = function() {
        localStorage.removeItem('immo_session');

        // URL-Parameter entfernen
        const url = new URL(window.location.href);
        url.searchParams.delete('session_email');
        url.searchParams.delete('session_token');
        window.history.replaceState({}, '', url.toString());
    };

    // Funktion zum Abrufen der Session
    window.getImmoSession = function() {
        const data = localStorage.getItem('immo_session');
        return data ? JSON.parse(data) : null;
    };
    </script>
    """, unsafe_allow_html=True)


def get_session_token(email: str) -> str:
    """Generiert einen Session-Token f√ºr den Benutzer"""
    # Kombination aus Email und einem Salt f√ºr Sicherheit
    token_data = f"{email}_{datetime.now().isoformat()}"
    return hashlib.sha256(token_data.encode()).hexdigest()[:32]


def save_session_to_browser(email: str, token: str):
    """Speichert Session-Daten im Browser localStorage"""
    st.markdown(f"""
    <script>
    if (typeof window.saveImmoSession === 'function') {{
        window.saveImmoSession('{email}', '{token}');
    }} else {{
        const data = {{email: '{email}', token: '{token}', timestamp: Date.now()}};
        localStorage.setItem('immo_session', JSON.stringify(data));
    }}
    </script>
    """, unsafe_allow_html=True)


def clear_session_from_browser():
    """L√∂scht Session-Daten aus dem Browser localStorage"""
    st.markdown("""
    <script>
    if (typeof window.clearImmoSession === 'function') {
        window.clearImmoSession();
    } else {
        localStorage.removeItem('immo_session');
    }
    </script>
    """, unsafe_allow_html=True)


def restore_session_from_storage():
    """Versucht Session aus Browser-Storage wiederherzustellen"""
    # Diese Funktion verwendet st.query_params als Workaround
    # da JavaScript localStorage nicht direkt aus Python lesbar ist
    query_params = st.query_params

    if "session_email" in query_params and "session_token" in query_params:
        email = query_params.get("session_email")
        token = query_params.get("session_token")

        # Benutzer anhand der Email finden
        for user in st.session_state.users.values():
            if user.email == email:
                # Session-Token validieren (vereinfacht)
                if st.session_state.get('valid_tokens', {}).get(email) == token:
                    return user

        # Auch Notar-Mitarbeiter pr√ºfen
        for ma in st.session_state.notar_mitarbeiter.values():
            if ma.email == email and ma.aktiv:
                if st.session_state.get('valid_tokens', {}).get(email) == token:
                    return ma

    return None


# ============================================================================
# SESSION STATE INITIALISIERUNG
# ============================================================================

def init_session_state():
    """Initialisiert den Session State mit Demo-Daten"""
    if 'initialized' not in st.session_state:
        st.session_state.initialized = True
        st.session_state.current_user = None
        st.session_state.users = {}
        st.session_state.projekte = {}
        st.session_state.legal_documents = {}
        st.session_state.financing_offers = {}
        st.session_state.preisangebote = {}  # Preisverhandlung zwischen K√§ufer/Verk√§ufer
        st.session_state.wirtschaftsdaten = {}
        st.session_state.notifications = {}
        st.session_state.comments = {}
        st.session_state.invitations = {}
        st.session_state.timeline_events = {}

        # Neue Datenstrukturen
        st.session_state.makler_profiles = {}
        st.session_state.expose_data = {}
        st.session_state.document_requests = {}
        st.session_state.notar_checklists = {}
        st.session_state.bank_folders = {}
        st.session_state.notar_mitarbeiter = {}
        st.session_state.verkaeufer_dokumente = {}

        # Termin-Koordination
        st.session_state.termine = {}  # Termin-ID -> Termin
        st.session_state.terminvorschlaege = {}  # Vorschlag-ID -> TerminVorschlag
        st.session_state.notar_kalender = {}  # Simulierter Outlook-Kalender

        # Makler-Empfehlungssystem
        st.session_state.makler_empfehlungen = {}  # ID -> MaklerEmpfehlung

        # Finanzierungs-Erweiterung
        st.session_state.finanzierer_einladungen = {}  # ID -> FinanziererEinladung
        st.session_state.finanzierungsanfragen = {}  # ID -> FinanzierungsAnfrage
        st.session_state.finanzierungsmodelle = {}  # ID -> Finanzierungsmodell

        # Automatische Marktanalyse
        st.session_state.marktanalyse_ergebnisse = {}  # Projekt-ID -> MarktanalyseErgebnis
        st.session_state.marktpreis_historie = {}  # Projekt-ID -> List[MarktpreisHistorie]

        # Notar-Datenermittlung
        st.session_state.flurkart_anfragen = {}  # ID -> FlurkartAnfrage
        st.session_state.grundbuch_anfragen = {}  # ID -> GrundbuchAnfrage
        st.session_state.baulasten_anfragen = {}  # ID -> BaulastenAnfrage
        st.session_state.steuer_id_abfragen = {}  # ID -> SteuerIDAbfrage
        st.session_state.grunderwerbsteuer_meldungen = {}  # ID -> GrunderwerbsteuerMeldung
        st.session_state.vorkaufsrecht_anfragen = {}  # ID -> VorkaufsrechtAnfrage

        # K√§ufer-Todos
        st.session_state.kaeufer_todos = {}  # ID -> KaeuferTodo

        # Handwerker-Empfehlungen (vom Notar verwaltet)
        st.session_state.handwerker_empfehlungen = {}  # ID -> Handwerker
        st.session_state.handwerker_bewertungen = {}  # VERBESSERUNG 7: ID -> HandwerkerBewertung

        # Ideenboard f√ºr K√§ufer
        st.session_state.ideenboard = {}  # ID -> IdeenboardEintrag

        # Aktentaschen f√ºr alle Benutzer
        st.session_state.aktentaschen = {}  # User-ID -> Aktentasche

        # Importierte Akten (Notar)
        st.session_state.importierte_akten = {}  # Akte-ID -> ImportierteAkte

        # NEU: Gesellschaften und Parteien
        st.session_state.gesellschaften = {}  # Gesellschaft-ID -> Gesellschaft
        st.session_state.organe = {}  # Organ-ID -> Organ
        st.session_state.hr_eintraege = {}  # HR-ID -> HandelsregisterEintrag
        st.session_state.parteien = {}  # Partei-ID -> Partei

        # NEU: Aktenzeichen-Z√§hler pro Notar und Jahr
        st.session_state.aktenzeichen_zaehler = {}  # "notar_id_jahr" -> letzte_nummer

        # ===== KOMMUNIKATIONS-ERWEITERUNGEN =====
        # Briefk√∂pfe
        st.session_state.briefkoepfe = {}  # Briefkopf-ID -> Briefkopf

        # E-Mail-Signaturen
        st.session_state.email_signaturen = {}  # Signatur-ID -> EmailSignatur

        # Makler-Mitarbeiter
        st.session_state.makler_mitarbeiter = {}  # Mitarbeiter-ID -> MaklerMitarbeiter

        # Kommunikation
        st.session_state.nachrichten = {}  # Nachricht-ID -> KommunikationsNachricht
        st.session_state.kommunikations_anlagen = {}  # Anlage-ID -> KommunikationsAnlage

        # Akten-Ordner
        st.session_state.akten_ordner = {}  # Ordner-ID -> AktenOrdner

        # Gespeicherte Suchen
        st.session_state.gespeicherte_suchen = {}  # Suche-ID -> GespeicherteSuche

        # Audit-Log
        st.session_state.audit_log = []  # Liste von AuditLogEintrag

        # ===== BENACHRICHTIGUNGS-CENTER =====
        st.session_state.eingaenge = {}  # Eingang-ID -> Eingang
        st.session_state.antwort_vorlagen = {}  # Vorlage-ID -> AntwortVorlage
        st.session_state.fristen = {}  # Frist-ID -> Frist
        st.session_state.gating_pruefungen = {}  # Pruefung-ID -> GatingPruefung
        st.session_state.dokument_versionen = {}  # Version-ID -> DokumentVersionierung
        st.session_state.kpi_snapshots = {}  # Snapshot-ID -> KPISnapshot
        st.session_state.bericht_konfigurationen = {}  # Bericht-ID -> BerichtKonfiguration

        # ===== VERTRAGSVERSIONEN & VERGLEICH =====
        st.session_state.vertrags_versionen = {}  # Version-ID -> VertragsVersion
        st.session_state.text_aenderungen = {}  # Aenderung-ID -> TextAenderung

        # System-Antwortvorlagen initialisieren
        _initialisiere_system_antwortvorlagen()

        # API-Keys f√ºr OCR (vom Notar konfigurierbar)
        # Zuerst versuchen aus st.secrets zu laden (persistent)
        st.session_state.api_keys = {
            'openai': '',
            'anthropic': ''
        }

        # API-Keys aus Streamlit Secrets laden (falls vorhanden)
        try:
            if hasattr(st, 'secrets'):
                if 'OPENAI_API_KEY' in st.secrets:
                    st.session_state.api_keys['openai'] = st.secrets['OPENAI_API_KEY']
                if 'ANTHROPIC_API_KEY' in st.secrets:
                    st.session_state.api_keys['anthropic'] = st.secrets['ANTHROPIC_API_KEY']
        except Exception:
            pass  # Secrets nicht verf√ºgbar

        # Session-Tokens f√ºr "Angemeldet bleiben"
        st.session_state.valid_tokens = {}

        # Rechtsdokumente-Akzeptanzen (User -> Notar -> Dokument -> Datum)
        st.session_state.rechtsdokument_akzeptanzen = {}

        # Notar-Rechtsdokumente (Datenschutz, AGB, Widerruf)
        st.session_state.notar_rechtsdokumente = {}

        # ============================================================
        # VERTRAGSARCHIV & TEXTBAUSTEINE
        # ============================================================
        st.session_state.textbausteine = {}  # baustein_id -> Textbaustein
        st.session_state.vertragsdokumente = {}  # dokument_id -> VertragsDokument
        st.session_state.vertragsvorlagen = {}  # vorlage_id -> VertragsVorlage
        st.session_state.vertragsentwuerfe = {}  # entwurf_id -> Vertragsentwurf

        # ============================================================
        # AKTENMANAGEMENT
        # ============================================================
        st.session_state.akten = {}  # akte_id -> Akte
        st.session_state.akten_nachrichten = {}  # nachricht_id -> AktenNachricht
        st.session_state.benutzerdefinierte_kategorien = {}  # kategorie_id -> BenutzerdefiniertKategorie
        st.session_state.notar_kuerzel = {}  # notar_id -> kuerzel (z.B. "SQ")
        st.session_state.mitarbeiter_kuerzel = {}  # mitarbeiter_id -> kuerzel (z.B. "Go")
        st.session_state.letzte_aktennummer = {}  # notar_id -> {jahr: nummer}

        # Datenbank-Status
        st.session_state.database_connected = False
        st.session_state.database_status = None

        # Datenbank initialisieren (falls verf√ºgbar)
        if DATABASE_AVAILABLE:
            try:
                db_status = check_database_connection()
                if db_status.get('connected'):
                    st.session_state.database_connected = True
                    st.session_state.database_status = db_status
                    # Tabellen erstellen falls nicht vorhanden
                    init_database(drop_existing=False)
            except Exception as e:
                st.session_state.database_status = {'error': str(e)}

        # Demo-Daten
        create_demo_users()
        create_demo_projekt()
        create_demo_timeline()
        create_demo_makler_empfehlungen()
        create_demo_handwerker()
        create_demo_notar_rechtsdokumente()

def create_demo_users():
    """Erstellt Demo-Benutzer f√ºr alle Rollen"""
    demo_users = [
        User("makler1", "Max Makler", "makler@demo.de", UserRole.MAKLER.value, hash_password("makler123")),
        User("kaeufer1", "Karl K√§ufer", "kaeufer@demo.de", UserRole.KAEUFER.value, hash_password("kaeufer123"), projekt_ids=["projekt1"]),
        User("verkaeufer1", "Vera Verk√§ufer", "verkaeufer@demo.de", UserRole.VERKAEUFER.value, hash_password("verkaeufer123"), projekt_ids=["projekt1"]),
        User("finanzierer1", "Frank Finanzierer", "finanz@demo.de", UserRole.FINANZIERER.value, hash_password("finanz123"), projekt_ids=["projekt1"]),
        User("notar1", "Nina Notar", "notar@demo.de", UserRole.NOTAR.value, hash_password("notar123"), projekt_ids=["projekt1"]),
    ]
    for user in demo_users:
        st.session_state.users[user.user_id] = user

def create_demo_projekt():
    """Erstellt ein Demo-Projekt"""
    projekt = Projekt(
        projekt_id="projekt1",
        name="Musterwohnung M√ºnchen",
        beschreibung="Sch√∂ne 3-Zimmer-Wohnung in M√ºnchen-Schwabing, 85m¬≤, Baujahr 2015",
        adresse="Leopoldstra√üe 123, 80802 M√ºnchen",
        kaufpreis=485000.00,
        makler_id="makler1",
        kaeufer_ids=["kaeufer1"],
        verkaeufer_ids=["verkaeufer1"],
        finanzierer_ids=["finanzierer1"],
        notar_id="notar1",
        status=ProjektStatus.TEILNEHMER_EINGELADEN.value
    )
    st.session_state.projekte[projekt.projekt_id] = projekt

    # Automatisch Akte f√ºr Demo-Projekt erstellen und verkn√ºpfen
    if projekt.notar_id:
        verknuepfe_projekt_mit_notar(projekt.projekt_id, projekt.notar_id)

def create_demo_timeline():
    """Erstellt Demo-Timeline-Events"""
    events = [
        TimelineEvent("evt1", "projekt1", "Projekt erstellt", "Projekt wurde vom Makler angelegt", ProjektStatus.VORBEREITUNG.value, True, datetime.now() - timedelta(days=10), 1, None),
        TimelineEvent("evt2", "projekt1", "Expos√© hochgeladen", "Expos√© wurde bereitgestellt", ProjektStatus.EXPOSE_ERSTELLT.value, True, datetime.now() - timedelta(days=9), 2, None),
        TimelineEvent("evt3", "projekt1", "Teilnehmer eingeladen", "K√§ufer und Verk√§ufer wurden eingeladen", ProjektStatus.TEILNEHMER_EINGELADEN.value, True, datetime.now() - timedelta(days=8), 3, None),
        TimelineEvent("evt4", "projekt1", "Onboarding-Dokumente akzeptieren", "K√§ufer und Verk√§ufer m√ºssen rechtliche Dokumente akzeptieren", ProjektStatus.ONBOARDING_LAUFEND.value, False, None, 4, "K√§ufer und Verk√§ufer m√ºssen Maklerauftrag, Datenschutz, Widerrufsbelehrung akzeptieren"),
        TimelineEvent("evt5", "projekt1", "Wirtschaftsdaten hochladen", "K√§ufer l√§dt Bonit√§tsunterlagen hoch", ProjektStatus.WIRTSCHAFTSDATEN_HOCHGELADEN.value, False, None, 5, "K√§ufer muss BWA, Einkommensnachweise und Verm√∂gensnachweise hochladen"),
        TimelineEvent("evt6", "projekt1", "Finanzierungsanfrage", "Finanzierer pr√ºft Unterlagen und erstellt Angebot", ProjektStatus.FINANZIERUNG_ANGEFRAGT.value, False, None, 6, "Finanzierer muss Wirtschaftsdaten pr√ºfen und Finanzierungsangebot erstellen"),
        TimelineEvent("evt7", "projekt1", "Finanzierung gesichert", "K√§ufer nimmt Finanzierungsangebot an", ProjektStatus.FINANZIERUNG_GESICHERT.value, False, None, 7, "K√§ufer muss Finanzierungsangebot annehmen"),
        TimelineEvent("evt8", "projekt1", "Notartermin vereinbaren", "Notartermin wird festgelegt", ProjektStatus.NOTARTERMIN_VEREINBART.value, False, None, 8, "Makler oder Notar muss Termin vereinbaren"),
        TimelineEvent("evt9", "projekt1", "Kaufvertrag unterzeichnen", "Alle Parteien unterzeichnen beim Notar", ProjektStatus.KAUFVERTRAG_UNTERZEICHNET.value, False, None, 9, "K√§ufer und Verk√§ufer beim Notartermin"),
        TimelineEvent("evt10", "projekt1", "Transaktion abgeschlossen", "√úbergabe und Eintragung ins Grundbuch", ProjektStatus.ABGESCHLOSSEN.value, False, None, 10, "Notar best√§tigt Abschluss"),
    ]
    for event in events:
        st.session_state.timeline_events[event.event_id] = event
        if event.event_id not in st.session_state.projekte["projekt1"].timeline_events:
            st.session_state.projekte["projekt1"].timeline_events.append(event.event_id)

def create_demo_makler_empfehlungen():
    """Erstellt Demo-Makler-Empfehlungen vom Notar"""
    import uuid

    # Demo-Makler, die vom Notar empfohlen wurden
    demo_empfehlungen = [
        MaklerEmpfehlung(
            empfehlung_id="emp1",
            notar_id="notar1",
            makler_email="premium.makler@mallorca.de",
            makler_name="Carlos Immobilien",
            firmenname="Carlos Premium Immobilien S.L.",
            status=MaklerEmpfehlungStatus.FREIGEGEBEN.value,
            kurzvita="Seit 25 Jahren spezialisiert auf Luxusimmobilien in Mallorca. √úber 500 erfolgreiche Transaktionen. Deutschsprachige Betreuung.",
            telefon="+34 971 123 456",
            website="www.carlos-immobilien.es",
            adresse="Paseo Mar√≠timo 45, 07015 Palma de Mallorca",
            spezialisierung=["Luxusimmobilien", "Ferienimmobilien", "Neubauprojekte"],
            regionen=["Mallorca", "Ibiza"],
            provision_kaeufer_prozent=3.0,
            provision_verkaeufer_prozent=3.0,
            freigegeben_am=datetime.now() - timedelta(days=30),
            onboarding_token=str(uuid.uuid4())
        ),
        MaklerEmpfehlung(
            empfehlung_id="emp2",
            notar_id="notar1",
            makler_email="info@costa-homes.de",
            makler_name="Costa Homes GmbH",
            firmenname="Costa Homes Immobilien GmbH",
            status=MaklerEmpfehlungStatus.FREIGEGEBEN.value,
            kurzvita="Deutsches Maklerb√ºro mit Niederlassung auf den Balearen. Rechtssichere Abwicklung durch deutsche Anw√§lte.",
            telefon="+49 89 123 4567",
            website="www.costa-homes.de",
            adresse="Maximilianstra√üe 10, 80539 M√ºnchen",
            spezialisierung=["Ferienimmobilien", "Anlageimmobilien"],
            regionen=["Mallorca", "Costa Brava", "Algarve"],
            provision_kaeufer_prozent=3.57,
            provision_verkaeufer_prozent=3.57,
            freigegeben_am=datetime.now() - timedelta(days=60),
            onboarding_token=str(uuid.uuid4())
        ),
        MaklerEmpfehlung(
            empfehlung_id="emp3",
            notar_id="notar1",
            makler_email="kontakt@insel-immobilien.de",
            makler_name="Insel Immobilien",
            firmenname="Insel Immobilien Verwaltungs GmbH",
            status=MaklerEmpfehlungStatus.EINGELADEN.value,
            kurzvita="",  # Noch nicht ausgef√ºllt
            telefon="",
            onboarding_token=str(uuid.uuid4())
        ),
    ]

    for emp in demo_empfehlungen:
        st.session_state.makler_empfehlungen[emp.empfehlung_id] = emp


def create_demo_handwerker():
    """Erstellt Demo-Handwerker vom Notar"""
    demo_handwerker = [
        Handwerker(
            handwerker_id="hw1",
            notar_id="notar1",
            firmenname="M√ºller Elektrotechnik GmbH",
            kategorie=HandwerkerKategorie.ELEKTRIKER.value,
            kontaktperson="Thomas M√ºller",
            telefon="089 123 456",
            email="info@mueller-elektro.de",
            adresse="Elektrikerstra√üe 5, 80333 M√ºnchen",
            webseite="www.mueller-elektro.de",
            beschreibung="Spezialisiert auf Smart Home Installation, E-Check und Photovoltaik. Meisterbetrieb seit 1985.",
            bewertung=5,
            empfohlen=True,
            notizen="Sehr zuverl√§ssig, faire Preise"
        ),
        Handwerker(
            handwerker_id="hw2",
            notar_id="notar1",
            firmenname="Schmidt Sanit√§r & Heizung",
            kategorie=HandwerkerKategorie.SANITAER.value,
            kontaktperson="Klaus Schmidt",
            telefon="089 234 567",
            email="kontakt@schmidt-sanitaer.de",
            adresse="Wasserweg 12, 80335 M√ºnchen",
            webseite="www.schmidt-sanitaer.de",
            beschreibung="Badsanierung, Heizungsmodernisierung, 24h Notdienst. Fachbetrieb f√ºr W√§rmepumpen.",
            bewertung=4,
            empfohlen=True,
            notizen="Schnelle Reaktionszeit"
        ),
        Handwerker(
            handwerker_id="hw3",
            notar_id="notar1",
            firmenname="Meister Maler Huber",
            kategorie=HandwerkerKategorie.MALER.value,
            kontaktperson="Franz Huber",
            telefon="089 345 678",
            email="huber@meister-maler.de",
            adresse="Farbgasse 8, 80337 M√ºnchen",
            webseite="",
            beschreibung="Malerarbeiten, Tapezieren, Fassadengestaltung. Traditioneller Handwerksbetrieb.",
            bewertung=5,
            empfohlen=True,
            notizen=""
        ),
        Handwerker(
            handwerker_id="hw4",
            notar_id="notar1",
            firmenname="Schreiner Werkstatt Weber",
            kategorie=HandwerkerKategorie.TISCHLER.value,
            kontaktperson="Michael Weber",
            telefon="089 456 789",
            email="weber@schreiner-weber.de",
            adresse="Holzstra√üe 20, 80339 M√ºnchen",
            webseite="www.schreiner-weber.de",
            beschreibung="Einbauschr√§nke, K√ºchenmontage, T√ºren und Fenster. Individuelle M√∂belanfertigung.",
            bewertung=4,
            empfohlen=True,
            notizen="Spezialisiert auf hochwertige Einbauten"
        ),
        Handwerker(
            handwerker_id="hw5",
            notar_id="notar1",
            firmenname="Schnell & Sicher Umz√ºge GmbH",
            kategorie=HandwerkerKategorie.UMZUG.value,
            kontaktperson="Stefan Bauer",
            telefon="089 567 890",
            email="info@schnell-sicher-umzuege.de",
            adresse="Transportweg 15, 80341 M√ºnchen",
            webseite="www.schnell-sicher-umzuege.de",
            beschreibung="Komplettumz√ºge, M√∂belmontage, Einlagerung. Umz√ºge bundesweit und international. Versichert und zertifiziert.",
            bewertung=5,
            empfohlen=True,
            notizen="Sehr p√ºnktlich, sorgf√§ltiger Umgang mit M√∂beln"
        ),
        Handwerker(
            handwerker_id="hw6",
            notar_id="notar1",
            firmenname="Glanzrein Geb√§udereinigung",
            kategorie=HandwerkerKategorie.REINIGUNG.value,
            kontaktperson="Anna Glaser",
            telefon="089 678 901",
            email="service@glanzrein.de",
            adresse="Sauberstra√üe 7, 80343 M√ºnchen",
            webseite="www.glanzrein.de",
            beschreibung="Bauendreinigung, Umzugsreinigung, regelm√§√üige Geb√§udereinigung. √ñkologische Reinigungsmittel.",
            bewertung=4,
            empfohlen=True,
            notizen="Ideal f√ºr Endreinigung vor √úbergabe"
        ),
    ]

    for hw in demo_handwerker:
        st.session_state.handwerker_empfehlungen[hw.handwerker_id] = hw


def create_demo_notar_rechtsdokumente():
    """Erstellt Demo-Rechtsdokumente f√ºr den Notar"""
    if 'notar_rechtsdokumente' not in st.session_state:
        st.session_state.notar_rechtsdokumente = {}

    # Demo-Rechtsdokumente f√ºr notar1
    st.session_state.notar_rechtsdokumente["notar1"] = {
        'datenschutz': {
            'titel': 'Datenschutzerkl√§rung',
            'inhalt': '''**Datenschutzerkl√§rung f√ºr die Immobilien-Transaktionsplattform**

1. **Verantwortlicher:** Notariat M√ºnchen, Leopoldstra√üe 1, 80802 M√ºnchen

2. **Erhebung und Verarbeitung personenbezogener Daten:**
   Wir erheben und verarbeiten Ihre personenbezogenen Daten (Name, Adresse, Kontaktdaten, Ausweisdaten) ausschlie√ülich zur Durchf√ºhrung der Immobilientransaktion.

3. **Rechtsgrundlage:** Die Verarbeitung erfolgt auf Grundlage von Art. 6 Abs. 1 lit. b DSGVO (Vertragserf√ºllung) sowie Art. 6 Abs. 1 lit. c DSGVO (rechtliche Verpflichtung).

4. **Speicherdauer:** Ihre Daten werden f√ºr die Dauer der gesetzlichen Aufbewahrungsfristen (10 Jahre) gespeichert.

5. **Ihre Rechte:** Sie haben das Recht auf Auskunft, Berichtigung, L√∂schung, Einschr√§nkung der Verarbeitung sowie Daten√ºbertragbarkeit.

6. **Kontakt:** Bei Fragen wenden Sie sich an datenschutz@notariat-muenchen.de''',
            'version': '1.0',
            'gueltig_ab': datetime.now().date(),
            'pflicht': True
        },
        'agb': {
            'titel': 'Allgemeine Gesch√§ftsbedingungen',
            'inhalt': '''**Allgemeine Gesch√§ftsbedingungen (AGB) f√ºr die Nutzung der Immobilien-Transaktionsplattform**

¬ß1 **Geltungsbereich**
Diese AGB gelten f√ºr alle Nutzer der Plattform zur Abwicklung von Immobilientransaktionen.

¬ß2 **Leistungsumfang**
Die Plattform dient der digitalen Unterst√ºtzung bei Immobilienk√§ufen und -verk√§ufen, insbesondere der Dokumentenverwaltung, Terminkoordination und Kommunikation zwischen den Parteien.

¬ß3 **Pflichten der Nutzer**
- Wahrheitsgem√§√üe Angaben zu pers√∂nlichen Daten
- Vertrauliche Behandlung von Zugangsdaten
- Unverz√ºgliche Meldung von Sicherheitsvorf√§llen

¬ß4 **Haftung**
Die Haftung beschr√§nkt sich auf Vorsatz und grobe Fahrl√§ssigkeit. Die Haftung f√ºr leichte Fahrl√§ssigkeit ist ausgeschlossen.

¬ß5 **Schlussbestimmungen**
Es gilt deutsches Recht. Gerichtsstand ist M√ºnchen.''',
            'version': '1.0',
            'gueltig_ab': datetime.now().date(),
            'pflicht': True
        },
        'widerruf': {
            'titel': 'Widerrufsbelehrung',
            'inhalt': '''**Widerrufsbelehrung**

**Widerrufsrecht:**
Sie haben das Recht, binnen vierzehn Tagen ohne Angabe von Gr√ºnden diesen Vertrag zu widerrufen.

Die Widerrufsfrist betr√§gt vierzehn Tage ab dem Tag des Vertragsabschlusses.

Um Ihr Widerrufsrecht auszu√ºben, m√ºssen Sie uns (Notariat M√ºnchen, Leopoldstra√üe 1, 80802 M√ºnchen, E-Mail: widerruf@notariat-muenchen.de) mittels einer eindeutigen Erkl√§rung √ºber Ihren Entschluss, diesen Vertrag zu widerrufen, informieren.

**Folgen des Widerrufs:**
Wenn Sie diesen Vertrag widerrufen, haben wir Ihnen alle Zahlungen, die wir von Ihnen erhalten haben, unverz√ºglich zur√ºckzuzahlen.

**Hinweis:**
Das Widerrufsrecht erlischt bei Vertr√§gen zur Erbringung von Dienstleistungen, wenn die Dienstleistung vollst√§ndig erbracht wurde.''',
            'version': '1.0',
            'gueltig_ab': datetime.now().date(),
            'pflicht': True
        }
    }


def hash_password(password: str) -> str:
    """Einfaches Password-Hashing"""
    return hashlib.sha256(password.encode()).hexdigest()


def render_dashboard_search(dashboard_name: str) -> str:
    """
    Rendert eine Suchleiste f√ºr Dashboards und gibt den Suchbegriff zur√ºck.
    """
    search_key = f"search_{dashboard_name}"

    col1, col2 = st.columns([4, 1])
    with col1:
        search_term = st.text_input(
            "üîç Suche",
            key=search_key,
            placeholder="Projekte, Dokumente, Namen durchsuchen...",
            label_visibility="collapsed"
        )
    with col2:
        if search_term:
            if st.button("‚úñ L√∂schen", key=f"clear_{search_key}"):
                st.session_state[search_key] = ""
                st.rerun()

    return search_term.lower().strip() if search_term else ""


def search_matches(search_term: str, *fields) -> bool:
    """
    Pr√ºft ob der Suchbegriff in einem der Felder vorkommt.

    Args:
        search_term: Der Suchbegriff (lowercase)
        *fields: Felder zum Durchsuchen (werden zu String konvertiert)

    Returns:
        True wenn Suchbegriff gefunden wurde
    """
    if not search_term:
        return True

    for field in fields:
        if field is not None:
            field_str = str(field).lower()
            if search_term in field_str:
                return True
    return False


def filter_projekte_by_search(projekte: list, search_term: str) -> list:
    """Filtert Projekte nach Suchbegriff"""
    if not search_term:
        return projekte

    return [p for p in projekte if search_matches(
        search_term,
        p.name,
        p.beschreibung,
        p.adresse,
        str(p.kaufpreis),
        p.status
    )]


def filter_dokumente_by_search(dokumente: list, search_term: str) -> list:
    """Filtert Dokumente nach Suchbegriff"""
    if not search_term:
        return dokumente

    return [d for d in dokumente if search_matches(
        search_term,
        getattr(d, 'filename', ''),
        getattr(d, 'name', ''),
        getattr(d, 'kategorie', ''),
        getattr(d, 'doc_type', ''),
        getattr(d, 'ocr_text', '')
    )]


def filter_angebote_by_search(angebote: list, search_term: str) -> list:
    """Filtert Finanzierungsangebote nach Suchbegriff"""
    if not search_term:
        return angebote

    filtered = []
    for offer in angebote:
        # Projekt-Name holen
        projekt = st.session_state.projekte.get(offer.projekt_id)
        projekt_name = projekt.name if projekt else ""

        # Finanzierer-Name holen
        finanzierer = st.session_state.users.get(offer.finanzierer_id)
        finanzierer_name = finanzierer.name if finanzierer else ""

        if search_matches(
            search_term,
            projekt_name,
            finanzierer_name,
            offer.produktname,
            str(offer.darlehensbetrag),
            str(offer.zinssatz),
            offer.besondere_bedingungen,
            offer.status
        ):
            filtered.append(offer)

    return filtered


def display_search_results_info(total: int, filtered: int, search_term: str):
    """Zeigt Info √ºber Suchergebnisse an"""
    if search_term:
        st.caption(f"üîç {filtered} von {total} Ergebnissen f√ºr \"{search_term}\"")


# ============================================================================
# HELPER-FUNKTIONEN
# ============================================================================

def create_notification(user_id: str, titel: str, nachricht: str, typ: str = NotificationType.INFO.value, link: str = None):
    """Erstellt eine neue Benachrichtigung"""
    notif_id = f"notif_{len(st.session_state.notifications)}"
    notification = Notification(
        notif_id=notif_id,
        user_id=user_id,
        titel=titel,
        nachricht=nachricht,
        typ=typ,
        created_at=datetime.now(),
        link=link
    )
    st.session_state.notifications[notif_id] = notification
    if user_id in st.session_state.users:
        st.session_state.users[user_id].notifications.append(notif_id)
    return notif_id

def get_unread_notifications(user_id: str) -> List[Notification]:
    """Holt ungelesene Benachrichtigungen"""
    user = st.session_state.users.get(user_id)
    if not user:
        return []

    notifications = []
    for notif_id in user.notifications:
        notif = st.session_state.notifications.get(notif_id)
        if notif and not notif.gelesen:
            notifications.append(notif)

    return sorted(notifications, key=lambda x: x.created_at, reverse=True)

# ===== PREISVERHANDLUNG HELPER FUNCTIONS =====

def kann_preisverhandlung_fuehren(projekt: Projekt, user_id: str, user_rolle: str) -> bool:
    """
    Pr√ºft ob ein User Preisverhandlungen f√ºr dieses Projekt f√ºhren kann.
    - Ohne Makler: immer erlaubt f√ºr K√§ufer/Verk√§ufer
    - Mit Makler: nur wenn preisverhandlung_erlaubt = True
    """
    if user_rolle not in ["K√§ufer", "Verk√§ufer"]:
        return False

    # Pr√ºfen ob User am Projekt beteiligt ist
    if user_rolle == "K√§ufer" and user_id not in projekt.kaeufer_ids:
        return False
    if user_rolle == "Verk√§ufer" and user_id not in projekt.verkaeufer_ids:
        return False

    # Ohne Makler: immer erlaubt
    if not projekt.makler_id:
        return True

    # Mit Makler: nur wenn erlaubt
    return getattr(projekt, 'preisverhandlung_erlaubt', False)

def create_preisangebot(projekt_id: str, von_user_id: str, von_rolle: str, betrag: float, nachricht: str = "") -> str:
    """Erstellt ein neues Preisangebot"""
    angebot_id = f"preis_{len(st.session_state.preisangebote)}_{datetime.now().strftime('%Y%m%d%H%M%S')}"

    angebot = Preisangebot(
        angebot_id=angebot_id,
        projekt_id=projekt_id,
        von_user_id=von_user_id,
        von_rolle=von_rolle,
        betrag=betrag,
        nachricht=nachricht,
        status=PreisangebotStatus.OFFEN.value,
        erstellt_am=datetime.now()
    )

    st.session_state.preisangebote[angebot_id] = angebot

    # Preisverhandlung tracken (f√ºr ML-Training)
    safe_track_interaktion(
        interaktions_typ='preisvorschlag',
        details={
            'angebot_id': angebot_id,
            'betrag': betrag,
            'von_rolle': von_rolle,
            'status': 'offen'
        },
        nutzer_id=von_user_id,
        projekt_id=projekt_id
    )

    # Benachrichtigungen an Gegenseite
    projekt = st.session_state.projekte.get(projekt_id)
    if projekt:
        von_user = st.session_state.users.get(von_user_id)
        von_name = von_user.name if von_user else "Unbekannt"

        # Benachrichtige Gegenseite
        if von_rolle == "K√§ufer":
            # Benachrichtige alle Verk√§ufer
            for vk_id in projekt.verkaeufer_ids:
                create_notification(
                    user_id=vk_id,
                    titel="üí∞ Neues Preisangebot erhalten",
                    nachricht=f"{von_name} bietet {format_euro(betrag)} ‚Ç¨ f√ºr {projekt.name}",
                    typ=NotificationType.INFO.value
                )
        else:
            # Benachrichtige alle K√§ufer
            for kf_id in projekt.kaeufer_ids:
                create_notification(
                    user_id=kf_id,
                    titel="üí∞ Neues Preisangebot vom Verk√§ufer",
                    nachricht=f"{von_name} bietet {format_euro(betrag)} ‚Ç¨ f√ºr {projekt.name}",
                    typ=NotificationType.INFO.value
                )

        # Wenn Makler vorhanden, auch informieren
        if projekt.makler_id:
            create_notification(
                user_id=projekt.makler_id,
                titel="üí∞ Preisangebot in Ihrem Projekt",
                nachricht=f"{von_name} ({von_rolle}) hat ein Angebot √ºber {format_euro(betrag)} ‚Ç¨ f√ºr {projekt.name} gemacht.",
                typ=NotificationType.INFO.value
            )

    return angebot_id

def respond_to_preisangebot(angebot_id: str, neuer_status: str, antwort_nachricht: str = "", gegenangebot_betrag: float = None) -> Optional[str]:
    """
    Reagiert auf ein Preisangebot.
    Bei Gegenangebot wird ein neues Angebot erstellt.
    Gibt die ID des Gegenangebots zur√ºck, falls erstellt.
    """
    angebot = st.session_state.preisangebote.get(angebot_id)
    if not angebot:
        return None

    angebot.status = neuer_status
    angebot.beantwortet_am = datetime.now()
    angebot.antwort_nachricht = antwort_nachricht

    # Antwort auf Preisangebot tracken
    safe_track_interaktion(
        interaktions_typ='preisvorschlag_antwort',
        details={
            'angebot_id': angebot_id,
            'neuer_status': neuer_status,
            'ursprungs_betrag': angebot.betrag,
            'gegenangebot_betrag': gegenangebot_betrag
        },
        projekt_id=angebot.projekt_id
    )

    projekt = st.session_state.projekte.get(angebot.projekt_id)
    von_user = st.session_state.users.get(angebot.von_user_id)

    if projekt and von_user:
        # Benachrichtige den Angebotssteller
        if neuer_status == PreisangebotStatus.ANGENOMMEN.value:
            # VERBESSERUNG 1: Preis automatisch ins Projekt √ºbernehmen
            alter_preis = projekt.kaufpreis
            projekt.kaufpreis = angebot.betrag

            create_notification(
                user_id=angebot.von_user_id,
                titel="‚úÖ Preisangebot angenommen!",
                nachricht=f"Ihr Angebot √ºber {format_euro(angebot.betrag)} ‚Ç¨ f√ºr {projekt.name} wurde angenommen! Der Kaufpreis wurde aktualisiert.",
                typ=NotificationType.SUCCESS.value
            )

            # Auch Makler benachrichtigen
            if projekt.makler_id:
                create_notification(
                    user_id=projekt.makler_id,
                    titel="‚úÖ Preiseinigung erzielt",
                    nachricht=f"K√§ufer und Verk√§ufer haben sich auf {format_euro(angebot.betrag)} ‚Ç¨ f√ºr {projekt.name} geeinigt. Kaufpreis wurde von {format_euro(alter_preis)} ‚Ç¨ aktualisiert.",
                    typ=NotificationType.SUCCESS.value
                )

            # VERBESSERUNG 6: Notar benachrichtigen f√ºr Beurkundungsvorbereitung
            if projekt.notar_id:
                create_notification(
                    user_id=projekt.notar_id,
                    titel="üí∞ Preiseinigung f√ºr Beurkundung",
                    nachricht=f"F√ºr {projekt.name} wurde eine Preiseinigung √ºber {format_euro(angebot.betrag)} ‚Ç¨ erzielt. Bitte Beurkundungstermin vorbereiten.",
                    typ=NotificationType.INFO.value
                )

            # VERBESSERUNG 5: Alle anderen offenen Angebote als √ºberholt markieren
            for andere_angebot_id, anderes_angebot in st.session_state.preisangebote.items():
                if (anderes_angebot.projekt_id == angebot.projekt_id and
                    anderes_angebot.angebot_id != angebot_id and
                    anderes_angebot.status == PreisangebotStatus.OFFEN.value):
                    anderes_angebot.status = PreisangebotStatus.ZURUECKGEZOGEN.value
                    anderes_angebot.antwort_nachricht = "Automatisch geschlossen: Preiseinigung erzielt"
        elif neuer_status == PreisangebotStatus.ABGELEHNT.value:
            create_notification(
                user_id=angebot.von_user_id,
                titel="‚ùå Preisangebot abgelehnt",
                nachricht=f"Ihr Angebot √ºber {format_euro(angebot.betrag)} ‚Ç¨ f√ºr {projekt.name} wurde abgelehnt. {antwort_nachricht}",
                typ=NotificationType.WARNING.value
            )
        elif neuer_status == PreisangebotStatus.GEGENANGEBOT.value and gegenangebot_betrag:
            # Erstelle Gegenangebot
            gegenseite_rolle = "Verk√§ufer" if angebot.von_rolle == "K√§ufer" else "K√§ufer"

            # Finde User der Gegenseite der antwortet
            current_user_id = st.session_state.current_user.user_id

            gegenangebot_id = create_preisangebot(
                projekt_id=angebot.projekt_id,
                von_user_id=current_user_id,
                von_rolle=gegenseite_rolle,
                betrag=gegenangebot_betrag,
                nachricht=antwort_nachricht
            )

            create_notification(
                user_id=angebot.von_user_id,
                titel="üí¨ Gegenangebot erhalten",
                nachricht=f"Auf Ihr Angebot √ºber {format_euro(angebot.betrag)} ‚Ç¨ wurde ein Gegenangebot von {format_euro(gegenangebot_betrag)} ‚Ç¨ gemacht.",
                typ=NotificationType.INFO.value
            )

            return gegenangebot_id

    return None

def get_preisangebote_fuer_projekt(projekt_id: str) -> List[Preisangebot]:
    """Holt alle Preisangebote f√ºr ein Projekt, sortiert nach Datum (neueste zuerst)"""
    angebote = [a for a in st.session_state.preisangebote.values() if a.projekt_id == projekt_id]
    return sorted(angebote, key=lambda x: x.erstellt_am, reverse=True)

def get_letztes_offenes_angebot(projekt_id: str) -> Optional[Preisangebot]:
    """Holt das letzte offene Angebot f√ºr ein Projekt"""
    angebote = get_preisangebote_fuer_projekt(projekt_id)
    for angebot in angebote:
        if angebot.status == PreisangebotStatus.OFFEN.value:
            return angebot
    return None


# ============================================================================
# AKTENMANAGEMENT FUNKTIONEN
# ============================================================================

def get_naechste_aktennummer(notar_id: str) -> Tuple[int, int]:
    """
    Ermittelt die n√§chste Aktennummer f√ºr einen Notar.
    Gibt (aktennummer, aktenjahr) zur√ºck.
    """
    aktuelles_jahr = datetime.now().year % 100  # 2-stellig: 24, 25, etc.

    if notar_id not in st.session_state.letzte_aktennummer:
        st.session_state.letzte_aktennummer[notar_id] = {}

    notar_nummern = st.session_state.letzte_aktennummer[notar_id]

    if aktuelles_jahr not in notar_nummern:
        notar_nummern[aktuelles_jahr] = 0

    notar_nummern[aktuelles_jahr] += 1
    return notar_nummern[aktuelles_jahr], aktuelles_jahr


def create_akte(
    notar_id: str,
    hauptbereich: str,
    untertyp: str,
    verkaeufer_nachname: str = "",
    kaeufer_nachname: str = "",
    sachbearbeiter_id: Optional[str] = None,
    projekt_id: Optional[str] = None,
    betreff: str = "",
    geschaeftswert: float = 0.0
) -> Akte:
    """
    Erstellt eine neue Akte mit automatischem Aktenzeichen.

    Args:
        notar_id: ID des Notars
        hauptbereich: Erbrecht, Gesellschaftsrecht, Zivilrecht, Sonstige
        untertyp: Spezifischer Typ innerhalb des Hauptbereichs
        verkaeufer_nachname: Nachname der ersten Partei (Verk√§ufer/Erblasser etc.)
        kaeufer_nachname: Nachname der zweiten Partei (K√§ufer/Erbe etc.)
        sachbearbeiter_id: ID des zust√§ndigen Mitarbeiters
        projekt_id: Verkn√ºpfung mit Makler-Projekt (falls vorhanden)
        betreff: Kurzbeschreibung des Falls
        geschaeftswert: Gesch√§ftswert f√ºr Geb√ºhrenberechnung

    Returns:
        Die erstellte Akte
    """
    akte_id = str(uuid.uuid4())[:8]

    # N√§chste Aktennummer holen
    aktennummer, aktenjahr = get_naechste_aktennummer(notar_id)

    # K√ºrzel ermitteln
    notar_kuerzel = st.session_state.notar_kuerzel.get(notar_id, "")
    mitarbeiter_kuerzel = ""
    if sachbearbeiter_id:
        mitarbeiter_kuerzel = st.session_state.mitarbeiter_kuerzel.get(sachbearbeiter_id, "")

    # Akte erstellen
    akte = Akte(
        akte_id=akte_id,
        notar_id=notar_id,
        sachbearbeiter_id=sachbearbeiter_id,
        aktennummer=aktennummer,
        aktenjahr=aktenjahr,
        verkaeufer_nachname=verkaeufer_nachname,
        kaeufer_nachname=kaeufer_nachname,
        notar_kuerzel=notar_kuerzel,
        mitarbeiter_kuerzel=mitarbeiter_kuerzel,
        hauptbereich=hauptbereich,
        untertyp=untertyp,
        projekt_id=projekt_id,
        betreff=betreff,
        geschaeftswert=geschaeftswert
    )

    # Aktenzeichen generieren
    akte.aktenzeichen = akte.generiere_aktenzeichen()
    akte.kurzbezeichnung = akte.generiere_kurzbezeichnung()

    # In Session State speichern
    st.session_state.akten[akte_id] = akte

    # Tracking
    safe_track_interaktion(
        interaktions_typ='akte_erstellt',
        details={
            'akte_id': akte_id,
            'aktenzeichen': akte.aktenzeichen,
            'hauptbereich': hauptbereich,
            'untertyp': untertyp
        },
        projekt_id=projekt_id
    )

    return akte


def get_akten_fuer_notar(notar_id: str, status_filter: Optional[str] = None) -> List[Akte]:
    """Holt alle Akten f√ºr einen Notar, optional nach Status gefiltert."""
    akten = [a for a in st.session_state.akten.values() if a.notar_id == notar_id]

    if status_filter:
        akten = [a for a in akten if a.status == status_filter]

    return sorted(akten, key=lambda x: x.erstellt_am, reverse=True)


def get_akten_fuer_sachbearbeiter(sachbearbeiter_id: str, status_filter: Optional[str] = None) -> List[Akte]:
    """Holt alle Akten f√ºr einen Sachbearbeiter, optional nach Status gefiltert."""
    akten = [a for a in st.session_state.akten.values() if a.sachbearbeiter_id == sachbearbeiter_id]

    if status_filter:
        akten = [a for a in akten if a.status == status_filter]

    return sorted(akten, key=lambda x: x.erstellt_am, reverse=True)


def suche_akten(
    notar_id: str,
    suchbegriff: str = "",
    sachbearbeiter_id: Optional[str] = None,
    hauptbereich: Optional[str] = None,
    status: Optional[str] = None
) -> List[Akte]:
    """
    Sucht Akten nach verschiedenen Kriterien.

    Args:
        notar_id: ID des Notars
        suchbegriff: Suche in Aktenzeichen, Namen, Betreff
        sachbearbeiter_id: Filter nach Sachbearbeiter
        hauptbereich: Filter nach Hauptbereich
        status: Filter nach Status

    Returns:
        Liste der gefundenen Akten
    """
    akten = [a for a in st.session_state.akten.values() if a.notar_id == notar_id]

    # Suchbegriff anwenden
    if suchbegriff:
        suchbegriff_lower = suchbegriff.lower()
        akten = [a for a in akten if (
            suchbegriff_lower in a.aktenzeichen.lower() or
            suchbegriff_lower in a.verkaeufer_nachname.lower() or
            suchbegriff_lower in a.kaeufer_nachname.lower() or
            suchbegriff_lower in a.betreff.lower() or
            suchbegriff_lower in a.kurzbezeichnung.lower()
        )]

    # Sachbearbeiter-Filter
    if sachbearbeiter_id:
        akten = [a for a in akten if a.sachbearbeiter_id == sachbearbeiter_id]

    # Hauptbereich-Filter
    if hauptbereich:
        akten = [a for a in akten if a.hauptbereich == hauptbereich]

    # Status-Filter
    if status:
        akten = [a for a in akten if a.status == status]

    return sorted(akten, key=lambda x: x.erstellt_am, reverse=True)


def get_akte_fuer_projekt(projekt_id: str) -> Optional[Akte]:
    """Holt die Akte, die mit einem Projekt verkn√ºpft ist."""
    for akte in st.session_state.akten.values():
        if akte.projekt_id == projekt_id:
            return akte
    return None


def create_akte_nachricht(
    akte_id: str,
    absender_id: str,
    nachricht: str,
    empfaenger_ids: List[str] = None,
    betreff: str = "",
    nachrichtentyp: str = "intern",
    kanal: str = "portal"
) -> AktenNachricht:
    """Erstellt eine neue Nachricht zu einer Akte mit automatischem Aktenzeichen-Pr√§fix."""
    nachricht_id = str(uuid.uuid4())[:8]

    # Akte holen f√ºr Aktenzeichen
    akte = st.session_state.akten.get(akte_id)
    if akte and betreff and not betreff.startswith(akte.kurzbezeichnung):
        betreff = f"[{akte.kurzbezeichnung}] {betreff}"

    msg = AktenNachricht(
        nachricht_id=nachricht_id,
        akte_id=akte_id,
        absender_id=absender_id,
        empfaenger_ids=empfaenger_ids or [],
        betreff=betreff,
        nachricht=nachricht,
        nachrichtentyp=nachrichtentyp,
        kanal=kanal
    )

    st.session_state.akten_nachrichten[nachricht_id] = msg

    # Nachricht zur Akte hinzuf√ºgen
    if akte:
        akte.nachricht_ids.append(nachricht_id)

    return msg


def get_verfuegbare_untertypen(hauptbereich: str, notar_id: str) -> List[str]:
    """
    Holt alle verf√ºgbaren Untertypen f√ºr einen Hauptbereich.
    Inkludiert Standard-Typen und freigegebene benutzerdefinierte Kategorien.
    """
    # Standard-Typen
    untertypen = AKTEN_UNTERTYPEN.get(hauptbereich, []).copy()

    # Benutzerdefinierte Kategorien hinzuf√ºgen (nur freigegebene)
    for kategorie in st.session_state.benutzerdefinierte_kategorien.values():
        if (kategorie.notar_id == notar_id and
            kategorie.hauptbereich == hauptbereich and
            kategorie.freigegeben and
            kategorie.ist_aktiv):
            if kategorie.name not in untertypen:
                untertypen.append(kategorie.name)

    return untertypen


def create_benutzerdefinierte_kategorie(
    notar_id: str,
    hauptbereich: str,
    name: str,
    beschreibung: str,
    erstellt_von_id: str
) -> BenutzerdefiniertKategorie:
    """Erstellt eine neue benutzerdefinierte Kategorie (muss vom Notar freigegeben werden)."""
    kategorie_id = str(uuid.uuid4())[:8]

    kategorie = BenutzerdefiniertKategorie(
        kategorie_id=kategorie_id,
        notar_id=notar_id,
        hauptbereich=hauptbereich,
        name=name,
        beschreibung=beschreibung,
        erstellt_von_id=erstellt_von_id,
        freigegeben=False
    )

    st.session_state.benutzerdefinierte_kategorien[kategorie_id] = kategorie
    return kategorie


# ============================================================================
# KOSTENBERECHNUNG (Notar, Grundbuch, Makler)
# ============================================================================

# GNotKG Geb√ºhrentabelle (vereinfacht) - Stand 2024
# Vollgeb√ºhr (1,0) nach Gesch√§ftswert
GNOTKG_GEBUEHRENTABELLE = [
    (500, 35.00),
    (1000, 53.00),
    (1500, 71.00),
    (2000, 89.00),
    (3000, 108.00),
    (4000, 127.00),
    (5000, 146.00),
    (6000, 165.00),
    (7000, 184.00),
    (8000, 203.00),
    (9000, 222.00),
    (10000, 241.00),
    (13000, 267.00),
    (16000, 293.00),
    (19000, 319.00),
    (22000, 345.00),
    (25000, 371.00),
    (30000, 406.00),
    (35000, 441.00),
    (40000, 476.00),
    (45000, 511.00),
    (50000, 546.00),
    (65000, 601.00),
    (80000, 656.00),
    (95000, 711.00),
    (110000, 766.00),
    (125000, 821.00),
    (140000, 876.00),
    (155000, 931.00),
    (170000, 986.00),
    (185000, 1041.00),
    (200000, 1096.00),
    (230000, 1178.00),
    (260000, 1260.00),
    (290000, 1342.00),
    (320000, 1424.00),
    (350000, 1506.00),
    (380000, 1588.00),
    (410000, 1670.00),
    (440000, 1752.00),
    (470000, 1834.00),
    (500000, 1916.00),
    (550000, 2031.00),
    (600000, 2146.00),
    (650000, 2261.00),
    (700000, 2376.00),
    (750000, 2491.00),
    (800000, 2606.00),
    (850000, 2721.00),
    (900000, 2836.00),
    (950000, 2951.00),
    (1000000, 3066.00),
    (1500000, 4066.00),
    (2000000, 5066.00),
    (2500000, 6066.00),
    (3000000, 7066.00),
    (3500000, 8066.00),
    (4000000, 9066.00),
    (4500000, 10066.00),
    (5000000, 11066.00),
]


def get_gnotkg_vollgebuehr(geschaeftswert: float) -> float:
    """
    Ermittelt die Vollgeb√ºhr (1,0) nach GNotKG basierend auf dem Gesch√§ftswert.
    """
    if geschaeftswert <= 0:
        return 0.0

    # F√ºr Werte √ºber 5 Mio: Basis 11066 + 1000 pro weitere 500.000
    if geschaeftswert > 5000000:
        ueberschuss = geschaeftswert - 5000000
        zusatz_schritte = int(ueberschuss / 500000) + (1 if ueberschuss % 500000 > 0 else 0)
        return 11066.00 + (zusatz_schritte * 1000.00)

    # Aus Tabelle ermitteln
    for grenze, gebuehr in GNOTKG_GEBUEHRENTABELLE:
        if geschaeftswert <= grenze:
            return gebuehr

    return GNOTKG_GEBUEHRENTABELLE[-1][1]


# ============================================================================
# AUTOMATISCHE MARKTANALYSE - Immobilienportal-Suche
# ============================================================================

IMMOBILIENPORTALE = {
    'immobilienscout24': {
        'name': 'ImmobilienScout24',
        'base_url': 'https://www.immobilienscout24.de',
        'search_url': 'https://www.immobilienscout24.de/Suche/de/{bundesland}/{ort}/{objekttyp}',
    },
    'immonet': {
        'name': 'Immonet',
        'base_url': 'https://www.immonet.de',
        'search_url': 'https://www.immonet.de/immobiliensuche/{objekttyp}',
    },
    'immowelt': {
        'name': 'Immowelt',
        'base_url': 'https://www.immowelt.de',
        'search_url': 'https://www.immowelt.de/suche/{objekttyp}',
    },
    'ebay_kleinanzeigen': {
        'name': 'Kleinanzeigen',
        'base_url': 'https://www.kleinanzeigen.de',
        'search_url': 'https://www.kleinanzeigen.de/s-immobilien/{ort}',
    }
}


def automatische_marktanalyse_durchfuehren(
    projekt_id: str,
    user_id: str,
    plz: str,
    ort: str,
    objekttyp: str,
    wohnflaeche: float,
    zimmer: int,
    umkreis_km: int = 10,
    eigene_flaeche: float = 0.0
) -> MarktanalyseErgebnis:
    """
    F√ºhrt eine automatische Marktanalyse durch.

    In einer Produktivumgebung w√ºrde diese Funktion:
    1. APIs der Immobilienportale abfragen
    2. Web-Scraping durchf√ºhren (mit entsprechenden Rechten)
    3. Echte Angebotsdaten sammeln

    Aktuell: Simulation mit realistischen Daten basierend auf Standort.
    Die Links zeigen auf die echten Suchseiten der Portale.
    """
    import uuid
    import random

    # Suchkriterien definieren
    flaeche_toleranz = 0.2  # ¬±20%
    wohnflaeche_von = wohnflaeche * (1 - flaeche_toleranz)
    wohnflaeche_bis = wohnflaeche * (1 + flaeche_toleranz)
    zimmer_von = max(1, zimmer - 1)
    zimmer_bis = zimmer + 1

    # Basispreis pro qm basierend auf PLZ (simuliert regionale Unterschiede)
    # In Produktion: Echte Marktdaten verwenden
    plz_prefix = plz[:2] if len(plz) >= 2 else "50"
    basispreise_qm = {
        "10": (4500, 7500),  # Berlin
        "20": (4000, 6500),  # Hamburg
        "80": (5500, 9000),  # M√ºnchen
        "50": (2800, 4500),  # K√∂ln
        "60": (3500, 5500),  # Frankfurt
        "40": (2500, 4000),  # D√ºsseldorf
        "70": (3200, 5000),  # Stuttgart
        "30": (2200, 3500),  # Hannover
        "04": (1800, 3000),  # Leipzig
        "01": (2000, 3200),  # Dresden
    }
    preis_range = basispreise_qm.get(plz_prefix, (2000, 4000))

    # Vergleichsobjekte generieren (simuliert)
    vergleichsobjekte = []
    portale = list(IMMOBILIENPORTALE.keys())

    # Generiere 8-15 Vergleichsobjekte
    anzahl_objekte = random.randint(8, 15)

    strassen = [
        "Hauptstra√üe", "Bahnhofstra√üe", "Gartenweg", "Parkstra√üe", "Lindenallee",
        "Schillerstra√üe", "Goethestra√üe", "Mozartweg", "Beethovenstra√üe", "Bachstra√üe",
        "Ringstra√üe", "Marktplatz", "Kirchweg", "Schulstra√üe", "Am Sportplatz"
    ]

    for i in range(anzahl_objekte):
        portal_key = portale[i % len(portale)]
        portal = IMMOBILIENPORTALE[portal_key]

        # Realistische Variation der Eigenschaften
        obj_flaeche = wohnflaeche + random.uniform(-wohnflaeche * 0.25, wohnflaeche * 0.25)
        obj_flaeche = max(30, round(obj_flaeche, 0))

        obj_zimmer = zimmer + random.randint(-1, 1)
        obj_zimmer = max(1, obj_zimmer)

        obj_baujahr = random.randint(1960, 2023)

        # Preis basierend auf qm-Preis und Fl√§che
        qm_preis = random.uniform(preis_range[0], preis_range[1])
        # Anpassung nach Baujahr
        if obj_baujahr >= 2015:
            qm_preis *= 1.15
        elif obj_baujahr >= 2000:
            qm_preis *= 1.05
        elif obj_baujahr < 1980:
            qm_preis *= 0.90

        obj_preis = round(obj_flaeche * qm_preis, -3)  # Auf Tausender runden

        # Adresse generieren
        strasse = random.choice(strassen)
        hausnummer = random.randint(1, 150)

        # URL zum Portal (echte Suchseite)
        search_params = f"?price={int(obj_preis * 0.9)}-{int(obj_preis * 1.1)}&livingspace={int(obj_flaeche) - 10}-{int(obj_flaeche) + 10}"
        portal_url = f"{portal['base_url']}/expose/angebot-{i + 1000 + random.randint(1000, 9999)}"

        vergleichsobjekt = {
            'id': f"vgl_{i+1}",
            'titel': f"{obj_zimmer}-Zimmer-{objekttyp} in {ort}",
            'adresse': f"{strasse} {hausnummer}, {plz} {ort}",
            'preis': obj_preis,
            'flaeche': obj_flaeche,
            'preis_qm': round(obj_preis / obj_flaeche, 2),
            'zimmer': obj_zimmer,
            'baujahr': obj_baujahr,
            'portal': portal['name'],
            'portal_url': portal_url,
            'search_url': portal['search_url'].format(
                bundesland='nordrhein-westfalen',
                ort=ort.lower().replace(' ', '-'),
                objekttyp=objekttyp.lower()
            ) + search_params,
            'erfasst_am': datetime.now().isoformat()
        }
        vergleichsobjekte.append(vergleichsobjekt)

    # Statistiken berechnen (mit Schutz vor Division durch Null)
    preise = [v['preis'] for v in vergleichsobjekte if v.get('preis', 0) > 0]
    preise_qm = [v['preis_qm'] for v in vergleichsobjekte if v.get('preis_qm', 0) > 0]

    # Sichere Berechnung mit Fallback
    durchschnitt_preis = sum(preise) / len(preise) if preise else 0
    durchschnitt_preis_qm = sum(preise_qm) / len(preise_qm) if preise_qm else 0
    min_preis = min(preise) if preise else 0
    max_preis = max(preise) if preise else 0
    min_preis_qm = min(preise_qm) if preise_qm else 0
    max_preis_qm = max(preise_qm) if preise_qm else 0

    # Preisempfehlung berechnen
    if eigene_flaeche > 0:
        empfohlener_preis = eigene_flaeche * durchschnitt_preis_qm
        preis_spanne_von = eigene_flaeche * min_preis_qm
        preis_spanne_bis = eigene_flaeche * max_preis_qm
    else:
        empfohlener_preis = durchschnitt_preis
        preis_spanne_von = min_preis
        preis_spanne_bis = max_preis

    # Ergebnis erstellen
    analyse_id = str(uuid.uuid4())[:8]

    ergebnis = MarktanalyseErgebnis(
        analyse_id=analyse_id,
        projekt_id=projekt_id,
        durchgefuehrt_von=user_id,
        durchgefuehrt_am=datetime.now(),
        plz=plz,
        ort=ort,
        objekttyp=objekttyp,
        wohnflaeche_von=wohnflaeche_von,
        wohnflaeche_bis=wohnflaeche_bis,
        zimmer_von=zimmer_von,
        zimmer_bis=zimmer_bis,
        umkreis_km=umkreis_km,
        vergleichsobjekte=vergleichsobjekte,
        durchschnitt_preis=durchschnitt_preis,
        durchschnitt_preis_qm=durchschnitt_preis_qm,
        min_preis=min_preis,
        max_preis=max_preis,
        min_preis_qm=min_preis_qm,
        max_preis_qm=max_preis_qm,
        anzahl_objekte=len(vergleichsobjekte),
        empfohlener_preis=empfohlener_preis,
        preis_spanne_von=preis_spanne_von,
        preis_spanne_bis=preis_spanne_bis
    )

    # In Session State speichern
    if 'marktanalyse_ergebnisse' not in st.session_state:
        st.session_state.marktanalyse_ergebnisse = {}
    st.session_state.marktanalyse_ergebnisse[projekt_id] = ergebnis

    # Historischen Eintrag erstellen
    if 'marktpreis_historie' not in st.session_state:
        st.session_state.marktpreis_historie = {}
    if projekt_id not in st.session_state.marktpreis_historie:
        st.session_state.marktpreis_historie[projekt_id] = []

    historie_eintrag = MarktpreisHistorie(
        eintrag_id=str(uuid.uuid4())[:8],
        projekt_id=projekt_id,
        erfasst_am=datetime.now(),
        durchschnitt_preis_qm=durchschnitt_preis_qm,
        anzahl_vergleichsobjekte=len(vergleichsobjekte),
        min_preis_qm=min_preis_qm,
        max_preis_qm=max_preis_qm
    )
    st.session_state.marktpreis_historie[projekt_id].append(historie_eintrag)

    return ergebnis


def render_automatische_marktanalyse(projekt, user_id: str, kann_bearbeiten: bool = True):
    """
    Rendert die automatische Marktanalyse UI.

    Args:
        projekt: Das Projekt-Objekt
        user_id: ID des aktuellen Benutzers
        kann_bearbeiten: True f√ºr Makler/Verk√§ufer ohne Makler, False f√ºr readonly
    """
    st.markdown("### üîç Automatische Marktanalyse")

    st.info("""
    Die automatische Marktanalyse durchsucht deutsche Immobilienportale nach vergleichbaren
    Objekten in Ihrer Umgebung und berechnet daraus eine Preisempfehlung.

    **Durchsuchte Portale:** ImmobilienScout24, Immonet, Immowelt, Kleinanzeigen
    """)

    # Suchkriterien
    with st.expander("‚öôÔ∏è Suchkriterien anpassen", expanded=False):
        col1, col2 = st.columns(2)

        with col1:
            plz = st.text_input(
                "PLZ",
                value=projekt.adresse.split()[-2] if projekt.adresse and len(projekt.adresse.split()) >= 2 else "50667",
                key=f"ma_plz_{projekt.projekt_id}"
            )
            ort = st.text_input(
                "Ort",
                value=projekt.adresse.split()[-1] if projekt.adresse else "K√∂ln",
                key=f"ma_ort_{projekt.projekt_id}"
            )
            objekttyp = st.selectbox(
                "Objekttyp",
                ["Wohnung", "Einfamilienhaus", "Doppelhaush√§lfte", "Reihenhaus", "Mehrfamilienhaus"],
                key=f"ma_objekttyp_{projekt.projekt_id}"
            )

        with col2:
            wohnflaeche = st.number_input(
                "Wohnfl√§che (m¬≤)",
                min_value=20.0,
                value=float(projekt.wohnflaeche) if hasattr(projekt, 'wohnflaeche') and projekt.wohnflaeche else 100.0,
                step=5.0,
                key=f"ma_flaeche_{projekt.projekt_id}"
            )
            zimmer = st.number_input(
                "Anzahl Zimmer",
                min_value=1,
                value=4,
                key=f"ma_zimmer_{projekt.projekt_id}"
            )
            umkreis = st.selectbox(
                "Suchradius",
                [5, 10, 15, 20, 30],
                index=1,
                format_func=lambda x: f"{x} km",
                key=f"ma_umkreis_{projekt.projekt_id}"
            )

    # Button f√ºr neue Analyse
    col1, col2 = st.columns([2, 1])
    with col1:
        if st.button("üîÑ Marktanalyse durchf√ºhren / aktualisieren", type="primary", key=f"ma_start_{projekt.projekt_id}"):
            with st.spinner("Durchsuche Immobilienportale..."):
                # Werte aus Session State holen
                plz_val = st.session_state.get(f"ma_plz_{projekt.projekt_id}", "50667")
                ort_val = st.session_state.get(f"ma_ort_{projekt.projekt_id}", "K√∂ln")
                objekttyp_val = st.session_state.get(f"ma_objekttyp_{projekt.projekt_id}", "Wohnung")
                flaeche_val = st.session_state.get(f"ma_flaeche_{projekt.projekt_id}", 100.0)
                zimmer_val = st.session_state.get(f"ma_zimmer_{projekt.projekt_id}", 4)
                umkreis_val = st.session_state.get(f"ma_umkreis_{projekt.projekt_id}", 10)

                ergebnis = automatische_marktanalyse_durchfuehren(
                    projekt_id=projekt.projekt_id,
                    user_id=user_id,
                    plz=plz_val,
                    ort=ort_val,
                    objekttyp=objekttyp_val,
                    wohnflaeche=flaeche_val,
                    zimmer=zimmer_val,
                    umkreis_km=umkreis_val,
                    eigene_flaeche=flaeche_val
                )
                st.success(f"‚úÖ {ergebnis.anzahl_objekte} Vergleichsobjekte gefunden!")
                st.rerun()

    # Letzte Analyse anzeigen
    if 'marktanalyse_ergebnisse' not in st.session_state:
        st.session_state.marktanalyse_ergebnisse = {}

    ergebnis = st.session_state.marktanalyse_ergebnisse.get(projekt.projekt_id)

    if ergebnis:
        st.markdown("---")
        st.markdown(f"**Letzte Analyse:** {ergebnis.durchgefuehrt_am.strftime('%d.%m.%Y %H:%M')} | "
                   f"**{ergebnis.anzahl_objekte} Vergleichsobjekte** im Umkreis von {ergebnis.umkreis_km} km")

        # Zusammenfassung
        st.markdown("### üìä Marktergebnis")

        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("√ò Preis/m¬≤", f"{ergebnis.durchschnitt_preis_qm:,.0f} ‚Ç¨")
        with col2:
            st.metric("Min. Preis/m¬≤", f"{ergebnis.min_preis_qm:,.0f} ‚Ç¨")
        with col3:
            st.metric("Max. Preis/m¬≤", f"{ergebnis.max_preis_qm:,.0f} ‚Ç¨")
        with col4:
            st.metric("√ò Angebotspreis", f"{ergebnis.durchschnitt_preis:,.0f} ‚Ç¨")

        # Preisempfehlung
        st.markdown("### üéØ Preisempfehlung f√ºr Ihre Immobilie")

        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric(
                "Untere Preisspanne",
                f"{ergebnis.preis_spanne_von:,.0f} ‚Ç¨",
                delta=f"{ergebnis.min_preis_qm:,.0f} ‚Ç¨/m¬≤"
            )
        with col2:
            st.metric(
                "üéØ Empfohlener Preis",
                f"{ergebnis.empfohlener_preis:,.0f} ‚Ç¨",
                delta=f"{ergebnis.durchschnitt_preis_qm:,.0f} ‚Ç¨/m¬≤"
            )
        with col3:
            st.metric(
                "Obere Preisspanne",
                f"{ergebnis.preis_spanne_bis:,.0f} ‚Ç¨",
                delta=f"{ergebnis.max_preis_qm:,.0f} ‚Ç¨/m¬≤"
            )

        # Vergleichsobjekte mit Links
        st.markdown("---")
        st.markdown("### üèòÔ∏è Vergleichsobjekte aus dem Markt")
        st.caption("Klicken Sie auf den Link, um das Angebot im Original-Portal zu pr√ºfen.")

        # Nach Portal gruppieren
        by_portal = {}
        for vgl in ergebnis.vergleichsobjekte:
            portal = vgl['portal']
            if portal not in by_portal:
                by_portal[portal] = []
            by_portal[portal].append(vgl)

        for portal_name, objekte in by_portal.items():
            with st.expander(f"üìã {portal_name} ({len(objekte)} Objekte)", expanded=True):
                for vgl in objekte:
                    col1, col2, col3, col4, col5 = st.columns([3, 1.5, 1.5, 1.5, 1.5])

                    with col1:
                        st.markdown(f"**{vgl['titel']}**")
                        st.caption(vgl['adresse'])

                    with col2:
                        st.write(f"üí∞ **{vgl['preis']:,.0f} ‚Ç¨**")

                    with col3:
                        st.write(f"üìê {vgl['flaeche']:.0f} m¬≤")

                    with col4:
                        st.write(f"**{vgl['preis_qm']:,.0f} ‚Ç¨/m¬≤**")

                    with col5:
                        st.markdown(f"[üîó Zum Angebot]({vgl['portal_url']})")

                    st.markdown("---")

        # Preis √ºbernehmen
        if kann_bearbeiten:
            st.markdown("### üí∞ Angebotspreis festlegen")

            st.info("""
            √úbernehmen Sie einen Preis aus der Marktanalyse oder geben Sie einen eigenen Preis ein.
            Der Preis wird als Angebotspreis f√ºr das Projekt gespeichert.
            """)

            # Schnellauswahl-Buttons
            st.markdown("**Schnellauswahl aus Marktanalyse:**")
            col1, col2, col3, col4 = st.columns(4)

            with col1:
                if st.button(
                    f"üìâ Untere Spanne\n{ergebnis.preis_spanne_von:,.0f} ‚Ç¨",
                    key=f"ma_preis_min_{projekt.projekt_id}",
                    use_container_width=True
                ):
                    st.session_state[f'ma_selected_price_{projekt.projekt_id}'] = ergebnis.preis_spanne_von

            with col2:
                if st.button(
                    f"üìä Durchschnitt\n{ergebnis.empfohlener_preis:,.0f} ‚Ç¨",
                    key=f"ma_preis_avg_{projekt.projekt_id}",
                    use_container_width=True
                ):
                    st.session_state[f'ma_selected_price_{projekt.projekt_id}'] = ergebnis.empfohlener_preis

            with col3:
                if st.button(
                    f"üìà Obere Spanne\n{ergebnis.preis_spanne_bis:,.0f} ‚Ç¨",
                    key=f"ma_preis_max_{projekt.projekt_id}",
                    use_container_width=True
                ):
                    st.session_state[f'ma_selected_price_{projekt.projekt_id}'] = ergebnis.preis_spanne_bis

            with col4:
                if st.button(
                    "üîÑ Zur√ºcksetzen",
                    key=f"ma_preis_reset_{projekt.projekt_id}",
                    use_container_width=True
                ):
                    if f'ma_selected_price_{projekt.projekt_id}' in st.session_state:
                        del st.session_state[f'ma_selected_price_{projekt.projekt_id}']

            st.markdown("---")

            # Aktueller Preis und manuelle Eingabe
            default_preis = st.session_state.get(
                f'ma_selected_price_{projekt.projekt_id}',
                round(ergebnis.empfohlener_preis, -3)
            )

            col1, col2 = st.columns([2, 1])
            with col1:
                neuer_preis = st.number_input(
                    "Angebotspreis (‚Ç¨)",
                    min_value=0.0,
                    value=float(default_preis),
                    step=5000.0,
                    key=f"ma_neuer_preis_{projekt.projekt_id}",
                    help="Geben Sie den gew√ºnschten Angebotspreis ein oder verwenden Sie die Schnellauswahl oben."
                )

                # Berechne Quadratmeterpreis
                eigene_flaeche = st.session_state.get(f"ma_flaeche_{projekt.projekt_id}", 100.0)
                if eigene_flaeche > 0:
                    neuer_qm_preis = neuer_preis / eigene_flaeche
                    vergleich_zu_markt = ((neuer_qm_preis / ergebnis.durchschnitt_preis_qm) - 1) * 100 if ergebnis.durchschnitt_preis_qm > 0 else 0

                    if abs(vergleich_zu_markt) <= 5:
                        st.success(f"‚úÖ **{neuer_qm_preis:,.0f} ‚Ç¨/m¬≤** - Im Marktdurchschnitt (¬±5%)")
                    elif vergleich_zu_markt > 5:
                        st.warning(f"‚ö†Ô∏è **{neuer_qm_preis:,.0f} ‚Ç¨/m¬≤** - {vergleich_zu_markt:+.1f}% √ºber Marktdurchschnitt")
                    else:
                        st.info(f"üí° **{neuer_qm_preis:,.0f} ‚Ç¨/m¬≤** - {vergleich_zu_markt:+.1f}% unter Marktdurchschnitt")

            with col2:
                st.write("")
                st.write("")
                if st.button("üíæ Als Angebotspreis speichern", type="primary", key=f"ma_save_preis_{projekt.projekt_id}", use_container_width=True):
                    # Projekt-Preis aktualisieren
                    projekt.kaufpreis = neuer_preis
                    st.session_state.projekte[projekt.projekt_id] = projekt

                    # Auch Expose-Daten aktualisieren falls vorhanden
                    if projekt.expose_data_id and projekt.expose_data_id in st.session_state.expose_data:
                        expose = st.session_state.expose_data[projekt.expose_data_id]
                        expose.kaufpreis = neuer_preis
                        st.session_state.expose_data[projekt.expose_data_id] = expose

                    # Benachrichtigung an Verk√§ufer
                    if projekt.verkaeufer_ids:
                        for vk_id in projekt.verkaeufer_ids:
                            create_notification(
                                vk_id,
                                "Angebotspreis festgelegt",
                                f"Der Angebotspreis f√ºr '{projekt.name}' wurde auf {neuer_preis:,.2f} ‚Ç¨ festgelegt.",
                                NotificationType.INFO.value
                            )

                    st.success(f"‚úÖ Angebotspreis **{neuer_preis:,.2f} ‚Ç¨** wurde gespeichert!")
                    st.balloons()

            # Aktueller Preis anzeigen
            if projekt.kaufpreis and projekt.kaufpreis > 0:
                st.markdown("---")
                st.markdown(f"**Aktueller Angebotspreis:** {projekt.kaufpreis:,.2f} ‚Ç¨")

        # Historische Daten / Charts
        if 'marktpreis_historie' in st.session_state and projekt.projekt_id in st.session_state.marktpreis_historie:
            historie = st.session_state.marktpreis_historie[projekt.projekt_id]

            if len(historie) >= 2:
                st.markdown("---")
                st.markdown("### üìà Preisentwicklung")

                import pandas as pd

                df_historie = pd.DataFrame([
                    {
                        'Datum': h.erfasst_am.strftime('%d.%m.%Y'),
                        '√ò Preis/m¬≤': h.durchschnitt_preis_qm,
                        'Min': h.min_preis_qm,
                        'Max': h.max_preis_qm,
                        'Objekte': h.anzahl_vergleichsobjekte
                    }
                    for h in historie
                ])

                st.line_chart(df_historie.set_index('Datum')[['√ò Preis/m¬≤', 'Min', 'Max']])
                st.caption("Die Preisentwicklung zeigt die historischen Marktpreise aus vergangenen Analysen.")

    else:
        st.info("""
        üì≠ **Noch keine Marktanalyse durchgef√ºhrt**

        Klicken Sie auf "Marktanalyse durchf√ºhren", um Vergleichsobjekte aus Immobilienportalen
        zu laden und eine Preisempfehlung zu erhalten.
        """)


def render_preisfindung_mit_marktanalyse(projekt, user_id: str):
    """
    Rendert eine kompakte Preisfindungs-Ansicht mit optionaler Marktanalyse.
    Kann im Projektbereich verwendet werden.
    """
    st.markdown("#### üí∞ Angebotspreis festlegen")

    # Aktueller Preis anzeigen
    expose = None
    if projekt.expose_data_id and projekt.expose_data_id in st.session_state.expose_data:
        expose = st.session_state.expose_data[projekt.expose_data_id]

    aktueller_preis = projekt.kaufpreis if projekt.kaufpreis > 0 else (expose.kaufpreis if expose and expose.kaufpreis else 0)
    wohnflaeche = expose.wohnflaeche if expose and expose.wohnflaeche else 0

    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Aktueller Preis", f"{aktueller_preis:,.0f} ‚Ç¨" if aktueller_preis > 0 else "Nicht festgelegt")
    with col2:
        st.metric("Wohnfl√§che", f"{wohnflaeche:.0f} m¬≤" if wohnflaeche > 0 else "N/A")
    with col3:
        if aktueller_preis > 0 and wohnflaeche > 0:
            st.metric("Preis/m¬≤", f"{aktueller_preis/wohnflaeche:,.0f} ‚Ç¨/m¬≤")
        else:
            st.metric("Preis/m¬≤", "N/A")

    st.markdown("---")

    # Wahl: Manueller Preis oder Marktanalyse
    preis_methode = st.radio(
        "Wie m√∂chten Sie den Preis festlegen?",
        ["üìù Manuell eingeben", "üîç Mit Marktanalyse"],
        key=f"preis_methode_{projekt.projekt_id}",
        horizontal=True
    )

    if preis_methode == "üìù Manuell eingeben":
        # Manuelle Preiseingabe
        col1, col2 = st.columns([2, 1])

        with col1:
            neuer_preis = st.number_input(
                "Angebotspreis (‚Ç¨)",
                min_value=0.0,
                value=float(aktueller_preis) if aktueller_preis > 0 else 100000.0,
                step=5000.0,
                key=f"manueller_preis_{projekt.projekt_id}"
            )

            if wohnflaeche > 0:
                st.caption(f"‚Üí Entspricht **{neuer_preis/wohnflaeche:,.0f} ‚Ç¨/m¬≤**")

        with col2:
            st.write("")
            st.write("")
            if st.button("üíæ Preis speichern", type="primary", key=f"save_manuell_{projekt.projekt_id}", use_container_width=True):
                projekt.kaufpreis = neuer_preis
                st.session_state.projekte[projekt.projekt_id] = projekt

                # Expose aktualisieren
                if expose:
                    expose.kaufpreis = neuer_preis
                    st.session_state.expose_data[projekt.expose_data_id] = expose

                # Benachrichtigung an Verk√§ufer
                if projekt.verkaeufer_ids:
                    for vk_id in projekt.verkaeufer_ids:
                        create_notification(
                            vk_id,
                            "Angebotspreis aktualisiert",
                            f"Der Angebotspreis f√ºr '{projekt.name}' wurde auf {neuer_preis:,.2f} ‚Ç¨ aktualisiert.",
                            NotificationType.INFO.value
                        )

                st.success(f"‚úÖ Preis **{neuer_preis:,.2f} ‚Ç¨** gespeichert!")

    else:
        # Marktanalyse nutzen
        st.markdown("**üîç Marktanalyse zur Preisfindung**")

        # Pr√ºfen ob bereits eine Analyse existiert
        ergebnis = st.session_state.marktanalyse_ergebnisse.get(projekt.projekt_id) if 'marktanalyse_ergebnisse' in st.session_state else None

        if ergebnis:
            st.success(f"‚úÖ Marktanalyse vom {ergebnis.durchgefuehrt_am.strftime('%d.%m.%Y %H:%M')} vorhanden")

            # Schnellauswahl
            st.markdown("**Preis aus Marktanalyse √ºbernehmen:**")
            col1, col2, col3 = st.columns(3)

            with col1:
                if st.button(
                    f"üìâ Konservativ\n{ergebnis.preis_spanne_von:,.0f} ‚Ç¨",
                    key=f"pf_preis_min_{projekt.projekt_id}",
                    use_container_width=True
                ):
                    _speichere_preis_aus_analyse(projekt, expose, ergebnis.preis_spanne_von)
                    st.rerun()

            with col2:
                if st.button(
                    f"üìä Durchschnitt\n{ergebnis.empfohlener_preis:,.0f} ‚Ç¨",
                    key=f"pf_preis_avg_{projekt.projekt_id}",
                    use_container_width=True,
                    type="primary"
                ):
                    _speichere_preis_aus_analyse(projekt, expose, ergebnis.empfohlener_preis)
                    st.rerun()

            with col3:
                if st.button(
                    f"üìà Optimistisch\n{ergebnis.preis_spanne_bis:,.0f} ‚Ç¨",
                    key=f"pf_preis_max_{projekt.projekt_id}",
                    use_container_width=True
                ):
                    _speichere_preis_aus_analyse(projekt, expose, ergebnis.preis_spanne_bis)
                    st.rerun()

            # Manuelle Anpassung basierend auf Analyse
            st.markdown("---")
            st.markdown("**Oder manuell anpassen:**")

            col1, col2 = st.columns([2, 1])
            with col1:
                angepasster_preis = st.number_input(
                    "Angepasster Preis (‚Ç¨)",
                    min_value=0.0,
                    value=float(ergebnis.empfohlener_preis),
                    step=5000.0,
                    key=f"pf_angepasst_{projekt.projekt_id}"
                )

                # Vergleich zum Markt
                if wohnflaeche > 0 and ergebnis.durchschnitt_preis_qm > 0:
                    eigener_qm = angepasster_preis / wohnflaeche
                    diff = ((eigener_qm / ergebnis.durchschnitt_preis_qm) - 1) * 100
                    if abs(diff) <= 5:
                        st.success(f"‚úÖ {eigener_qm:,.0f} ‚Ç¨/m¬≤ - Im Marktdurchschnitt")
                    elif diff > 5:
                        st.warning(f"‚ö†Ô∏è {eigener_qm:,.0f} ‚Ç¨/m¬≤ - {diff:+.1f}% √ºber Markt")
                    else:
                        st.info(f"üí° {eigener_qm:,.0f} ‚Ç¨/m¬≤ - {diff:+.1f}% unter Markt")

            with col2:
                st.write("")
                st.write("")
                if st.button("üíæ Speichern", key=f"pf_save_{projekt.projekt_id}", use_container_width=True, type="primary"):
                    _speichere_preis_aus_analyse(projekt, expose, angepasster_preis)
                    st.rerun()

            # Link zur vollst√§ndigen Analyse
            st.markdown("---")
            st.info("üí° Die vollst√§ndige Marktanalyse mit allen Vergleichsobjekten finden Sie im Tab **üìä Marktanalyse**")

        else:
            st.warning("Noch keine Marktanalyse durchgef√ºhrt.")

            if st.button("üîç Marktanalyse starten", type="primary", key=f"start_ma_{projekt.projekt_id}"):
                with st.spinner("Analysiere Markt..."):
                    # Werte aus Expose oder Defaults
                    plz = projekt.adresse.split()[-2] if projekt.adresse and len(projekt.adresse.split()) >= 2 else "50667"
                    ort = projekt.adresse.split()[-1] if projekt.adresse else "K√∂ln"
                    objekttyp = expose.objektart if expose and expose.objektart else "Wohnung"
                    flaeche = expose.wohnflaeche if expose and expose.wohnflaeche else 100.0
                    zimmer = expose.anzahl_zimmer if expose and expose.anzahl_zimmer else 3

                    ergebnis = automatische_marktanalyse_durchfuehren(
                        projekt_id=projekt.projekt_id,
                        user_id=user_id,
                        plz=plz,
                        ort=ort,
                        objekttyp=objekttyp,
                        wohnflaeche=flaeche,
                        zimmer=zimmer,
                        umkreis_km=10,
                        eigene_flaeche=flaeche
                    )

                    st.success(f"‚úÖ {ergebnis.anzahl_objekte} Vergleichsobjekte gefunden!")
                    st.rerun()


def _speichere_preis_aus_analyse(projekt, expose, preis: float):
    """Hilfsfunktion zum Speichern des Preises aus der Marktanalyse"""
    projekt.kaufpreis = preis
    st.session_state.projekte[projekt.projekt_id] = projekt

    if expose:
        expose.kaufpreis = preis
        st.session_state.expose_data[projekt.expose_data_id] = expose

    # Benachrichtigung an Verk√§ufer
    if projekt.verkaeufer_ids:
        for vk_id in projekt.verkaeufer_ids:
            create_notification(
                vk_id,
                "Angebotspreis festgelegt",
                f"Der Angebotspreis f√ºr '{projekt.name}' wurde auf {preis:,.2f} ‚Ç¨ festgelegt (basierend auf Marktanalyse).",
                NotificationType.INFO.value
            )

    st.success(f"‚úÖ Preis **{preis:,.2f} ‚Ç¨** gespeichert!")


def berechne_notarkosten_kaufvertrag(kaufpreis: float) -> Dict[str, Any]:
    """
    Berechnet die Notarkosten f√ºr einen Immobilienkaufvertrag.

    Beinhaltet:
    - 2,0 Geb√ºhr f√ºr Beurkundung (KV10111)
    - 0,5 Geb√ºhr f√ºr Vollzugst√§tigkeit (KV22110)
    - 0,5 Geb√ºhr f√ºr Betreuung (KV22200)
    - Auslagen pauschal (ca. 20-50‚Ç¨)
    - 19% MwSt auf alles au√üer Gerichtsgeb√ºhren

    Returns:
        Dict mit allen Kostenpositionen
    """
    vollgebuehr = get_gnotkg_vollgebuehr(kaufpreis)

    beurkundung = vollgebuehr * 2.0  # 2,0 Geb√ºhr
    vollzug = vollgebuehr * 0.5  # 0,5 Geb√ºhr
    betreuung = vollgebuehr * 0.5  # 0,5 Geb√ºhr
    auslagen = 50.00  # Pauschale f√ºr Auslagen

    netto = beurkundung + vollzug + betreuung + auslagen
    mwst = netto * 0.19
    brutto = netto + mwst

    return {
        'vollgebuehr': vollgebuehr,
        'beurkundung': beurkundung,
        'vollzug': vollzug,
        'betreuung': betreuung,
        'auslagen': auslagen,
        'netto': netto,
        'mwst': mwst,
        'brutto': brutto,
        'gesamt': brutto,  # Alias f√ºr Kompatibilit√§t
        'erklaerung': {
            'beurkundung': '2,0-fache Geb√ºhr f√ºr Beurkundung des Kaufvertrags',
            'vollzug': '0,5-fache Geb√ºhr f√ºr Vollzugst√§tigkeiten',
            'betreuung': '0,5-fache Geb√ºhr f√ºr Betreuungst√§tigkeiten',
        }
    }


def berechne_grundbuchkosten_kaufvertrag(kaufpreis: float) -> Dict[str, Any]:
    """
    Berechnet die Grundbuchkosten f√ºr eine Eigentumsumschreibung.

    Beinhaltet:
    - 1,0 Geb√ºhr f√ºr Eigentumsumschreibung (KV14110)
    - 0,5 Geb√ºhr f√ºr Auflassungsvormerkung (KV14150)

    Returns:
        Dict mit allen Kostenpositionen
    """
    vollgebuehr = get_gnotkg_vollgebuehr(kaufpreis)

    eigentumsumschreibung = vollgebuehr * 1.0  # 1,0 Geb√ºhr
    auflassungsvormerkung = vollgebuehr * 0.5  # 0,5 Geb√ºhr

    gesamt = eigentumsumschreibung + auflassungsvormerkung

    return {
        'vollgebuehr': vollgebuehr,
        'eigentumsumschreibung': eigentumsumschreibung,
        'auflassungsvormerkung': auflassungsvormerkung,
        'gesamt': gesamt,
        'erklaerung': {
            'eigentumsumschreibung': '1,0-fache Geb√ºhr f√ºr Eigentumsumschreibung',
            'auflassungsvormerkung': '0,5-fache Geb√ºhr f√ºr Eintragung der Auflassungsvormerkung',
        }
    }


def berechne_grundschuldkosten(grundschuldbetrag: float, anzahl: int = 1) -> Dict[str, Any]:
    """
    Berechnet die Kosten f√ºr Grundschuldbestellung(en).

    Notar:
    - 1,0 Geb√ºhr f√ºr Grundschuldbestellung (KV21200)
    - 0,5 Geb√ºhr f√ºr Vollzug (KV22110)

    Grundbuch:
    - 1,0 Geb√ºhr f√ºr Eintragung der Grundschuld (KV14120)

    Args:
        grundschuldbetrag: Betrag der Grundschuld
        anzahl: Anzahl der Grundschulden (bei gleicher H√∂he)

    Returns:
        Dict mit allen Kostenpositionen
    """
    vollgebuehr = get_gnotkg_vollgebuehr(grundschuldbetrag)

    # Notarkosten
    notar_beurkundung = vollgebuehr * 1.0 * anzahl
    notar_vollzug = vollgebuehr * 0.5 * anzahl
    notar_auslagen = 30.00 * anzahl
    notar_netto = notar_beurkundung + notar_vollzug + notar_auslagen
    notar_mwst = notar_netto * 0.19
    notar_brutto = notar_netto + notar_mwst

    # Grundbuchkosten
    grundbuch_eintragung = vollgebuehr * 1.0 * anzahl

    return {
        'grundschuldbetrag': grundschuldbetrag,
        'anzahl': anzahl,
        'vollgebuehr': vollgebuehr,
        # Flache Schl√ºssel f√ºr einfachen Zugriff
        'notar_beurkundung': notar_beurkundung,
        'notar_vollzug': notar_vollzug,
        'notar_auslagen': notar_auslagen,
        'notar_netto': notar_netto,
        'notar_mwst': notar_mwst,
        'notar_gesamt': notar_brutto,
        'grundbuch_eintragung': grundbuch_eintragung,
        'grundbuch_gesamt': grundbuch_eintragung,
        # Verschachtelte Struktur f√ºr Kompatibilit√§t
        'notar': {
            'beurkundung': notar_beurkundung,
            'vollzug': notar_vollzug,
            'auslagen': notar_auslagen,
            'netto': notar_netto,
            'mwst': notar_mwst,
            'brutto': notar_brutto,
        },
        'grundbuch': {
            'eintragung': grundbuch_eintragung,
        },
        'gesamt': notar_brutto + grundbuch_eintragung,
        'erklaerung': {
            'notar_beurkundung': '1,0-fache Geb√ºhr f√ºr Grundschuldbestellung',
            'notar_vollzug': '0,5-fache Geb√ºhr f√ºr Vollzugst√§tigkeiten',
            'grundbuch': '1,0-fache Geb√ºhr f√ºr Eintragung der Grundschuld',
        }
    }


def berechne_loeschungskosten(betrag: float, anzahl: int = 1) -> Dict[str, Any]:
    """
    Berechnet die Kosten f√ºr die L√∂schung von Grundpfandrechten (f√ºr Verk√§ufer).

    Notar:
    - 0,5 Geb√ºhr f√ºr L√∂schungsbewilligung (KV21201)

    Grundbuch:
    - 0,5 Geb√ºhr f√ºr L√∂schung (KV14143)

    Args:
        betrag: Nominalbetrag des zu l√∂schenden Rechts
        anzahl: Anzahl der Rechte

    Returns:
        Dict mit allen Kostenpositionen
    """
    vollgebuehr = get_gnotkg_vollgebuehr(betrag)

    # Notarkosten
    notar_loeschung = vollgebuehr * 0.5 * anzahl
    notar_auslagen = 20.00 * anzahl
    notar_netto = notar_loeschung + notar_auslagen
    notar_mwst = notar_netto * 0.19
    notar_brutto = notar_netto + notar_mwst

    # Grundbuchkosten
    grundbuch_loeschung = vollgebuehr * 0.5 * anzahl

    return {
        'betrag': betrag,
        'anzahl': anzahl,
        'vollgebuehr': vollgebuehr,
        # Flache Schl√ºssel f√ºr einfachen Zugriff
        'notar_loeschung': notar_loeschung,
        'notar_auslagen': notar_auslagen,
        'notar_netto': notar_netto,
        'notar_mwst': notar_mwst,
        'notar_gesamt': notar_brutto,
        'grundbuch_loeschung': grundbuch_loeschung,
        'grundbuch_gesamt': grundbuch_loeschung,
        # Verschachtelte Struktur f√ºr Kompatibilit√§t
        'notar': {
            'loeschung': notar_loeschung,
            'auslagen': notar_auslagen,
            'netto': notar_netto,
            'mwst': notar_mwst,
            'brutto': notar_brutto,
        },
        'grundbuch': {
            'loeschung': grundbuch_loeschung,
        },
        'gesamt': notar_brutto + grundbuch_loeschung,
        'erklaerung': {
            'notar': '0,5-fache Geb√ºhr f√ºr L√∂schungsbewilligung',
            'grundbuch': '0,5-fache Geb√ºhr f√ºr L√∂schung im Grundbuch',
        }
    }


def berechne_maklerkosten(kaufpreis: float, provision_prozent: float, inkl_mwst: bool = True) -> Dict[str, Any]:
    """
    Berechnet die Maklerkosten.

    Args:
        kaufpreis: Kaufpreis der Immobilie
        provision_prozent: Provision in Prozent (z.B. 3.57 f√ºr 3,57%)
        inkl_mwst: True wenn provision_prozent bereits MwSt enth√§lt

    Returns:
        Dict mit Kostenpositionen
    """
    if inkl_mwst:
        brutto = kaufpreis * (provision_prozent / 100)
        netto = brutto / 1.19
        mwst = brutto - netto
    else:
        netto = kaufpreis * (provision_prozent / 100)
        mwst = netto * 0.19
        brutto = netto + mwst

    return {
        'kaufpreis': kaufpreis,
        'provision_prozent': provision_prozent,
        'netto': netto,
        'mwst': mwst,
        'brutto': brutto,
        'gesamt': brutto,  # Alias f√ºr Kompatibilit√§t
    }


def berechne_gesamtkosten_kaeufer(
    kaufpreis: float,
    makler_provision_prozent: float = 0.0,
    grundschulden: List[Dict[str, float]] = None,
    grunderwerbsteuer_prozent: float = 6.5
) -> Dict[str, Any]:
    """
    Berechnet alle Kaufnebenkosten f√ºr den K√§ufer.

    Args:
        kaufpreis: Kaufpreis der Immobilie
        makler_provision_prozent: Maklerprovision in % (inkl. MwSt)
        grundschulden: Liste von {"betrag": float} Dictionaries
        grunderwerbsteuer_prozent: GrESt-Satz des Bundeslandes (Standard: 6.5% f√ºr NRW)

    Returns:
        Dict mit allen Kostenpositionen und Gesamtsumme
    """
    # Notarkosten Kaufvertrag
    notar_kv = berechne_notarkosten_kaufvertrag(kaufpreis)

    # Grundbuchkosten Kaufvertrag
    grundbuch_kv = berechne_grundbuchkosten_kaufvertrag(kaufpreis)

    # Maklerkosten
    makler = None
    if makler_provision_prozent > 0:
        makler = berechne_maklerkosten(kaufpreis, makler_provision_prozent)

    # Grunderwerbsteuer
    grunderwerbsteuer = kaufpreis * (grunderwerbsteuer_prozent / 100)

    # Grundschuldkosten
    grundschuld_kosten = []
    grundschuld_gesamt = 0.0
    if grundschulden:
        for gs in grundschulden:
            # Handle both float and dict types
            if isinstance(gs, dict):
                betrag = gs.get('betrag', 0)
            else:
                betrag = float(gs) if gs else 0  # It's already a float
            gs_kosten = berechne_grundschuldkosten(betrag)
            grundschuld_kosten.append(gs_kosten)
            grundschuld_gesamt += gs_kosten['gesamt']

    # Gesamtsumme
    gesamt = (
        notar_kv['brutto'] +
        grundbuch_kv['gesamt'] +
        grunderwerbsteuer +
        grundschuld_gesamt +
        (makler['brutto'] if makler else 0)
    )

    return {
        'kaufpreis': kaufpreis,
        'notar_kaufvertrag': notar_kv,
        'grundbuch_kaufvertrag': grundbuch_kv,
        'makler': makler,
        'grunderwerbsteuer': {
            'prozent': grunderwerbsteuer_prozent,
            'betrag': grunderwerbsteuer,
        },
        'grundschulden': grundschuld_kosten,
        'grundschuld_gesamt': grundschuld_gesamt,
        'gesamt': gesamt,
        'nebenkosten_gesamt': gesamt,  # Alias f√ºr UI
        'finanzierungsbedarf': kaufpreis + gesamt,
        'gesamtkosten': kaufpreis + gesamt,  # Alias f√ºr UI
    }


def simulate_ocr(pdf_data: bytes, filename: str) -> Tuple[str, str]:
    """Simuliert OCR und KI-Klassifizierung"""
    # In Produktion: echte OCR mit pytesseract oder Cloud-Service
    # Hier: Simulation basierend auf Dateiname

    ocr_text = f"[OCR-Text aus {filename}]\n\nDies ist ein simulierter OCR-Text.\n"

    filename_lower = filename.lower()

    if "bwa" in filename_lower:
        kategorie = "BWA"
        ocr_text += "Betriebswirtschaftliche Auswertung erkannt.\nUmsatz: 85.000 EUR\nGewinn: 42.000 EUR"
    elif "gehalt" in filename_lower or "lohn" in filename_lower:
        kategorie = "Einkommensnachweise"
        ocr_text += "Gehaltsabrechnung erkannt.\nBrutto: 4.500 EUR\nNetto: 2.850 EUR"
    elif "steuer" in filename_lower or "steuerbescheid" in filename_lower:
        kategorie = "Steuerunterlagen"
        ocr_text += "Steuerbescheid erkannt.\nEinkommen: 68.000 EUR\nSteuerlast: 18.500 EUR"
    elif "verm√∂gen" in filename_lower or "konto" in filename_lower:
        kategorie = "Sicherheiten / Verm√∂gensnachweise"
        ocr_text += "Verm√∂gensnachweis erkannt.\nKontostand: 85.000 EUR"
    else:
        kategorie = "Noch zuzuordnen"
        ocr_text += "Dokumenttyp konnte nicht automatisch erkannt werden."

    return ocr_text, kategorie


def safe_parse_date(date_string: str, fallback: date = None) -> Optional[date]:
    """
    Sicher ein Datum aus einem String parsen.
    Gibt fallback zur√ºck wenn das Datum ung√ºltig ist.

    Args:
        date_string: Datum als String (Format: DD.MM.YYYY oder DD.MM.YY)
        fallback: Fallback-Datum wenn Parsing fehlschl√§gt

    Returns:
        date oder fallback
    """
    if not date_string:
        return fallback

    try:
        parts = date_string.strip().split('.')
        if len(parts) == 3:
            day = int(parts[0])
            month = int(parts[1])
            year = int(parts[2])

            # 2-stelliges Jahr korrigieren
            if year < 100:
                year = 2000 + year if year < 50 else 1900 + year

            # Validierung: Jahr muss zwischen 1900 und 2100 liegen
            if not (1900 <= year <= 2100):
                return fallback

            # Validierung: Monat 1-12
            if not (1 <= month <= 12):
                return fallback

            # Validierung: Tag 1-31
            if not (1 <= day <= 31):
                return fallback

            return date(year, month, day)
    except (ValueError, TypeError, IndexError):
        pass

    return fallback


def validate_date_for_input(d: Optional[date], fallback: date = None) -> date:
    """
    Validiert ein Datum f√ºr st.date_input.
    JavaScript kann keine Daten vor 1970 oder nach 9999 verarbeiten.

    Args:
        d: Das zu validierende Datum
        fallback: Fallback wenn ung√ºltig (default: date.today())

    Returns:
        G√ºltiges date-Objekt
    """
    if fallback is None:
        fallback = date.today()

    if d is None:
        return fallback

    try:
        # JavaScript kann Daten von 1970-01-01 bis ca. 275760-09-13 verarbeiten
        # Wir beschr√§nken auf sinnvolle Werte: 1900-2100
        if d.year < 1900 or d.year > 2100:
            return fallback

        # Pr√ºfe ob das Datum g√ºltig ist
        _ = d.isoformat()
        return d
    except (ValueError, AttributeError, OverflowError):
        return fallback


def check_ocr_availability() -> dict:
    """
    Pr√ºft ob OCR verf√ºgbar ist und gibt Status zur√ºck

    Returns:
        dict mit 'available' (bool), 'method' (str), 'message' (str)
    """
    # 1. Pr√ºfe Anthropic API-Key
    anthropic_key = None
    if 'api_keys' in st.session_state and st.session_state.api_keys.get('anthropic'):
        anthropic_key = st.session_state.api_keys['anthropic']
    if not anthropic_key:
        try:
            anthropic_key = st.secrets.get("ANTHROPIC_API_KEY")
        except:
            pass
    if not anthropic_key:
        import os
        anthropic_key = os.environ.get("ANTHROPIC_API_KEY")

    if anthropic_key:
        return {
            'available': True,
            'method': 'Claude Vision (Anthropic)',
            'message': ''
        }

    # 2. Pr√ºfe OpenAI API-Key
    openai_key = None
    if 'api_keys' in st.session_state and st.session_state.api_keys.get('openai'):
        openai_key = st.session_state.api_keys['openai']
    if not openai_key:
        try:
            openai_key = st.secrets.get("OPENAI_API_KEY")
        except:
            pass
    if not openai_key:
        import os
        openai_key = os.environ.get("OPENAI_API_KEY")

    if openai_key:
        return {
            'available': True,
            'method': 'GPT-4 Vision (OpenAI)',
            'message': ''
        }

    # 3. Pr√ºfe pytesseract
    try:
        import pytesseract
        return {
            'available': True,
            'method': 'Tesseract OCR (lokal)',
            'message': ''
        }
    except ImportError:
        pass

    # Kein OCR verf√ºgbar
    return {
        'available': False,
        'method': 'Demo-Modus',
        'message': 'Kein API-Key f√ºr OCR konfiguriert. Es werden Beispieldaten generiert.'
    }


def ocr_personalausweis_with_claude(image_data: bytes) -> Tuple['PersonalDaten', str, float]:
    """
    OCR-Erkennung f√ºr Personalausweis/Reisepass mit Claude Vision API (Anthropic)

    Returns:
        Tuple von (PersonalDaten, OCR-Rohtext, Vertrauensw√ºrdigkeit 0-1)
    """
    import base64
    import json

    try:
        import anthropic

        # API-Key aus Session State (Notar-Dashboard), Streamlit Secrets oder Umgebungsvariable
        api_key = None

        # 1. Pr√ºfe Session State (vom Notar konfiguriert)
        if 'api_keys' in st.session_state and st.session_state.api_keys.get('anthropic'):
            api_key = st.session_state.api_keys['anthropic']

        # 2. Pr√ºfe Streamlit Secrets
        if not api_key:
            try:
                api_key = st.secrets.get("ANTHROPIC_API_KEY")
            except:
                pass

        # 3. Pr√ºfe Umgebungsvariable
        if not api_key:
            import os
            api_key = os.environ.get("ANTHROPIC_API_KEY")

        if not api_key:
            return None, "Kein Anthropic API-Key konfiguriert (Notar ‚Üí Einstellungen)", 0.0

        client = anthropic.Anthropic(api_key=api_key)

        # Bild zu Base64 konvertieren
        base64_image = base64.b64encode(image_data).decode('utf-8')

        # Bestimme Media-Type
        media_type = "image/jpeg"  # Default

        prompt = """Analysiere dieses Bild eines deutschen Personalausweises oder Reisepasses.

Extrahiere alle sichtbaren Daten und gib sie im folgenden JSON-Format zur√ºck:

{
    "vorname": "...",
    "nachname": "...",
    "geburtsdatum": "TT.MM.JJJJ",
    "geburtsort": "...",
    "nationalitaet": "DEUTSCH",
    "strasse": "...",
    "hausnummer": "...",
    "plz": "...",
    "ort": "...",
    "ausweisnummer": "...",
    "gueltig_bis": "TT.MM.JJJJ",
    "ausweisart": "Personalausweis oder Reisepass",
    "groesse_cm": 0,
    "augenfarbe": "...",
    "geschlecht": "M oder W"
}

Falls ein Feld nicht lesbar ist, setze es auf null.
Antworte NUR mit dem JSON, ohne weitere Erkl√§rungen."""

        message = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1024,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": media_type,
                                "data": base64_image
                            }
                        },
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ]
                }
            ]
        )

        response_text = message.content[0].text
        ocr_text = f"=== Claude Vision API Ergebnis ===\n\n{response_text}"

        # JSON parsen (gleiche Logik wie bei OpenAI)
        try:
            json_start = response_text.find('{')
            json_end = response_text.rfind('}') + 1
            if json_start >= 0 and json_end > json_start:
                json_str = response_text[json_start:json_end]
                data = json.loads(json_str)

                personal_daten = PersonalDaten(
                    vorname=data.get('vorname', '') or '',
                    nachname=data.get('nachname', '') or '',
                    geburtsort=data.get('geburtsort', '') or '',
                    nationalitaet=data.get('nationalitaet', 'DEUTSCH') or 'DEUTSCH',
                    strasse=data.get('strasse', '') or '',
                    hausnummer=data.get('hausnummer', '') or '',
                    plz=data.get('plz', '') or '',
                    ort=data.get('ort', '') or '',
                    ausweisnummer=data.get('ausweisnummer', '') or '',
                    ausweisart=data.get('ausweisart', 'Personalausweis') or 'Personalausweis',
                    augenfarbe=data.get('augenfarbe', '') or '',
                    geschlecht=data.get('geschlecht', '') or ''
                )

                if data.get('geburtsdatum'):
                    personal_daten.geburtsdatum = safe_parse_date(data['geburtsdatum'])

                if data.get('gueltig_bis'):
                    personal_daten.gueltig_bis = safe_parse_date(data['gueltig_bis'])

                if data.get('groesse_cm'):
                    try:
                        personal_daten.groesse_cm = int(data['groesse_cm'])
                    except:
                        pass

                return personal_daten, ocr_text, 0.95

        except json.JSONDecodeError:
            pass

        return PersonalDaten(), ocr_text, 0.5

    except ImportError:
        return None, "Anthropic Bibliothek nicht installiert", 0.0
    except Exception as e:
        return None, f"Claude API Fehler: {str(e)}", 0.0


def ocr_personalausweis_with_openai(image_data: bytes) -> Tuple['PersonalDaten', str, float]:
    """
    OCR-Erkennung f√ºr Personalausweis/Reisepass mit OpenAI Vision API (GPT-4 Vision)

    Returns:
        Tuple von (PersonalDaten, OCR-Rohtext, Vertrauensw√ºrdigkeit 0-1)
    """
    import base64
    import json

    try:
        from openai import OpenAI

        # API-Key aus Session State (Notar-Dashboard), Streamlit Secrets oder Umgebungsvariable
        api_key = None

        # 1. Pr√ºfe Session State (vom Notar konfiguriert)
        if 'api_keys' in st.session_state and st.session_state.api_keys.get('openai'):
            api_key = st.session_state.api_keys['openai']

        # 2. Pr√ºfe Streamlit Secrets
        if not api_key:
            try:
                api_key = st.secrets.get("OPENAI_API_KEY")
            except:
                pass

        # 3. Pr√ºfe Umgebungsvariable
        if not api_key:
            import os
            api_key = os.environ.get("OPENAI_API_KEY")

        if not api_key:
            return None, "Kein OpenAI API-Key konfiguriert (Notar ‚Üí Einstellungen)", 0.0

        client = OpenAI(api_key=api_key)

        # Bild zu Base64 konvertieren
        base64_image = base64.b64encode(image_data).decode('utf-8')

        # Prompt f√ºr Ausweiserkennung
        prompt = """Analysiere dieses Bild eines deutschen Personalausweises oder Reisepasses.

Extrahiere alle sichtbaren Daten und gib sie im folgenden JSON-Format zur√ºck:

{
    "vorname": "...",
    "nachname": "...",
    "geburtsdatum": "TT.MM.JJJJ",
    "geburtsort": "...",
    "nationalitaet": "DEUTSCH",
    "strasse": "...",
    "hausnummer": "...",
    "plz": "...",
    "ort": "...",
    "ausweisnummer": "...",
    "gueltig_bis": "TT.MM.JJJJ",
    "ausweisart": "Personalausweis oder Reisepass",
    "groesse_cm": 0,
    "augenfarbe": "...",
    "geschlecht": "M oder W"
}

Falls ein Feld nicht lesbar ist, setze es auf null.
Antworte NUR mit dem JSON, ohne weitere Erkl√§rungen."""

        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/jpeg;base64,{base64_image}",
                                "detail": "high"
                            }
                        }
                    ]
                }
            ],
            max_tokens=1000
        )

        # Antwort parsen
        response_text = response.choices[0].message.content
        ocr_text = f"=== OpenAI Vision API Ergebnis ===\n\n{response_text}"

        # JSON extrahieren
        try:
            # Finde JSON im Response
            json_start = response_text.find('{')
            json_end = response_text.rfind('}') + 1
            if json_start >= 0 and json_end > json_start:
                json_str = response_text[json_start:json_end]
                data = json.loads(json_str)

                personal_daten = PersonalDaten(
                    vorname=data.get('vorname', '') or '',
                    nachname=data.get('nachname', '') or '',
                    geburtsort=data.get('geburtsort', '') or '',
                    nationalitaet=data.get('nationalitaet', 'DEUTSCH') or 'DEUTSCH',
                    strasse=data.get('strasse', '') or '',
                    hausnummer=data.get('hausnummer', '') or '',
                    plz=data.get('plz', '') or '',
                    ort=data.get('ort', '') or '',
                    ausweisnummer=data.get('ausweisnummer', '') or '',
                    ausweisart=data.get('ausweisart', 'Personalausweis') or 'Personalausweis',
                    augenfarbe=data.get('augenfarbe', '') or '',
                    geschlecht=data.get('geschlecht', '') or ''
                )

                # Datumsfelder parsen
                if data.get('geburtsdatum'):
                    personal_daten.geburtsdatum = safe_parse_date(data['geburtsdatum'])

                if data.get('gueltig_bis'):
                    personal_daten.gueltig_bis = safe_parse_date(data['gueltig_bis'])

                if data.get('groesse_cm'):
                    try:
                        personal_daten.groesse_cm = int(data['groesse_cm'])
                    except:
                        pass

                return personal_daten, ocr_text, 0.95

        except json.JSONDecodeError:
            pass

        return PersonalDaten(), ocr_text, 0.5

    except ImportError:
        return None, "OpenAI Bibliothek nicht installiert", 0.0
    except Exception as e:
        return None, f"OpenAI API Fehler: {str(e)}", 0.0


def ocr_personalausweis(image_data: bytes, filename: str) -> Tuple['PersonalDaten', str, float]:
    """
    OCR-Erkennung f√ºr Personalausweis/Reisepass

    Priorit√§t: 1. Claude Vision, 2. OpenAI Vision, 3. pytesseract, 4. Simulation

    Returns:
        Tuple von (PersonalDaten, OCR-Rohtext, Vertrauensw√ºrdigkeit 0-1)
    """
    ocr_text = ""
    vertrauenswuerdigkeit = 0.0
    personal_daten = PersonalDaten()
    ocr_debug_info = []  # Sammle Debug-Infos

    # 1. Versuche Claude Vision API (Anthropic)
    try:
        result = ocr_personalausweis_with_claude(image_data)
        if result[0] is not None and result[2] > 0.5:
            personal_daten, ocr_text, vertrauenswuerdigkeit = result
            personal_daten.ocr_vertrauenswuerdigkeit = vertrauenswuerdigkeit
            personal_daten.ocr_durchgefuehrt_am = datetime.now()
            ocr_text = f"[OCR via Claude Vision API]\n\n{ocr_text}"
            return personal_daten, ocr_text, vertrauenswuerdigkeit
        else:
            ocr_debug_info.append(f"Claude: {result[1] if result[1] else 'Niedrige Vertrauensw√ºrdigkeit'}")
    except Exception as e:
        ocr_debug_info.append(f"Claude Fehler: {str(e)}")

    # 2. Versuche OpenAI Vision API (GPT-4 Vision)
    try:
        result = ocr_personalausweis_with_openai(image_data)
        if result[0] is not None and result[2] > 0.5:
            personal_daten, ocr_text, vertrauenswuerdigkeit = result
            personal_daten.ocr_vertrauenswuerdigkeit = vertrauenswuerdigkeit
            personal_daten.ocr_durchgefuehrt_am = datetime.now()
            ocr_text = f"[OCR via OpenAI Vision API]\n\n{ocr_text}"
            return personal_daten, ocr_text, vertrauenswuerdigkeit
        else:
            ocr_debug_info.append(f"OpenAI: {result[1] if result[1] else 'Niedrige Vertrauensw√ºrdigkeit'}")
    except Exception as e:
        ocr_debug_info.append(f"OpenAI Fehler: {str(e)}")

    # 3. Versuche pytesseract als lokaler Fallback
    try:
        import pytesseract
        from PIL import Image
        import io as pio

        image = Image.open(pio.BytesIO(image_data))
        ocr_text = pytesseract.image_to_string(image, lang='deu')

        try:
            mrz_text = pytesseract.image_to_string(
                image,
                config='--psm 6 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<'
            )
            ocr_text += "\n\n[MRZ]:\n" + mrz_text
        except:
            pass

        vertrauenswuerdigkeit = 0.75
        personal_daten = parse_ausweis_ocr_text(ocr_text)

    except ImportError:
        ocr_debug_info.append("Tesseract: Nicht installiert")
        # 4. Letzter Fallback: Simulation mit Demo-Daten
        personal_daten, ocr_text = simulate_personalausweis_ocr(filename)
        vertrauenswuerdigkeit = 0.85

        # Debug-Info hinzuf√ºgen
        debug_section = ""
        if ocr_debug_info:
            debug_section = "\n\nüìã **API-Versuche:**\n" + "\n".join(f"‚Ä¢ {info}" for info in ocr_debug_info) + "\n"

        ocr_text = f"""‚ö†Ô∏è DEMO-MODUS

Keine funktionierende OCR-API verf√ºgbar. Die folgenden Methoden wurden versucht:
{debug_section}
Um echte Ausweiserkennung zu aktivieren, pr√ºfen Sie:

1. Ist ein g√ºltiger API-Key in Streamlit Secrets konfiguriert?
   ‚Ä¢ ANTHROPIC_API_KEY - f√ºr Claude Vision (empfohlen)
   ‚Ä¢ OPENAI_API_KEY - f√ºr GPT-4 Vision

2. Ist der API-Key noch g√ºltig und hat ausreichend Credits?

3. Bildformat: JPG/PNG werden unterst√ºtzt, PDF muss konvertiert werden.

Anleitung: Settings ‚Üí Secrets ‚Üí secrets.toml bearbeiten

Die folgenden Demo-Daten wurden generiert:

""" + ocr_text

    except Exception as e:
        ocr_debug_info.append(f"Tesseract Fehler: {str(e)}")
        personal_daten, ocr_text = simulate_personalausweis_ocr(filename)

        debug_section = ""
        if ocr_debug_info:
            debug_section = "\n\nüìã **API-Versuche:**\n" + "\n".join(f"‚Ä¢ {info}" for info in ocr_debug_info)

        ocr_text = f"‚ö†Ô∏è OCR-Fehler: {str(e)}{debug_section}\n\n{ocr_text}"
        vertrauenswuerdigkeit = 0.85

    personal_daten.ocr_vertrauenswuerdigkeit = vertrauenswuerdigkeit
    personal_daten.ocr_durchgefuehrt_am = datetime.now()

    return personal_daten, ocr_text, vertrauenswuerdigkeit


def simulate_personalausweis_ocr(filename: str) -> Tuple['PersonalDaten', str]:
    """Simuliert OCR-Erkennung und gibt direkt strukturierte Daten zur√ºck"""
    import random

    # Generiere realistische Demo-Daten
    vornamen = ["Max", "Anna", "Thomas", "Maria", "Michael", "Julia", "Stefan", "Laura"]
    nachnamen = ["M√ºller", "Schmidt", "Schneider", "Fischer", "Weber", "Meyer", "Wagner", "Becker"]
    orte = ["Berlin", "M√ºnchen", "Hamburg", "K√∂ln", "Frankfurt", "Stuttgart", "D√ºsseldorf", "Leipzig"]
    strassen = ["Hauptstra√üe", "Bahnhofstra√üe", "Berliner Stra√üe", "Gartenweg", "Schulstra√üe", "Kirchplatz"]

    vorname = random.choice(vornamen)
    nachname = random.choice(nachnamen)
    geb_tag = random.randint(1, 28)
    geb_monat = random.randint(1, 12)
    geb_jahr = random.randint(1960, 2000)
    geburtsort = random.choice(orte)
    wohnort = random.choice(orte)
    strasse = random.choice(strassen)
    hausnr = str(random.randint(1, 150))
    plz = f"{random.randint(10000, 99999)}"
    ausweisnummer = f"L{random.randint(10000000, 99999999)}"
    gueltig_tag = random.randint(1, 28)
    gueltig_monat = random.randint(1, 12)
    gueltig_jahr = random.randint(2026, 2035)
    groesse = random.randint(160, 195)
    augenfarbe = random.choice(["BRAUN", "BLAU", "GR√úN", "GRAU"])
    geschlecht = random.choice(["M", "W"])

    # Erstelle direkt PersonalDaten-Objekt (zuverl√§ssiger als Regex-Parsing)
    personal_daten = PersonalDaten(
        vorname=vorname,
        nachname=nachname,
        geburtsdatum=date(geb_jahr, geb_monat, geb_tag),
        geburtsort=geburtsort,
        nationalitaet="DEUTSCH",
        strasse=strasse,
        hausnummer=hausnr,
        plz=plz,
        ort=wohnort,
        ausweisnummer=ausweisnummer,
        ausweisart="Personalausweis",
        gueltig_bis=date(gueltig_jahr, gueltig_monat, gueltig_tag),
        groesse_cm=groesse,
        augenfarbe=augenfarbe,
        geschlecht=geschlecht
    )

    # OCR-Text f√ºr Anzeige generieren
    ocr_text = f"""
=== SIMULIERTE OCR-ERKENNUNG ===
(Demo-Modus - echte OCR erfordert pytesseract)

BUNDESREPUBLIK DEUTSCHLAND
PERSONALAUSWEIS / IDENTITY CARD

Erkannte Daten:
---------------
Nachname: {nachname}
Vorname: {vorname}
Geburtsdatum: {geb_tag:02d}.{geb_monat:02d}.{geb_jahr}
Geburtsort: {geburtsort}
Staatsangeh√∂rigkeit: DEUTSCH

Anschrift:
{strasse} {hausnr}
{plz} {wohnort}

Ausweisnummer: {ausweisnummer}
G√ºltig bis: {gueltig_tag:02d}.{gueltig_monat:02d}.{gueltig_jahr}
Gr√∂√üe: {groesse} cm
Augenfarbe: {augenfarbe}
Geschlecht: {geschlecht}
"""

    return personal_daten, ocr_text


def parse_ausweis_ocr_text(ocr_text: str) -> 'PersonalDaten':
    """Extrahiert strukturierte Daten aus echtem OCR-Text eines Ausweises"""
    import re

    personal_daten = PersonalDaten()

    # Text normalisieren
    text_upper = ocr_text.upper()
    lines = [line.strip() for line in ocr_text.split('\n') if line.strip()]

    # Verbesserte Nachname-Extraktion
    for i, line in enumerate(lines):
        line_upper = line.upper()
        if 'NACHNAME' in line_upper or 'SURNAME' in line_upper:
            # Nachname ist oft in der n√§chsten Zeile
            if i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                if next_line and not any(x in next_line.upper() for x in ['VORNAME', 'GIVEN', 'GEBOREN']):
                    personal_daten.nachname = next_line.title()
                    break

    # Verbesserte Vorname-Extraktion
    for i, line in enumerate(lines):
        line_upper = line.upper()
        if 'VORNAME' in line_upper or 'GIVEN NAME' in line_upper:
            if i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                if next_line and not any(x in next_line.upper() for x in ['NACHNAME', 'SURNAME', 'GEBOREN', 'GEBURT']):
                    personal_daten.vorname = next_line.title()
                    break

    # Geburtsdatum extrahieren (Format: DD.MM.YYYY oder √§hnlich)
    date_pattern = r'(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{4})'
    for i, line in enumerate(lines):
        if 'GEBURTSDATUM' in line.upper() or 'DATE OF BIRTH' in line.upper() or 'GEBOREN' in line.upper():
            # Suche in dieser und n√§chster Zeile
            search_text = line + " " + (lines[i + 1] if i + 1 < len(lines) else "")
            match = re.search(date_pattern, search_text)
            if match:
                try:
                    day, month, year = int(match.group(1)), int(match.group(2)), int(match.group(3))
                    personal_daten.geburtsdatum = date(year, month, day)
                except:
                    pass
                break

    # Geburtsort extrahieren
    for i, line in enumerate(lines):
        line_upper = line.upper()
        if 'GEBURTSORT' in line_upper or 'PLACE OF BIRTH' in line_upper:
            if i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                if next_line and not any(x in next_line.upper() for x in ['STAATSANG', 'NATIONAL', 'WOHNORT']):
                    personal_daten.geburtsort = next_line.title()
                    break

    # Staatsangeh√∂rigkeit
    if "DEUTSCH" in text_upper:
        personal_daten.nationalitaet = "DEUTSCH"

    # Adresse extrahieren - suche nach PLZ-Muster
    plz_pattern = r'(\d{5})\s+([A-Z√Ñ√ñ√úa-z√§√∂√º√ü\-\s]+)'
    for i, line in enumerate(lines):
        if 'ANSCHRIFT' in line.upper() or 'ADDRESS' in line.upper() or 'WOHNORT' in line.upper():
            # Suche in den n√§chsten Zeilen
            for j in range(i + 1, min(i + 4, len(lines))):
                plz_match = re.search(plz_pattern, lines[j])
                if plz_match:
                    personal_daten.plz = plz_match.group(1)
                    personal_daten.ort = plz_match.group(2).strip().title()
                    # Stra√üe ist vermutlich in vorheriger Zeile
                    if j > i + 1:
                        strasse_zeile = lines[j - 1]
                        # Trenne Stra√üe und Hausnummer
                        strasse_match = re.match(r'(.+?)\s+(\d+\s*[a-zA-Z]?)$', strasse_zeile)
                        if strasse_match:
                            personal_daten.strasse = strasse_match.group(1).strip()
                            personal_daten.hausnummer = strasse_match.group(2).strip()
                        else:
                            personal_daten.strasse = strasse_zeile
                    break
            break

    # Ausweisnummer extrahieren (Format: Lxxxxxxxx oder √§hnlich)
    ausweis_pattern = r'[A-Z]\d{8,9}'
    for line in lines:
        if 'AUSWEISNUMMER' in line.upper() or 'DOCUMENT NUMBER' in line.upper():
            match = re.search(ausweis_pattern, line.upper())
            if match:
                personal_daten.ausweisnummer = match.group(0)
                break
    # Fallback: Suche √ºberall
    if not personal_daten.ausweisnummer:
        for line in lines:
            match = re.search(ausweis_pattern, line.upper())
            if match:
                personal_daten.ausweisnummer = match.group(0)
                break

    # G√ºltig bis extrahieren
    for i, line in enumerate(lines):
        if 'G√úLTIG' in line.upper() or 'EXPIRY' in line.upper() or 'VALID' in line.upper():
            search_text = line + " " + (lines[i + 1] if i + 1 < len(lines) else "")
            match = re.search(date_pattern, search_text)
            if match:
                try:
                    day, month, year = int(match.group(1)), int(match.group(2)), int(match.group(3))
                    personal_daten.gueltig_bis = date(year, month, day)
                except:
                    pass
                break

    # Gr√∂√üe extrahieren
    groesse_match = re.search(r'(\d{3})\s*CM', text_upper)
    if groesse_match:
        personal_daten.groesse_cm = int(groesse_match.group(1))

    # Augenfarbe extrahieren
    for farbe in ["BRAUN", "BLAU", "GR√úN", "GRAU", "SCHWARZ"]:
        if farbe in text_upper:
            # Pr√ºfe ob es im Kontext von Augenfarbe steht
            if re.search(rf'AUGENFARBE.*{farbe}|{farbe}.*AUGENFARBE|EYE.*{farbe}', text_upper):
                personal_daten.augenfarbe = farbe
                break

    # Geschlecht extrahieren
    if re.search(r'\bSEX[:\s]+M\b|\bGESCHLECHT[:\s]+M\b', text_upper):
        personal_daten.geschlecht = "M"
    elif re.search(r'\bSEX[:\s]+[FW]\b|\bGESCHLECHT[:\s]+[FW]\b', text_upper):
        personal_daten.geschlecht = "W"

    # Ausweisart erkennen
    if "REISEPASS" in text_upper or "PASSPORT" in text_upper:
        personal_daten.ausweisart = "Reisepass"
    else:
        personal_daten.ausweisart = "Personalausweis"

    return personal_daten


def render_ausweis_upload(user_id: str, rolle: str, context: str = ""):
    """
    Rendert das Ausweis-Upload-Widget mit OCR-Erkennung f√ºr Vorder- und R√ºckseite

    Args:
        user_id: ID des Benutzers
        rolle: Rolle des Benutzers (K√§ufer, Verk√§ufer)
        context: Optionaler Kontext f√ºr eindeutige Widget-Keys (z.B. "makler_", "notar_")
    """
    # Eindeutiger Key-Prefix f√ºr diesen Kontext
    key_prefix = f"{context}_{user_id}" if context else user_id
    user = st.session_state.users.get(user_id)
    if not user:
        st.error("Benutzer nicht gefunden.")
        return

    st.markdown("### ü™™ Personalausweis / Reisepass")

    # OCR-Status pr√ºfen und anzeigen
    ocr_status = check_ocr_availability()
    if ocr_status['available']:
        st.success(f"‚úÖ OCR aktiviert: {ocr_status['method']}")
    else:
        st.warning(f"""
        ‚ö†Ô∏è **OCR nicht verf√ºgbar** - Demo-Modus aktiv

        {ocr_status['message']}

        **So aktivieren Sie echte OCR:**
        1. Gehen Sie zu **Notar-Dashboard ‚Üí Einstellungen**
        2. Hinterlegen Sie einen **OpenAI** oder **Anthropic API-Key**
        3. Laden Sie die Seite neu
        """)

    st.info("""
    üì± **So funktioniert's:**
    1. Laden Sie zuerst die **Vorderseite** Ihres Ausweises hoch (Name, Geburtsdatum, Foto)
    2. Dann laden Sie die **R√ºckseite** hoch (Adresse, Ausweisnummer, G√ºltigkeit)
    3. Die Daten werden automatisch per OCR erkannt und zusammengef√ºhrt
    """)

    # Bestehende Daten anzeigen
    if user.personal_daten and user.personal_daten.manuell_bestaetigt:
        st.success("‚úÖ Ausweisdaten wurden erfasst und best√§tigt.")
        with st.expander("üìã Gespeicherte Daten anzeigen", expanded=False):
            pd = user.personal_daten
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Name:** {pd.vorname} {pd.nachname}")
                st.write(f"**Geburtsdatum:** {pd.geburtsdatum.strftime('%d.%m.%Y') if pd.geburtsdatum else 'N/A'}")
                st.write(f"**Geburtsort:** {pd.geburtsort}")
                st.write(f"**Nationalit√§t:** {pd.nationalitaet}")
            with col2:
                st.write(f"**Adresse:** {pd.strasse} {pd.hausnummer}")
                st.write(f"**PLZ/Ort:** {pd.plz} {pd.ort}")
                st.write(f"**Ausweisnummer:** {pd.ausweisnummer}")
                st.write(f"**G√ºltig bis:** {pd.gueltig_bis.strftime('%d.%m.%Y') if pd.gueltig_bis else 'N/A'}")

        if st.button("üîÑ Neuen Ausweis hochladen", key=f"new_ausweis_{key_prefix}"):
            st.session_state[f"upload_new_ausweis_{user_id}"] = True
            # Reset der Seiten-Daten
            if f"ausweis_vorderseite_{user_id}" in st.session_state:
                del st.session_state[f"ausweis_vorderseite_{user_id}"]
            if f"ausweis_rueckseite_{user_id}" in st.session_state:
                del st.session_state[f"ausweis_rueckseite_{user_id}"]
            st.rerun()

        if not st.session_state.get(f"upload_new_ausweis_{user_id}", False):
            return

    # Initialisiere Session State f√ºr Ausweis-Seiten
    if f"ausweis_vorderseite_{user_id}" not in st.session_state:
        st.session_state[f"ausweis_vorderseite_{user_id}"] = None
    if f"ausweis_rueckseite_{user_id}" not in st.session_state:
        st.session_state[f"ausweis_rueckseite_{user_id}"] = None

    # Fortschrittsanzeige
    vorderseite_done = st.session_state[f"ausweis_vorderseite_{user_id}"] is not None
    rueckseite_done = st.session_state[f"ausweis_rueckseite_{user_id}"] is not None

    progress_col1, progress_col2, progress_col3 = st.columns(3)
    with progress_col1:
        if vorderseite_done:
            st.success("‚úÖ Vorderseite erfasst")
        else:
            st.warning("‚è≥ Vorderseite ausstehend")
    with progress_col2:
        if rueckseite_done:
            st.success("‚úÖ R√ºckseite erfasst")
        else:
            st.warning("‚è≥ R√ºckseite ausstehend")
    with progress_col3:
        if vorderseite_done and rueckseite_done:
            st.success("‚úÖ Bereit zur √úbernahme")
        else:
            st.info("üìã Daten pr√ºfen")

    st.markdown("---")

    # Tabs f√ºr Vorder- und R√ºckseite
    ausweis_tabs = st.tabs(["üìÑ Vorderseite", "üìÑ R√ºckseite", "‚úÖ Daten √ºbernehmen"])

    # === VORDERSEITE ===
    with ausweis_tabs[0]:
        st.markdown("#### Vorderseite des Ausweises")
        st.caption("Enth√§lt: Name, Geburtsdatum, Geburtsort, Nationalit√§t, Foto")

        render_ausweis_seite_upload(user_id, "vorderseite", key_prefix)

    # === R√úCKSEITE ===
    with ausweis_tabs[1]:
        st.markdown("#### R√ºckseite des Ausweises")
        st.caption("Enth√§lt: Adresse, Ausweisnummer, G√ºltigkeitsdatum, Gr√∂√üe, Augenfarbe")

        render_ausweis_seite_upload(user_id, "rueckseite", key_prefix)

    # === DATEN √úBERNEHMEN ===
    with ausweis_tabs[2]:
        render_ausweis_zusammenfassung(user_id, key_prefix)


def render_ausweis_seite_upload(user_id: str, seite: str, key_prefix: str = ""):
    """Rendert den Upload f√ºr eine Ausweis-Seite (Vorder- oder R√ºckseite)"""

    # Data key bleibt user_id basiert, Widget key nutzt key_prefix
    seite_key = f"ausweis_{seite}_{user_id}"
    widget_prefix = key_prefix if key_prefix else user_id
    seite_label = "Vorderseite" if seite == "vorderseite" else "R√ºckseite"

    # Pr√ºfen ob bereits erfasst
    if st.session_state.get(seite_key):
        ocr_data = st.session_state[seite_key]
        st.success(f"‚úÖ {seite_label} wurde erfasst (Vertrauen: {ocr_data['vertrauen']*100:.0f}%)")

        col1, col2 = st.columns([1, 2])
        with col1:
            try:
                st.image(ocr_data['image_data'], caption=seite_label, width=250)
            except:
                st.info("Bild gespeichert")

        with col2:
            with st.expander("üìã Erkannte Daten"):
                pd = ocr_data['personal_daten']
                if seite == "vorderseite":
                    st.write(f"**Vorname:** {pd.vorname}")
                    st.write(f"**Nachname:** {pd.nachname}")
                    st.write(f"**Geburtsdatum:** {pd.geburtsdatum.strftime('%d.%m.%Y') if pd.geburtsdatum else '-'}")
                    st.write(f"**Geburtsort:** {pd.geburtsort}")
                    st.write(f"**Nationalit√§t:** {pd.nationalitaet}")
                else:
                    st.write(f"**Stra√üe:** {pd.strasse} {pd.hausnummer}")
                    st.write(f"**PLZ/Ort:** {pd.plz} {pd.ort}")
                    st.write(f"**Ausweisnummer:** {pd.ausweisnummer}")
                    st.write(f"**G√ºltig bis:** {pd.gueltig_bis.strftime('%d.%m.%Y') if pd.gueltig_bis else '-'}")

        if st.button(f"üîÑ {seite_label} erneut erfassen", key=f"retry_{seite}_{widget_prefix}"):
            del st.session_state[seite_key]
            st.rerun()

        return

    # Upload-Methode ausw√§hlen
    upload_methode = st.radio(
        f"Wie m√∂chten Sie die {seite_label} erfassen?",
        ["üìÅ Datei hochladen", "üì∑ Foto aufnehmen (Kamera)"],
        key=f"upload_methode_{seite}_{widget_prefix}",
        horizontal=True
    )

    file_data = None
    file_name = "capture.jpg"

    if upload_methode == "üìÅ Datei hochladen":
        uploaded_file = st.file_uploader(
            f"{seite_label} hochladen",
            type=['jpg', 'jpeg', 'png', 'pdf'],
            key=f"upload_{seite}_{widget_prefix}",
            help=f"Bitte laden Sie ein gut lesbares Foto der {seite_label} Ihres Ausweises hoch."
        )
        if uploaded_file:
            file_data = uploaded_file.read()
            file_name = uploaded_file.name
    else:
        # Kamera-Auswahl f√ºr Benutzer
        st.markdown("##### üì∑ Kamera-Einstellungen")
        col_cam1, col_cam2 = st.columns(2)

        with col_cam1:
            kamera_auswahl = st.radio(
                "Kamera ausw√§hlen",
                options=["üì± R√ºckkamera (Hauptkamera)", "ü§≥ Frontkamera"],
                key=f"kamera_wahl_{seite}_{widget_prefix}",
                horizontal=True,
                help="Die R√ºckkamera (Hauptkamera) liefert meist bessere Qualit√§t f√ºr Dokumente"
            )

        with col_cam2:
            scan_hinweise = st.checkbox(
                "Hinweise anzeigen",
                value=True,
                key=f"hinweise_{seite}_{widget_prefix}"
            )

        # Bestimme Kamera-Modus basierend auf Auswahl
        facing_mode = "environment" if "R√ºck" in kamera_auswahl else "user"
        kamera_typ = "back" if "R√ºck" in kamera_auswahl else "front"

        if scan_hinweise:
            if "R√ºck" in kamera_auswahl:
                st.info("""üì± **Tipps f√ºr R√ºckkamera (Hauptkamera):**
                - Halten Sie den Ausweis flach und parallel zur Kamera
                - Sorgen Sie f√ºr gute, gleichm√§√üige Beleuchtung
                - Vermeiden Sie Reflexionen und Schatten
                - Halten Sie ca. 20-30 cm Abstand
                - Warten Sie, bis das Bild scharf ist""")
            else:
                st.info("""ü§≥ **Tipps f√ºr Frontkamera:**
                - Die Frontkamera hat meist niedrigere Aufl√∂sung
                - Nutzen Sie wenn m√∂glich die R√ºckkamera
                - Halten Sie das Ger√§t stabil""")

        # JavaScript um gew√§hlte Kamera zu verwenden
        st.markdown(f"""
        <script>
        // Setze Kamera auf {facing_mode}
        (function() {{
            const originalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
            navigator.mediaDevices.getUserMedia = function(constraints) {{
                if (constraints && constraints.video) {{
                    if (typeof constraints.video === 'boolean') {{
                        constraints.video = {{ facingMode: {{ ideal: '{facing_mode}' }} }};
                    }} else if (typeof constraints.video === 'object') {{
                        constraints.video.facingMode = {{ ideal: '{facing_mode}' }};
                    }}
                }}
                return originalGetUserMedia(constraints);
            }};
        }})();
        </script>
        """, unsafe_allow_html=True)

        # Kamera-Status anzeigen
        st.markdown(f"**Aktive Kamera:** {kamera_auswahl}")

        camera_photo = st.camera_input(
            f"{seite_label} fotografieren",
            key=f"camera_{seite}_{widget_prefix}"
        )
        if camera_photo:
            file_data = camera_photo.read()
            file_name = f"{seite}_kamera_{kamera_typ}.jpg"
            st.session_state[f"kamera_typ_{seite}_{widget_prefix}"] = kamera_typ

    if file_data:
        col1, col2 = st.columns([1, 2])
        with col1:
            try:
                st.image(file_data, caption=f"Erfasste {seite_label}", width=300)
            except:
                st.info(f"Datei: {file_name}")

        with col2:
            st.markdown("**Bildqualit√§t pr√ºfen:**")
            st.markdown("""
            - ‚úÖ Ausweis vollst√§ndig sichtbar
            - ‚úÖ Text gut lesbar
            - ‚úÖ Keine Reflexionen/Schatten
            """)

            if st.button(f"üîç {seite_label} analysieren", key=f"ocr_{seite}_{widget_prefix}", type="primary"):
                with st.spinner(f"Analysiere {seite_label}..."):
                    personal_daten, ocr_text, vertrauen = ocr_personalausweis(file_data, file_name)

                    st.session_state[seite_key] = {
                        'personal_daten': personal_daten,
                        'ocr_text': ocr_text,
                        'vertrauen': vertrauen,
                        'image_data': file_data
                    }

                    # Widget-Cache f√ºr Zusammenfassungs-Formular invalidieren
                    # damit neue Daten √ºbernommen werden
                    ocr_version_key = f"ausweis_ocr_version_{user_id}"
                    st.session_state[ocr_version_key] = st.session_state.get(ocr_version_key, 0) + 1

                st.success(f"‚úÖ {seite_label} analysiert!")
                st.rerun()


def render_ausweis_zusammenfassung(user_id: str, key_prefix: str = ""):
    """Zeigt die kombinierten Daten aus Vorder- und R√ºckseite und erm√∂glicht Bearbeitung"""

    # OCR-Version f√ºr Widget-Key-Invalidierung (damit neue Daten angezeigt werden)
    ocr_version = st.session_state.get(f"ausweis_ocr_version_{user_id}", 0)
    widget_prefix = f"{key_prefix}_{ocr_version}" if key_prefix else f"{user_id}_{ocr_version}"

    vorderseite = st.session_state.get(f"ausweis_vorderseite_{user_id}")
    rueckseite = st.session_state.get(f"ausweis_rueckseite_{user_id}")

    if not vorderseite and not rueckseite:
        st.info("Bitte erfassen Sie zuerst die Vorder- und/oder R√ºckseite Ihres Ausweises.")
        return

    st.markdown("### ‚úèÔ∏è Erkannte Daten pr√ºfen und bearbeiten")

    # Daten aus beiden Seiten kombinieren
    pd_vorne = vorderseite['personal_daten'] if vorderseite else PersonalDaten()
    pd_hinten = rueckseite['personal_daten'] if rueckseite else PersonalDaten()

    # Vertrauen berechnen
    vertrauen_vorne = vorderseite['vertrauen'] if vorderseite else 0
    vertrauen_hinten = rueckseite['vertrauen'] if rueckseite else 0
    gesamt_vertrauen = (vertrauen_vorne + vertrauen_hinten) / 2 if vorderseite and rueckseite else max(vertrauen_vorne, vertrauen_hinten)

    if gesamt_vertrauen < 0.5:
        st.warning("‚ö†Ô∏è Niedrige OCR-Vertrauensw√ºrdigkeit. Bitte pr√ºfen Sie alle Daten sorgf√§ltig.")
    elif gesamt_vertrauen < 0.75:
        st.info("‚ÑπÔ∏è Mittlere OCR-Vertrauensw√ºrdigkeit. Bitte pr√ºfen Sie die Daten.")

    # Bearbeitungsformular - Daten aus beiden Seiten zusammenf√ºhren
    col1, col2 = st.columns(2)

    with col1:
        st.markdown("**Pers√∂nliche Daten** (aus Vorderseite)")
        vorname = st.text_input("Vorname*", value=pd_vorne.vorname or pd_hinten.vorname, key=f"final_vorname_{widget_prefix}")
        nachname = st.text_input("Nachname*", value=pd_vorne.nachname or pd_hinten.nachname, key=f"final_nachname_{widget_prefix}")
        geburtsname = st.text_input("Geburtsname", value=pd_vorne.geburtsname or pd_hinten.geburtsname, key=f"final_geburtsname_{widget_prefix}")

        geb_datum = validate_date_for_input(
            pd_vorne.geburtsdatum or pd_hinten.geburtsdatum,
            fallback=date(1980, 1, 1)
        )
        geburtsdatum = st.date_input("Geburtsdatum*", value=geb_datum, format="DD.MM.YYYY", key=f"final_gebdat_{widget_prefix}")

        geburtsort = st.text_input("Geburtsort", value=pd_vorne.geburtsort or pd_hinten.geburtsort, key=f"final_geburtsort_{widget_prefix}")
        nationalitaet = st.text_input("Nationalit√§t", value=pd_vorne.nationalitaet or pd_hinten.nationalitaet or "DEUTSCH", key=f"final_nat_{widget_prefix}")

    with col2:
        st.markdown("**Adresse & Ausweis** (aus R√ºckseite)")
        strasse = st.text_input("Stra√üe*", value=pd_hinten.strasse or pd_vorne.strasse, key=f"final_strasse_{widget_prefix}")
        hausnummer = st.text_input("Hausnummer*", value=pd_hinten.hausnummer or pd_vorne.hausnummer, key=f"final_hausnr_{widget_prefix}")
        plz = st.text_input("PLZ*", value=pd_hinten.plz or pd_vorne.plz, key=f"final_plz_{widget_prefix}")
        ort = st.text_input("Ort*", value=pd_hinten.ort or pd_vorne.ort, key=f"final_ort_{widget_prefix}")

        ausweisart = st.selectbox("Ausweisart", ["Personalausweis", "Reisepass"],
                                  index=0, key=f"final_ausweisart_{widget_prefix}")
        ausweisnummer = st.text_input("Ausweisnummer*", value=pd_hinten.ausweisnummer or pd_vorne.ausweisnummer, key=f"final_ausweisnr_{widget_prefix}")

        gueltig_datum = validate_date_for_input(
            pd_hinten.gueltig_bis or pd_vorne.gueltig_bis,
            fallback=date.today() + timedelta(days=365*5)  # Default: 5 Jahre g√ºltig
        )
        gueltig_bis = st.date_input("G√ºltig bis*", value=gueltig_datum, format="DD.MM.YYYY", key=f"final_gueltig_{widget_prefix}")

    # OCR-Rohtext anzeigen
    with st.expander("üîç OCR-Rohtext anzeigen"):
        if vorderseite:
            st.markdown("**Vorderseite:**")
            st.text_area("", vorderseite['ocr_text'], height=100, disabled=True, key=f"ocr_raw_vorne_{widget_prefix}")
        if rueckseite:
            st.markdown("**R√ºckseite:**")
            st.text_area("", rueckseite['ocr_text'], height=100, disabled=True, key=f"ocr_raw_hinten_{widget_prefix}")

    # Buttons
    st.markdown("---")
    col1, col2, col3 = st.columns(3)

    with col1:
        if st.button("üíæ Daten √ºbernehmen & best√§tigen", key=f"final_save_{widget_prefix}", type="primary"):
            # Validierung
            if not all([vorname, nachname, strasse, hausnummer, plz, ort, ausweisnummer]):
                st.error("Bitte f√ºllen Sie alle Pflichtfelder (*) aus.")
            elif gueltig_bis < date.today():
                st.error("‚ö†Ô∏è Der Ausweis ist abgelaufen! Bitte verwenden Sie einen g√ºltigen Ausweis.")
            else:
                user = st.session_state.users.get(user_id)
                new_pd = PersonalDaten(
                    vorname=vorname,
                    nachname=nachname,
                    geburtsname=geburtsname,
                    geburtsdatum=geburtsdatum,
                    geburtsort=geburtsort,
                    nationalitaet=nationalitaet,
                    strasse=strasse,
                    hausnummer=hausnummer,
                    plz=plz,
                    ort=ort,
                    ausweisart=ausweisart,
                    ausweisnummer=ausweisnummer,
                    gueltig_bis=gueltig_bis,
                    groesse_cm=pd_hinten.groesse_cm or pd_vorne.groesse_cm,
                    augenfarbe=pd_hinten.augenfarbe or pd_vorne.augenfarbe,
                    geschlecht=pd_vorne.geschlecht or pd_hinten.geschlecht,
                    ocr_vertrauenswuerdigkeit=gesamt_vertrauen,
                    ocr_durchgefuehrt_am=datetime.now(),
                    manuell_bestaetigt=True,
                    bestaetigt_am=datetime.now()
                )

                # User aktualisieren
                user.personal_daten = new_pd
                # Vorderseite als Hauptbild speichern
                if vorderseite:
                    user.ausweis_foto = vorderseite['image_data']
                elif rueckseite:
                    user.ausweis_foto = rueckseite['image_data']
                user.name = f"{vorname} {nachname}"
                st.session_state.users[user_id] = user

                # Daten auch f√ºr Kaufvertrag-Generator speichern
                st.session_state[f"personal_{user_id}"] = {
                    'vorname': vorname,
                    'nachname': nachname,
                    'geburtsname': geburtsname,
                    'geburtsdatum': geburtsdatum.strftime('%d.%m.%Y') if geburtsdatum else '',
                    'geburtsort': geburtsort,
                    'nationalitaet': nationalitaet,
                    'strasse': strasse,
                    'hausnummer': hausnummer,
                    'plz': plz,
                    'ort': ort,
                    'ausweisart': ausweisart,
                    'ausweisnummer': ausweisnummer,
                    'gueltig_bis': gueltig_bis.strftime('%d.%m.%Y') if gueltig_bis else ''
                }

                # Session State aufr√§umen
                for key in [f"ausweis_vorderseite_{user_id}", f"ausweis_rueckseite_{user_id}",
                           f"upload_new_ausweis_{user_id}", f"ocr_result_{user_id}"]:
                    if key in st.session_state:
                        del st.session_state[key]

                st.success("‚úÖ Ausweisdaten erfolgreich gespeichert!")
                st.balloons()
                st.rerun()

    with col2:
        if st.button("üîÑ Alle Seiten neu erfassen", key=f"reset_all_{user_id}"):
            for key in [f"ausweis_vorderseite_{user_id}", f"ausweis_rueckseite_{user_id}"]:
                if key in st.session_state:
                    del st.session_state[key]
            st.rerun()

    with col3:
        if st.button("‚ùå Abbrechen", key=f"cancel_final_{user_id}"):
            for key in [f"ausweis_vorderseite_{user_id}", f"ausweis_rueckseite_{user_id}",
                       f"upload_new_ausweis_{user_id}"]:
                if key in st.session_state:
                    del st.session_state[key]
            st.rerun()


def update_projekt_status(projekt_id: str):
    """Aktualisiert den Projektstatus basierend auf Timeline-Events"""
    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt:
        return

    # Finde h√∂chsten abgeschlossenen Status
    completed_events = []
    for event_id in projekt.timeline_events:
        event = st.session_state.timeline_events.get(event_id)
        if event and event.completed:
            completed_events.append(event)

    if completed_events:
        latest_event = max(completed_events, key=lambda e: e.position)
        projekt.status = latest_event.status

# ============================================================================
# NOTAR-CHECKLISTEN-FUNKTIONEN
# ============================================================================

def get_checklist_fields(checklist_typ: str) -> Dict[str, Dict[str, Any]]:
    """Gibt die Felder-Definition f√ºr einen Checklisten-Typ zur√ºck"""

    if checklist_typ == ChecklistType.KAUFVERTRAG.value:
        return {
            "vorname": {"label": "Vorname", "type": "text", "required": True},
            "nachname": {"label": "Nachname", "type": "text", "required": True},
            "geburtsdatum": {"label": "Geburtsdatum", "type": "date", "required": True},
            "geburtsort": {"label": "Geburtsort", "type": "text", "required": True},
            "staatsangehoerigkeit": {"label": "Staatsangeh√∂rigkeit", "type": "text", "required": True},
            "familienstand": {"label": "Familienstand", "type": "select", "options": ["ledig", "verheiratet", "geschieden", "verwitwet"], "required": True},
            "gueterstand": {"label": "G√ºterstand (bei Verheirateten)", "type": "select", "options": ["Zugewinngemeinschaft", "G√ºtertrennung", "G√ºtergemeinschaft", "N/A"], "required": False},
            "strasse": {"label": "Stra√üe", "type": "text", "required": True},
            "hausnummer": {"label": "Hausnummer", "type": "text", "required": True},
            "plz": {"label": "PLZ", "type": "text", "required": True},
            "ort": {"label": "Ort", "type": "text", "required": True},
            "telefon": {"label": "Telefon", "type": "text", "required": True},
            "email": {"label": "E-Mail", "type": "text", "required": True},
            "steuer_id": {"label": "Steuer-ID", "type": "text", "required": True},
            "personalausweis": {"label": "Personalausweis-Nr.", "type": "text", "required": True},
            "ausgestellt_am": {"label": "Ausgestellt am", "type": "date", "required": True},
            "gueltig_bis": {"label": "G√ºltig bis", "type": "date", "required": True},
        }

    elif checklist_typ == ChecklistType.UEBERLASSUNG.value:
        return {
            "vorname": {"label": "Vorname", "type": "text", "required": True},
            "nachname": {"label": "Nachname", "type": "text", "required": True},
            "geburtsdatum": {"label": "Geburtsdatum", "type": "date", "required": True},
            "geburtsort": {"label": "Geburtsort", "type": "text", "required": True},
            "staatsangehoerigkeit": {"label": "Staatsangeh√∂rigkeit", "type": "text", "required": True},
            "strasse": {"label": "Stra√üe", "type": "text", "required": True},
            "hausnummer": {"label": "Hausnummer", "type": "text", "required": True},
            "plz": {"label": "PLZ", "type": "text", "required": True},
            "ort": {"label": "Ort", "type": "text", "required": True},
            "telefon": {"label": "Telefon", "type": "text", "required": True},
            "email": {"label": "E-Mail", "type": "text", "required": True},
            "ueberlassungsdatum": {"label": "√úberlassungsdatum", "type": "date", "required": True},
            "eigentumsverhaeltnis": {"label": "Eigentumsverh√§ltnis", "type": "text", "required": True},
            "nutzungsvereinbarung": {"label": "Nutzungsvereinbarung", "type": "textarea", "required": False},
            "besondere_bedingungen": {"label": "Besondere Bedingungen", "type": "textarea", "required": False},
            "zustimmung_eigentuemer": {"label": "Zustimmung Eigent√ºmer vorhanden", "type": "checkbox", "required": True},
            "vollmacht": {"label": "Vollmacht vorhanden", "type": "checkbox", "required": False},
        }

    elif checklist_typ == ChecklistType.MANDANT.value:
        return {
            "vorname": {"label": "Vorname", "type": "text", "required": True},
            "nachname": {"label": "Nachname", "type": "text", "required": True},
            "geburtsdatum": {"label": "Geburtsdatum", "type": "date", "required": True},
            "geburtsort": {"label": "Geburtsort", "type": "text", "required": True},
            "staatsangehoerigkeit": {"label": "Staatsangeh√∂rigkeit", "type": "text", "required": True},
            "strasse": {"label": "Stra√üe", "type": "text", "required": True},
            "hausnummer": {"label": "Hausnummer", "type": "text", "required": True},
            "plz": {"label": "PLZ", "type": "text", "required": True},
            "ort": {"label": "Ort", "type": "text", "required": True},
            "telefon": {"label": "Telefon", "type": "text", "required": True},
            "email": {"label": "E-Mail", "type": "text", "required": True},
            "beruf": {"label": "Beruf", "type": "text", "required": True},
            "arbeitgeber": {"label": "Arbeitgeber", "type": "text", "required": False},
            "pep_status": {"label": "Politisch exponierte Person (PEP)", "type": "select", "options": ["Nein", "Ja"], "required": True},
            "herkunft_mittel": {"label": "Herkunft der Mittel", "type": "textarea", "required": True},
            "geldwaesche_erklaerung": {"label": "Geldw√§sche-Erkl√§rung abgegeben", "type": "checkbox", "required": True},
        }

    elif checklist_typ == ChecklistType.DATENSCHUTZ.value:
        return {
            "datenschutz_text": {
                "label": "Datenschutzinformation Notariat",
                "type": "info",
                "content": """
# Datenschutzinformation gem√§√ü Art. 13, 14 DSGVO

## 1. Verantwortlicher
[Notariat] ist verantwortlich f√ºr die Verarbeitung Ihrer personenbezogenen Daten.

## 2. Zweck der Datenverarbeitung
Ihre Daten werden ausschlie√ülich zur Erf√ºllung unserer notariellen Pflichten und zur Vertragsabwicklung verarbeitet.

## 3. Rechtsgrundlage
Die Verarbeitung erfolgt auf Grundlage von Art. 6 Abs. 1 lit. b) und c) DSGVO zur Erf√ºllung vertraglicher und gesetzlicher Pflichten.

## 4. Speicherdauer
Ihre Daten werden gem√§√ü den gesetzlichen Aufbewahrungsfristen (¬ß 45 BNotO) f√ºr mindestens 10 Jahre gespeichert.

## 5. Ihre Rechte
Sie haben das Recht auf Auskunft, Berichtigung, L√∂schung, Einschr√§nkung der Verarbeitung, Daten√ºbertragbarkeit und Widerspruch.
                """,
                "required": True
            },
            "datenschutz_bestaetigung": {"label": "Ich habe die Datenschutzinformation zur Kenntnis genommen", "type": "checkbox", "required": True},
            "datenschutz_datum": {"label": "Datum der Kenntnisnahme", "type": "date", "required": True},
        }

    elif checklist_typ == ChecklistType.VERBRAUCHER.value:
        return {
            "verbraucher_text": {
                "label": "Verbraucher-Informationsblatt",
                "type": "info",
                "content": """
# Verbraucher-Informationsblatt gem√§√ü ¬ß 17a Abs. 1 BNotO

## Hinweise zum Grundst√ºckskaufvertrag

### 1. Allgemeine Informationen
Der Notar ist unparteiischer Betreuer aller Beteiligten und ber√§t Sie umfassend und neutral.

### 2. Kosten
Die Notarkosten richten sich nach dem Gerichts- und Notarkostengesetz (GNotKG) und sind gesetzlich festgelegt.

### 3. Wichtige Hinweise
- Der Kaufpreis wird erst nach Eigentumsumschreibung f√§llig
- Die Vormerkung sichert Ihre Rechte am Grundst√ºck
- Die Grunderwerbsteuer ist vom K√§ufer zu zahlen
- Pr√ºfen Sie die Finanzierung vor Vertragsunterzeichnung

### 4. Widerrufsrecht
Bei Verbrauchervertr√§gen kann unter bestimmten Umst√§nden ein Widerrufsrecht bestehen.

### 5. Rechtsberatung
Sie haben das Recht, sich vor Vertragsunterzeichnung rechtlich beraten zu lassen.
                """,
                "required": True
            },
            "verbraucher_bestaetigung": {"label": "Ich habe das Verbraucher-Informationsblatt erhalten und zur Kenntnis genommen", "type": "checkbox", "required": True},
            "verbraucher_datum": {"label": "Datum der Aush√§ndigung", "type": "date", "required": True},
            "beratungswunsch": {"label": "Ich w√ºnsche weitere rechtliche Beratung", "type": "checkbox", "required": False},
        }

    else:
        return {}

def render_checklist_form(checklist: NotarChecklist) -> bool:
    """Rendert ein Checklisten-Formular und gibt True zur√ºck wenn √Ñnderungen gespeichert wurden"""
    fields = get_checklist_fields(checklist.checklist_typ)

    if not fields:
        st.error("Unbekannter Checklisten-Typ")
        return False

    st.markdown(f"### {checklist.checklist_typ}")
    st.markdown(f"**Partei:** {checklist.partei}")

    changed = False
    new_data = checklist.daten.copy()

    for field_key, field_def in fields.items():
        field_type = field_def["type"]
        label = field_def["label"]
        required = field_def.get("required", False)

        if field_type == "info":
            st.info(field_def["content"])
        elif field_type == "text":
            current_val = new_data.get(field_key, "")
            new_val = st.text_input(f"{label}{'*' if required else ''}", value=current_val, key=f"{checklist.checklist_id}_{field_key}")
            if new_val != current_val:
                new_data[field_key] = new_val
                changed = True
        elif field_type == "textarea":
            current_val = new_data.get(field_key, "")
            new_val = st.text_area(f"{label}{'*' if required else ''}", value=current_val, key=f"{checklist.checklist_id}_{field_key}")
            if new_val != current_val:
                new_data[field_key] = new_val
                changed = True
        elif field_type == "date":
            current_val = new_data.get(field_key)
            if isinstance(current_val, str) and current_val:
                try:
                    current_val = datetime.fromisoformat(current_val).date()
                except:
                    current_val = None
            new_val = st.date_input(f"{label}{'*' if required else ''}", value=current_val, key=f"{checklist.checklist_id}_{field_key}")
            if new_val != current_val:
                new_data[field_key] = new_val.isoformat() if new_val else None
                changed = True
        elif field_type == "select":
            current_val = new_data.get(field_key, field_def["options"][0])
            new_val = st.selectbox(f"{label}{'*' if required else ''}", options=field_def["options"], index=field_def["options"].index(current_val) if current_val in field_def["options"] else 0, key=f"{checklist.checklist_id}_{field_key}")
            if new_val != current_val:
                new_data[field_key] = new_val
                changed = True
        elif field_type == "checkbox":
            current_val = new_data.get(field_key, False)
            new_val = st.checkbox(f"{label}{'*' if required else ''}", value=current_val, key=f"{checklist.checklist_id}_{field_key}")
            if new_val != current_val:
                new_data[field_key] = new_val
                changed = True

    # Pr√ºfe Vollst√§ndigkeit
    is_complete = True
    for field_key, field_def in fields.items():
        if field_def.get("required", False) and field_def["type"] != "info":
            if field_key not in new_data or not new_data[field_key]:
                is_complete = False
                break

    col1, col2, col3 = st.columns(3)
    with col1:
        if st.button("Speichern", key=f"save_{checklist.checklist_id}"):
            checklist.daten = new_data
            checklist.vollstaendig = is_complete
            checklist.updated_at = datetime.now()
            st.session_state.notar_checklists[checklist.checklist_id] = checklist
            st.success("Checkliste gespeichert!")
            changed = True

    with col2:
        if is_complete and not checklist.freigegeben:
            if st.button("Freigeben", key=f"release_{checklist.checklist_id}"):
                checklist.freigegeben = True
                st.session_state.notar_checklists[checklist.checklist_id] = checklist
                st.success("Checkliste freigegeben!")
                changed = True

    with col3:
        status = "‚úÖ Vollst√§ndig" if is_complete else "‚ö†Ô∏è Unvollst√§ndig"
        if checklist.freigegeben:
            status += " (Freigegeben)"
        st.markdown(f"**Status:** {status}")

    return changed

# ============================================================================
# BANKENMAPPE-GENERATOR
# ============================================================================

def create_bank_folder(projekt_id: str, erstellt_von: str) -> str:
    """Erstellt eine neue Bankenmappe f√ºr ein Projekt"""
    folder_id = f"bankfolder_{len(st.session_state.bank_folders)}"

    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt:
        return None

    # Expos√©-ID hinzuf√ºgen falls vorhanden
    expose_id = projekt.expose_data_id if projekt.expose_data_id else None

    bank_folder = BankFolder(
        folder_id=folder_id,
        projekt_id=projekt_id,
        erstellt_von=erstellt_von,
        expose_id=expose_id
    )

    st.session_state.bank_folders[folder_id] = bank_folder
    return folder_id

def render_bank_folder_view():
    """Rendert die Bankenmappe-Verwaltung"""
    st.markdown("### üíº Bankenmappe-Generator")
    st.info("Erstellen Sie automatisch eine Bankenmappe mit allen relevanten Unterlagen f√ºr die Finanzierung.")

    makler_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.makler_id == makler_id]

    if not projekte:
        st.warning("Keine Projekte vorhanden.")
        return

    # Projekt ausw√§hlen
    projekt_options = {f"{p.name} (ID: {p.projekt_id})": p.projekt_id for p in projekte}
    selected_projekt_label = st.selectbox("Projekt ausw√§hlen:", list(projekt_options.keys()), key="bankfolder_projekt")
    selected_projekt_id = projekt_options[selected_projekt_label]
    selected_projekt = st.session_state.projekte[selected_projekt_id]

    st.markdown("---")

    # Pr√ºfe ob bereits eine Bankenmappe f√ºr dieses Projekt existiert
    existing_folder = None
    for folder in st.session_state.bank_folders.values():
        if folder.projekt_id == selected_projekt_id:
            existing_folder = folder
            break

    if existing_folder:
        st.success(f"‚úÖ Bankenmappe vorhanden (erstellt am {existing_folder.created_at.strftime('%d.%m.%Y')})")

        # Inhalt der Bankenmappe anzeigen
        st.markdown("#### üìã Inhalt der Bankenmappe")

        col1, col2 = st.columns(2)

        with col1:
            st.markdown("**Expos√©:**")
            if existing_folder.expose_id:
                expose = st.session_state.expose_data.get(existing_folder.expose_id)
                if expose:
                    st.write(f"‚úÖ {expose.objekttitel}")
                else:
                    st.write("‚ùå Nicht gefunden")
            else:
                st.write("‚ùå Nicht hinzugef√ºgt")

            st.markdown("**Grundrisse:**")
            if existing_folder.grundrisse_ids:
                st.write(f"‚úÖ {len(existing_folder.grundrisse_ids)} Grundrisse")
            else:
                st.write("‚ùå Keine Grundrisse")

        with col2:
            st.markdown("**Weitere Dokumente:**")
            if existing_folder.dokument_ids:
                st.write(f"‚úÖ {len(existing_folder.dokument_ids)} Dokumente")
            else:
                st.write("‚ùå Keine weiteren Dokumente")

            st.markdown("**Status:**")
            st.write(f"üìä {existing_folder.status}")

        st.markdown("---")

        # Dokumente zur Bankenmappe hinzuf√ºgen
        with st.expander("‚ûï Dokumente hinzuf√ºgen/verwalten"):
            st.markdown("##### Verf√ºgbare Dokumente aus dem Projekt")

            # Expos√© automatisch hinzuf√ºgen
            if selected_projekt.expose_data_id and not existing_folder.expose_id:
                if st.button("Expos√© zur Bankenmappe hinzuf√ºgen", key="add_expose_to_folder"):
                    existing_folder.expose_id = selected_projekt.expose_data_id
                    st.session_state.bank_folders[existing_folder.folder_id] = existing_folder
                    st.success("Expos√© hinzugef√ºgt!")
                    st.rerun()

            st.markdown("**Hochgeladene Dokumente k√∂nnen hier hinzugef√ºgt werden**")
            st.info("In einer vollst√§ndigen Implementierung w√ºrden hier alle Projektdokumente aufgelistet.")

        # Bankenmappe generieren
        st.markdown("---")
        col1, col2, col3 = st.columns(3)

        with col1:
            if st.button("üì• PDF generieren", type="primary"):
                st.info("PDF-Generierung mit allen Dokumenten w√ºrde hier mit reportlab/PyPDF2 erfolgen")
                existing_folder.status = "Generiert"
                existing_folder.pdf_data = b"PDF_PLACEHOLDER"  # Hier w√ºrde das echte PDF sein
                st.session_state.bank_folders[existing_folder.folder_id] = existing_folder

        with col2:
            if existing_folder.pdf_data:
                st.download_button(
                    "üì§ Bankenmappe herunterladen",
                    existing_folder.pdf_data,
                    file_name=f"Bankenmappe_{selected_projekt.name}.pdf",
                    mime="application/pdf"
                )

        with col3:
            if st.button("üìß Per E-Mail versenden"):
                st.info("E-Mail-Versand w√ºrde hier implementiert werden")

        # Checkliste anzeigen
        st.markdown("---")
        st.markdown("#### ‚úÖ Checkliste Bankenmappe")

        checklist_items = [
            ("Expos√©", existing_folder.expose_id is not None),
            ("Grundrisse", len(existing_folder.grundrisse_ids) > 0),
            ("Kaufvertragsentwurf", False),  # Placeholder
            ("Grundbuchauszug", False),  # Placeholder
            ("Teilungserkl√§rung (bei WEG)", selected_projekt.property_type == PropertyType.WOHNUNG.value),
            ("Energieausweis", False),  # Placeholder
            ("Finanzierungsbest√§tigung", False),  # Placeholder
        ]

        for item, completed in checklist_items:
            if completed:
                st.markdown(f"‚úÖ {item}")
            else:
                st.markdown(f"‚¨ú {item}")

    else:
        st.info("Noch keine Bankenmappe f√ºr dieses Projekt erstellt.")

        if st.button("‚ûï Bankenmappe erstellen", type="primary"):
            folder_id = create_bank_folder(selected_projekt_id, makler_id)
            if folder_id:
                st.success("Bankenmappe erfolgreich erstellt!")
                st.rerun()
            else:
                st.error("Fehler beim Erstellen der Bankenmappe")

    st.markdown("---")
    st.markdown("#### ‚ÑπÔ∏è Was ist eine Bankenmappe?")
    st.markdown("""
    Die Bankenmappe enth√§lt alle relevanten Unterlagen f√ºr die Finanzierungspr√ºfung durch Banken:
    - **Expos√©** mit allen Objektdaten
    - **Grundrisse** und Lagepl√§ne
    - **Kaufvertragsentwurf** (vom Notar)
    - **Grundbuchauszug** (aktuell, nicht √§lter als 3 Monate)
    - **Teilungserkl√§rung** (bei Eigentumswohnungen)
    - **WEG-Protokolle** der letzten 2 Jahre (bei WEG)
    - **Energieausweis**
    - **Wirtschaftsplan** (bei WEG)
    - **Wohnfl√§chenberechnung**
    - **Finanzierungsbest√§tigung** des K√§ufers
    """)

# ============================================================================
# DOKUMENTEN-ANFORDERUNGS-SYSTEM
# ============================================================================

def create_document_request(projekt_id: str, dokument_typ: str, angefordert_von: str, angefordert_bei: str, nachricht: str = ""):
    """Erstellt eine neue Dokumentenanforderung"""
    request_id = f"req_{len(st.session_state.document_requests)}"
    request = DocumentRequest(
        request_id=request_id,
        projekt_id=projekt_id,
        dokument_typ=dokument_typ,
        angefordert_von=angefordert_von,
        angefordert_bei=angefordert_bei,
        nachricht=nachricht
    )
    st.session_state.document_requests[request_id] = request

    # Benachrichtigung an Empf√§nger
    empfaenger = st.session_state.users.get(angefordert_bei)
    anforderer = st.session_state.users.get(angefordert_von)
    if empfaenger and anforderer:
        create_notification(
            angefordert_bei,
            "Neue Dokumentenanforderung",
            f"{anforderer.name} hat das Dokument '{dokument_typ}' angefordert.",
            NotificationType.INFO.value
        )

    return request_id

def render_document_requests_view(user_id: str, user_role: str):
    """Rendert die Dokumentenanforderungs-Ansicht f√ºr einen Benutzer"""

    st.markdown("### üìã Dokumentenanforderungen")

    tabs = st.tabs(["Meine Anfragen", "An mich gerichtet", "Neue Anfrage erstellen"])

    # Meine Anfragen (die ich gestellt habe)
    with tabs[0]:
        st.subheader("üì§ Von mir gestellte Anfragen")
        my_requests = [r for r in st.session_state.document_requests.values() if r.angefordert_von == user_id]

        if not my_requests:
            st.info("Sie haben noch keine Dokumentenanforderungen gestellt.")
        else:
            for request in my_requests:
                empfaenger = st.session_state.users.get(request.angefordert_bei)
                empfaenger_name = empfaenger.name if empfaenger else "Unbekannt"

                status_icon = {
                    DocumentRequestStatus.ANGEFORDERT.value: "‚è≥",
                    DocumentRequestStatus.BEREITGESTELLT.value: "‚úÖ",
                    DocumentRequestStatus.FEHLT.value: "‚ùå",
                    DocumentRequestStatus.NICHT_RELEVANT.value: "‚äò"
                }.get(request.status, "‚ùì")

                with st.expander(f"{status_icon} {request.dokument_typ} - von {empfaenger_name}"):
                    st.write(f"**Status:** {request.status}")
                    st.write(f"**Erstellt:** {request.created_at.strftime('%d.%m.%Y %H:%M')}")
                    if request.nachricht:
                        st.write(f"**Nachricht:** {request.nachricht}")

                    if request.status == DocumentRequestStatus.BEREITGESTELLT.value and request.bereitgestellt_am:
                        st.success(f"Bereitgestellt am: {request.bereitgestellt_am.strftime('%d.%m.%Y %H:%M')}")

    # An mich gerichtete Anfragen
    with tabs[1]:
        st.subheader("üì• An mich gerichtete Anfragen")
        requests_to_me = [r for r in st.session_state.document_requests.values() if r.angefordert_bei == user_id]

        if not requests_to_me:
            st.info("Es liegen keine Dokumentenanforderungen an Sie vor.")
        else:
            for request in requests_to_me:
                anforderer = st.session_state.users.get(request.angefordert_von)
                anforderer_name = anforderer.name if anforderer else "Unbekannt"

                status_icon = {
                    DocumentRequestStatus.ANGEFORDERT.value: "‚è≥",
                    DocumentRequestStatus.BEREITGESTELLT.value: "‚úÖ",
                    DocumentRequestStatus.FEHLT.value: "‚ùå",
                    DocumentRequestStatus.NICHT_RELEVANT.value: "‚äò"
                }.get(request.status, "‚ùì")

                with st.expander(f"{status_icon} {request.dokument_typ} - von {anforderer_name}", expanded=(request.status == DocumentRequestStatus.ANGEFORDERT.value)):
                    st.write(f"**Dokument:** {request.dokument_typ}")
                    st.write(f"**Angefordert von:** {anforderer_name}")
                    st.write(f"**Erstellt:** {request.created_at.strftime('%d.%m.%Y %H:%M')}")
                    if request.nachricht:
                        st.info(f"**Nachricht:** {request.nachricht}")

                    st.markdown("---")

                    # Status √§ndern
                    new_status = st.selectbox(
                        "Status √§ndern:",
                        options=[s.value for s in DocumentRequestStatus],
                        index=[s.value for s in DocumentRequestStatus].index(request.status),
                        key=f"status_{request.request_id}"
                    )

                    if new_status != request.status:
                        if st.button("Status aktualisieren", key=f"update_status_{request.request_id}"):
                            request.status = new_status
                            if new_status == DocumentRequestStatus.BEREITGESTELLT.value:
                                request.bereitgestellt_am = datetime.now()

                                # Benachrichtigung an Anforderer
                                create_notification(
                                    request.angefordert_von,
                                    "Dokument bereitgestellt",
                                    f"{st.session_state.users[user_id].name} hat '{request.dokument_typ}' bereitgestellt.",
                                    NotificationType.SUCCESS.value
                                )

                            st.session_state.document_requests[request.request_id] = request
                            st.success("Status aktualisiert!")
                            st.rerun()

                    # Dokument hochladen (optional)
                    if request.status == DocumentRequestStatus.ANGEFORDERT.value:
                        uploaded_doc = st.file_uploader("Dokument hochladen", type=["pdf", "jpg", "jpeg", "png"], key=f"upload_doc_{request.request_id}")
                        if uploaded_doc:
                            if st.button("Dokument hochladen und als bereitgestellt markieren", key=f"upload_submit_{request.request_id}"):
                                # Hier w√ºrde man das Dokument in wirtschaftsdaten oder einen anderen Speicher legen
                                st.info("Dokument-Upload w√ºrde hier implementiert werden (in wirtschaftsdaten speichern)")
                                request.status = DocumentRequestStatus.BEREITGESTELLT.value
                                request.bereitgestellt_am = datetime.now()
                                st.session_state.document_requests[request.request_id] = request

                                # Benachrichtigung
                                create_notification(
                                    request.angefordert_von,
                                    "Dokument bereitgestellt",
                                    f"{st.session_state.users[user_id].name} hat '{request.dokument_typ}' hochgeladen.",
                                    NotificationType.SUCCESS.value
                                )
                                st.success("Dokument hochgeladen und Status aktualisiert!")
                                st.rerun()

    # Neue Anfrage erstellen
    with tabs[2]:
        st.subheader("‚ûï Neue Dokumentenanforderung erstellen")

        # Projekt ausw√§hlen
        if user_role == UserRole.MAKLER.value:
            projekte = [p for p in st.session_state.projekte.values() if p.makler_id == user_id]
        elif user_role == UserRole.NOTAR.value:
            projekte = [p for p in st.session_state.projekte.values() if p.notar_id == user_id]
        else:
            projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids + p.verkaeufer_ids]

        if not projekte:
            st.warning("Sie sind keinem Projekt zugeordnet.")
            return

        projekt_options = {f"{p.name} (ID: {p.projekt_id})": p.projekt_id for p in projekte}
        selected_projekt_label = st.selectbox("Projekt ausw√§hlen:", list(projekt_options.keys()), key="new_req_projekt")
        selected_projekt_id = projekt_options[selected_projekt_label]
        selected_projekt = st.session_state.projekte[selected_projekt_id]

        # Empf√§nger ausw√§hlen - alle Projektbeteiligten
        empfaenger_options = {}

        # K√§ufer
        for kid in selected_projekt.kaeufer_ids:
            k = st.session_state.users.get(kid)
            if k:
                empfaenger_options[f"üè† K√§ufer: {k.name}"] = kid

        # Verk√§ufer
        for vid in selected_projekt.verkaeufer_ids:
            v = st.session_state.users.get(vid)
            if v:
                empfaenger_options[f"üè° Verk√§ufer: {v.name}"] = vid

        # Makler
        if selected_projekt.makler_id:
            m = st.session_state.users.get(selected_projekt.makler_id)
            if m and selected_projekt.makler_id != user_id:  # Nicht an sich selbst
                empfaenger_options[f"üëî Makler: {m.name}"] = selected_projekt.makler_id

        # Finanzierer
        for fid in selected_projekt.finanzierer_ids:
            f = st.session_state.users.get(fid)
            if f and fid != user_id:  # Nicht an sich selbst
                empfaenger_options[f"üè¶ Finanzierer: {f.name}"] = fid

        # Notar (falls Anfrage nicht vom Notar selbst kommt)
        if selected_projekt.notar_id and selected_projekt.notar_id != user_id:
            n = st.session_state.users.get(selected_projekt.notar_id)
            if n:
                empfaenger_options[f"‚öñÔ∏è Notar: {n.name}"] = selected_projekt.notar_id

        if not empfaenger_options:
            st.warning("Keine Empf√§nger in diesem Projekt verf√ºgbar.")
            return

        empfaenger_label = st.selectbox("An wen soll die Anfrage gerichtet werden:", list(empfaenger_options.keys()), key="new_req_empf")
        empfaenger_id = empfaenger_options[empfaenger_label]

        dokument_typ = st.text_input("Dokument-Typ:", placeholder="z.B. Personalausweis, Grundbuchauszug, etc.", key="new_req_typ")
        nachricht = st.text_area("Nachricht (optional):", placeholder="Zus√§tzliche Informationen zur Anforderung", key="new_req_msg")

        if st.button("Anforderung erstellen", type="primary"):
            if dokument_typ:
                create_document_request(
                    projekt_id=selected_projekt_id,
                    dokument_typ=dokument_typ,
                    angefordert_von=user_id,
                    angefordert_bei=empfaenger_id,
                    nachricht=nachricht
                )
                st.success(f"Anforderung f√ºr '{dokument_typ}' wurde erstellt!")
                st.rerun()
            else:
                st.error("Bitte geben Sie einen Dokument-Typ an.")

# ============================================================================
# EXPOS√â-GENERATOR-FUNKTIONEN
# ============================================================================

def validate_address_online(strasse: str, hausnummer: str, plz: str, ort: str, land: str) -> Dict[str, Any]:
    """
    Validiert eine Adresse √ºber eine Online-API (Nominatim/OpenStreetMap).
    Gibt ein Dict mit validierter Adresse oder Vorschlag zur√ºck.
    """
    import urllib.request
    import urllib.parse

    try:
        # Adresse zusammenbauen
        query = f"{strasse} {hausnummer}, {plz} {ort}, {land}"
        encoded_query = urllib.parse.quote(query)

        url = f"https://nominatim.openstreetmap.org/search?q={encoded_query}&format=json&addressdetails=1&limit=1"

        req = urllib.request.Request(url, headers={'User-Agent': 'ImmobilienApp/1.0'})
        with urllib.request.urlopen(req, timeout=5) as response:
            data = json.loads(response.read().decode('utf-8'))

            if data and len(data) > 0:
                result = data[0]
                address = result.get('address', {})

                validated = {
                    'gefunden': True,
                    'strasse': address.get('road', strasse),
                    'hausnummer': address.get('house_number', hausnummer),
                    'plz': address.get('postcode', plz),
                    'ort': address.get('city') or address.get('town') or address.get('village', ort),
                    'land': address.get('country', land),
                    'lat': result.get('lat'),
                    'lon': result.get('lon'),
                    'display_name': result.get('display_name', '')
                }

                # Pr√ºfe ob Abweichungen existieren
                eingabe = f"{strasse} {hausnummer}, {plz} {ort}".lower().strip()
                gefunden = f"{validated['strasse']} {validated['hausnummer']}, {validated['plz']} {validated['ort']}".lower().strip()

                validated['abweichung'] = eingabe != gefunden
                return validated
            else:
                return {'gefunden': False, 'nachricht': 'Adresse nicht gefunden'}
    except Exception as e:
        return {'gefunden': False, 'nachricht': f'Fehler bei Validierung: {str(e)}'}


def calculate_price_suggestion(expose: 'ExposeData') -> float:
    """
    Berechnet einen Kaufpreis-Vorschlag basierend auf den Objektdaten.
    Einfaches Modell basierend auf Durchschnittspreisen.
    """
    # Basis-Preise pro m¬≤ (vereinfacht, je nach Region unterschiedlich)
    basis_preise = {
        "Wohnung": 3500,
        "Haus": 3000,
        "Mehrfamilienhaus": 2500,
        "Grundst√ºck/Land": 150,
    }

    basis = basis_preise.get(expose.objektart, 3000)

    # Fl√§che bestimmen
    if expose.objektart == "Grundst√ºck/Land":
        flaeche = expose.grundstuecksflaeche if expose.grundstuecksflaeche > 0 else 500
    else:
        flaeche = expose.wohnflaeche if expose.wohnflaeche > 0 else 80

    # Zuschl√§ge/Abschl√§ge
    faktor = 1.0

    # Zustand
    zustand_faktoren = {
        "Erstbezug": 1.3,
        "Neuwertig": 1.2,
        "Renoviert": 1.1,
        "Gepflegt": 1.0,
        "Sanierungsbed√ºrftig": 0.7,
    }
    faktor *= zustand_faktoren.get(expose.zustand, 1.0)

    # Baujahr
    if expose.baujahr > 0:
        alter = 2024 - expose.baujahr
        if alter < 5:
            faktor *= 1.15
        elif alter < 20:
            faktor *= 1.05
        elif alter > 50:
            faktor *= 0.85

    # Ausstattung
    if expose.hat_meerblick:
        faktor *= 1.25
    if expose.hat_fahrstuhl:
        faktor *= 1.05
    if expose.hat_balkon or expose.hat_terrasse:
        faktor *= 1.05
    if expose.hat_garage or expose.hat_tiefgarage:
        faktor *= 1.03
    if expose.hat_schwimmbad or expose.hat_gemeinschaftspool:
        faktor *= 1.08

    # Energieeffizienz
    if expose.energieeffizienzklasse in ["A+", "A", "B"]:
        faktor *= 1.05
    elif expose.energieeffizienzklasse in ["G", "H"]:
        faktor *= 0.95

    vorschlag = basis * flaeche * faktor
    return round(vorschlag, -3)  # Auf 1000er runden


# ============================================================================
# TERMIN-KOORDINATION FUNKTIONEN
# ============================================================================

def generate_ics_file(termin: 'Termin', projekt: 'Projekt') -> str:
    """Generiert eine ICS-Kalenderdatei f√ºr einen Termin"""
    from datetime import datetime, timedelta

    # Datum und Zeit kombinieren
    start_hour, start_min = map(int, termin.uhrzeit_start.split(':'))
    end_hour, end_min = map(int, termin.uhrzeit_ende.split(':'))

    start_dt = datetime.combine(termin.datum, datetime.min.time().replace(hour=start_hour, minute=start_min))
    end_dt = datetime.combine(termin.datum, datetime.min.time().replace(hour=end_hour, minute=end_min))

    # Teilnehmer sammeln
    teilnehmer_info = []
    for kontakt in termin.kontakte:
        teilnehmer_info.append(f"{kontakt.get('name', '')} ({kontakt.get('rolle', '')}): {kontakt.get('telefon', '')}")

    beschreibung = f"""Termin: {termin.termin_typ}
Projekt: {projekt.name}

Teilnehmer:
{chr(10).join(teilnehmer_info)}

Hinweis: Bitte bringen Sie einen g√ºltigen Personalausweis oder Reisepass mit.
"""

    # ICS Format - Beschreibung f√ºr ICS aufbereiten (Newlines durch \n ersetzen)
    beschreibung_ics = beschreibung.replace('\n', '\\n')
    ics_content = f"""BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Immobilien-Transaktionsplattform//DE
BEGIN:VEVENT
UID:{termin.termin_id}@immobilien-plattform.de
DTSTAMP:{datetime.now().strftime('%Y%m%dT%H%M%SZ')}
DTSTART:{start_dt.strftime('%Y%m%dT%H%M%S')}
DTEND:{end_dt.strftime('%Y%m%dT%H%M%S')}
SUMMARY:{termin.termin_typ}: {projekt.name}
DESCRIPTION:{beschreibung_ics}
LOCATION:{termin.ort}
STATUS:CONFIRMED
END:VEVENT
END:VCALENDAR"""

    return ics_content


def send_appointment_email(empfaenger: List[Dict[str, str]], termin: 'Termin', projekt: 'Projekt', email_typ: str = "bestaetigung"):
    """Simuliert das Senden von Termin-E-Mails

    Args:
        empfaenger: Liste von {email, name}
        termin: Der Termin
        projekt: Das Projekt
        email_typ: "bestaetigung", "erinnerung", "vorschlag"
    """
    # In einer echten Anwendung w√ºrde hier SMTP verwendet
    # Hier simulieren wir das Senden durch Logging

    email_templates = {
        "bestaetigung": f"""
Sehr geehrte(r) {{name}},

Ihr Termin wurde best√§tigt:

Termin: {termin.termin_typ}
Datum: {termin.datum.strftime('%d.%m.%Y')}
Uhrzeit: {termin.uhrzeit_start} - {termin.uhrzeit_ende} Uhr
Ort: {termin.ort}
Projekt: {projekt.name}

Bitte bringen Sie einen g√ºltigen Personalausweis oder Reisepass mit.

Im Anhang finden Sie eine Kalenderdatei zur √úbernahme in Ihren Kalender.

Mit freundlichen Gr√º√üen,
Ihre Immobilien-Transaktionsplattform
        """,
        "erinnerung": f"""
Sehr geehrte(r) {{name}},

Dies ist eine Erinnerung an Ihren morgigen Termin:

Termin: {termin.termin_typ}
Datum: {termin.datum.strftime('%d.%m.%Y')}
Uhrzeit: {termin.uhrzeit_start} - {termin.uhrzeit_ende} Uhr
Ort: {termin.ort}
Projekt: {projekt.name}

Bitte bringen Sie einen g√ºltigen Personalausweis oder Reisepass mit.

Mit freundlichen Gr√º√üen,
Ihre Immobilien-Transaktionsplattform
        """,
        "vorschlag": f"""
Sehr geehrte(r) {{name}},

Der Notar hat Terminvorschl√§ge f√ºr die Beurkundung erstellt.
Bitte pr√ºfen Sie die Vorschl√§ge in Ihrem Dashboard und w√§hlen Sie einen passenden Termin aus.

Projekt: {projekt.name}

Mit freundlichen Gr√º√üen,
Ihre Immobilien-Transaktionsplattform
        """
    }

    # Simuliertes Senden - in der realen Anwendung w√ºrde hier SMTP verwendet
    sent_emails = []
    for emp in empfaenger:
        email_text = email_templates.get(email_typ, "").format(name=emp.get('name', 'Teilnehmer'))
        sent_emails.append({
            'to': emp.get('email'),
            'subject': f"[{email_typ.capitalize()}] {termin.termin_typ} - {projekt.name}",
            'body': email_text,
            'sent_at': datetime.now()
        })

    return sent_emails


def check_kaufvertrag_entwurf_status(projekt_id: str) -> bool:
    """Pr√ºft, ob der Kaufvertragsentwurf bereits versendet wurde (Timeline-Check)"""
    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt:
        return False

    # Pr√ºfe Timeline-Events f√ºr versendeten Entwurf
    for event_id in projekt.timeline_events:
        event = st.session_state.timeline_events.get(event_id)
        if event and "Kaufvertrag" in event.titel and event.completed:
            return True

    # Alternative: Pr√ºfe den Projekt-Status
    return projekt.status in [
        ProjektStatus.FINANZIERUNG_GESICHERT.value,
        ProjektStatus.NOTARTERMIN_VEREINBART.value,
        ProjektStatus.KAUFVERTRAG_UNTERZEICHNET.value,
        ProjektStatus.ABGESCHLOSSEN.value
    ]


def get_notar_calendar_availability(notar_id: str, datum_von: date, datum_bis: date) -> List[Dict[str, Any]]:
    """Simuliert die Outlook-Kalenderpr√ºfung des Notars

    Returns:
        Liste von verf√ºgbaren Zeitslots
    """
    import random

    verfuegbare_slots = []

    # Simuliere Kalenderverf√ºgbarkeit
    current_date = datum_von
    while current_date <= datum_bis:
        # Wochenenden √ºberspringen
        if current_date.weekday() < 5:  # Mo-Fr
            # Vormittag (9:00 - 12:00)
            if random.random() > 0.3:  # 70% Chance verf√ºgbar
                verfuegbare_slots.append({
                    'datum': current_date,
                    'tageszeit': 'Vormittag',
                    'uhrzeit_start': f"{random.choice([9, 10, 11])}:00",
                    'uhrzeit_ende': f"{random.choice([10, 11, 12])}:00"
                })

            # Nachmittag (14:00 - 17:00)
            if random.random() > 0.3:  # 70% Chance verf√ºgbar
                verfuegbare_slots.append({
                    'datum': current_date,
                    'tageszeit': 'Nachmittag',
                    'uhrzeit_start': f"{random.choice([14, 15, 16])}:00",
                    'uhrzeit_ende': f"{random.choice([15, 16, 17])}:00"
                })

        current_date += timedelta(days=1)

    return verfuegbare_slots


def create_termin_vorschlaege(projekt_id: str, notar_id: str, termin_typ: str = TerminTyp.BEURKUNDUNG.value) -> Optional['TerminVorschlag']:
    """Erstellt 3 Terminvorschl√§ge basierend auf Notar-Kalenderverf√ºgbarkeit"""

    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt:
        return None

    # Pr√ºfe ob Kaufvertragsentwurf versendet wurde (nur f√ºr Beurkundung)
    if termin_typ == TerminTyp.BEURKUNDUNG.value:
        if not check_kaufvertrag_entwurf_status(projekt_id):
            return None  # Kann keine Beurkundungstermine vorschlagen ohne Entwurf

    # Hole verf√ºgbare Slots aus dem Kalender
    heute = date.today()
    verfuegbar = get_notar_calendar_availability(
        notar_id,
        heute + timedelta(days=7),  # Ab n√§chster Woche
        heute + timedelta(days=30)  # Bis in 4 Wochen
    )

    if len(verfuegbar) < 3:
        return None

    # W√§hle 3 verschiedene Slots aus
    import random
    random.shuffle(verfuegbar)
    ausgewaehlte_slots = verfuegbar[:3]

    # Erstelle Terminvorschlag
    vorschlag_id = f"vorschlag_{len(st.session_state.terminvorschlaege)}"
    vorschlag = TerminVorschlag(
        vorschlag_id=vorschlag_id,
        projekt_id=projekt_id,
        termin_typ=termin_typ,
        vorschlaege=[
            {
                'datum': slot['datum'],
                'uhrzeit_start': slot['uhrzeit_start'],
                'uhrzeit_ende': slot['uhrzeit_ende'],
                'tageszeit': slot['tageszeit']
            }
            for slot in ausgewaehlte_slots
        ],
        erstellt_von=notar_id
    )

    st.session_state.terminvorschlaege[vorschlag_id] = vorschlag
    return vorschlag


def create_termin_from_vorschlag(vorschlag: 'TerminVorschlag', ausgewaehlter_index: int, projekt: 'Projekt') -> Optional['Termin']:
    """Erstellt einen Termin aus einem angenommenen Vorschlag"""

    if ausgewaehlter_index < 0 or ausgewaehlter_index >= len(vorschlag.vorschlaege):
        return None

    slot = vorschlag.vorschlaege[ausgewaehlter_index]

    # Kontakte sammeln
    kontakte = []

    # Makler
    if projekt.makler_id:
        makler = st.session_state.users.get(projekt.makler_id)
        if makler:
            kontakte.append({
                'name': makler.name,
                'telefon': makler.telefon if hasattr(makler, 'telefon') else '',
                'rolle': 'Makler'
            })

    # K√§ufer
    for kaeufer_id in projekt.kaeufer_ids:
        kaeufer = st.session_state.users.get(kaeufer_id)
        if kaeufer:
            kontakte.append({
                'name': kaeufer.name,
                'telefon': kaeufer.telefon if hasattr(kaeufer, 'telefon') else '',
                'rolle': 'K√§ufer'
            })

    # Verk√§ufer
    for verkaeufer_id in projekt.verkaeufer_ids:
        verkaeufer = st.session_state.users.get(verkaeufer_id)
        if verkaeufer:
            kontakte.append({
                'name': verkaeufer.name,
                'telefon': verkaeufer.telefon if hasattr(verkaeufer, 'telefon') else '',
                'rolle': 'Verk√§ufer'
            })

    # Notar
    if projekt.notar_id:
        notar = st.session_state.users.get(projekt.notar_id)
        if notar:
            kontakte.append({
                'name': notar.name,
                'telefon': notar.telefon if hasattr(notar, 'telefon') else '',
                'rolle': 'Notar'
            })

    # Termin-Titel erstellen: "Verk√§ufer ./. K√§ufer, Projektname (Makler)"
    verkaeufer_namen = [user.name for vid in projekt.verkaeufer_ids
                        if (user := st.session_state.users.get(vid))]
    kaeufer_namen = [user.name for kid in projekt.kaeufer_ids
                     if (user := st.session_state.users.get(kid))]
    makler_name = ""
    if projekt.makler_id:
        makler = st.session_state.users.get(projekt.makler_id)
        if makler:
            makler_name = f" ({makler.name})"

    termin_titel = f"{', '.join(verkaeufer_namen)} ./. {', '.join(kaeufer_namen)}, {projekt.name}{makler_name}"

    # Notar-Adresse als Ort
    notar = st.session_state.users.get(projekt.notar_id)
    ort = "Notariat"  # Default
    if notar and hasattr(notar, 'adresse'):
        ort = notar.adresse

    termin_id = f"termin_{len(st.session_state.termine)}"
    termin = Termin(
        termin_id=termin_id,
        projekt_id=projekt.projekt_id,
        termin_typ=vorschlag.termin_typ,
        datum=slot['datum'],
        uhrzeit_start=slot['uhrzeit_start'],
        uhrzeit_ende=slot['uhrzeit_ende'],
        tageszeit=slot['tageszeit'],
        ort=ort,
        beschreibung=termin_titel,
        status=TerminStatus.AUSSTEHEND.value,
        erstellt_von=vorschlag.erstellt_von,
        kontakte=kontakte,
        outlook_status="provisorisch"
    )

    st.session_state.termine[termin_id] = termin

    # Vorschlag als angenommen markieren
    vorschlag.status = "angenommen"
    vorschlag.ausgewaehlt_index = ausgewaehlter_index
    st.session_state.terminvorschlaege[vorschlag.vorschlag_id] = vorschlag

    # Termin zum Projekt hinzuf√ºgen
    if termin_id not in projekt.termine:
        projekt.termine.append(termin_id)
        st.session_state.projekte[projekt.projekt_id] = projekt

    return termin


def check_termin_bestaetigung(termin: 'Termin', projekt: 'Projekt') -> Dict[str, Any]:
    """Pr√ºft den Best√§tigungsstatus eines Termins"""

    result = {
        'alle_bestaetigt': False,
        'makler_bestaetigt': termin.bestaetigt_von_makler is not None,
        'notar_bestaetigt': termin.bestaetigt_von_notar is not None,
        'kaeufer_bestaetigt': [],
        'kaeufer_ausstehend': [],
        'verkaeufer_bestaetigt': [],
        'verkaeufer_ausstehend': []
    }

    # K√§ufer pr√ºfen
    for kaeufer_id in projekt.kaeufer_ids:
        if kaeufer_id in termin.bestaetigt_von_kaeufer:
            result['kaeufer_bestaetigt'].append(kaeufer_id)
        else:
            result['kaeufer_ausstehend'].append(kaeufer_id)

    # Verk√§ufer pr√ºfen
    for verkaeufer_id in projekt.verkaeufer_ids:
        if verkaeufer_id in termin.bestaetigt_von_verkaeufer:
            result['verkaeufer_bestaetigt'].append(verkaeufer_id)
        else:
            result['verkaeufer_ausstehend'].append(verkaeufer_id)

    # Pr√ºfen ob alle best√§tigt haben
    makler_ok = not projekt.makler_id or result['makler_bestaetigt']
    kaeufer_ok = len(result['kaeufer_ausstehend']) == 0
    verkaeufer_ok = len(result['verkaeufer_ausstehend']) == 0

    result['alle_bestaetigt'] = makler_ok and kaeufer_ok and verkaeufer_ok

    return result


def bestatige_termin(termin_id: str, user_id: str, rolle: str):
    """Best√§tigt einen Termin f√ºr einen Benutzer"""

    termin = st.session_state.termine.get(termin_id)
    if not termin:
        return False

    projekt = st.session_state.projekte.get(termin.projekt_id)
    if not projekt:
        return False

    now = datetime.now()

    if rolle == UserRole.MAKLER.value:
        termin.bestaetigt_von_makler = now
    elif rolle == UserRole.KAEUFER.value:
        if user_id not in termin.bestaetigt_von_kaeufer:
            termin.bestaetigt_von_kaeufer.append(user_id)
    elif rolle == UserRole.VERKAEUFER.value:
        if user_id not in termin.bestaetigt_von_verkaeufer:
            termin.bestaetigt_von_verkaeufer.append(user_id)
    elif rolle == UserRole.NOTAR.value:
        termin.bestaetigt_von_notar = now

    # Pr√ºfen ob alle best√§tigt haben
    status = check_termin_bestaetigung(termin, projekt)

    if status['alle_bestaetigt']:
        termin.status = TerminStatus.BESTAETIGT.value
        termin.outlook_status = "best√§tigt"

        # E-Mail-Benachrichtigungen senden
        empfaenger = []
        for kontakt in termin.kontakte:
            user = None
            if kontakt.get('rolle') == 'Makler' and projekt.makler_id:
                user = st.session_state.users.get(projekt.makler_id)
            elif kontakt.get('rolle') == 'K√§ufer':
                for kid in projekt.kaeufer_ids:
                    u = st.session_state.users.get(kid)
                    if u and u.name == kontakt.get('name'):
                        user = u
                        break
            elif kontakt.get('rolle') == 'Verk√§ufer':
                for vid in projekt.verkaeufer_ids:
                    u = st.session_state.users.get(vid)
                    if u and u.name == kontakt.get('name'):
                        user = u
                        break
            elif kontakt.get('rolle') == 'Notar' and projekt.notar_id:
                user = st.session_state.users.get(projekt.notar_id)

            if user:
                empfaenger.append({'email': user.email, 'name': user.name})

        send_appointment_email(empfaenger, termin, projekt, "bestaetigung")
    elif len(termin.bestaetigt_von_kaeufer) > 0 or len(termin.bestaetigt_von_verkaeufer) > 0 or termin.bestaetigt_von_makler:
        termin.status = TerminStatus.TEILWEISE_BESTAETIGT.value

    st.session_state.termine[termin_id] = termin
    return True


def render_termin_verwaltung(projekt: 'Projekt', user_rolle: str):
    """Rendert die Termin-Verwaltung UI"""

    st.markdown("#### üìÖ Terminverwaltung")

    # Tabs f√ºr verschiedene Termintypen
    termin_tabs = st.tabs(["üîç Besichtigung", "üîë √úbergabe", "üìú Beurkundung", "üìã Alle Termine"])

    with termin_tabs[0]:
        render_termin_section(projekt, TerminTyp.BESICHTIGUNG.value, user_rolle)

    with termin_tabs[1]:
        render_termin_section(projekt, TerminTyp.UEBERGABE.value, user_rolle)

    with termin_tabs[2]:
        render_termin_section(projekt, TerminTyp.BEURKUNDUNG.value, user_rolle)

    with termin_tabs[3]:
        render_alle_termine(projekt, user_rolle)


def render_termin_section(projekt: 'Projekt', termin_typ: str, user_rolle: str):
    """Rendert eine Termin-Sektion f√ºr einen bestimmten Termintyp"""

    # Bestehende Termine f√ºr diesen Typ anzeigen
    projekt_termine = [st.session_state.termine.get(tid) for tid in projekt.termine
                      if st.session_state.termine.get(tid) and
                      st.session_state.termine.get(tid).termin_typ == termin_typ]

    if projekt_termine:
        for termin in projekt_termine:
            render_termin_card(termin, projekt, user_rolle, context=f"section_{termin_typ}")
    else:
        st.info(f"Noch keine {termin_typ}-Termine vorhanden.")

    # Offene Terminvorschl√§ge anzeigen
    offene_vorschlaege = [v for v in st.session_state.terminvorschlaege.values()
                         if v.projekt_id == projekt.projekt_id and
                         v.termin_typ == termin_typ and
                         v.status == "offen"]

    if offene_vorschlaege:
        st.markdown("##### üì® Offene Terminvorschl√§ge")
        for vorschlag in offene_vorschlaege:
            render_terminvorschlag_card(vorschlag, projekt, user_rolle)

    # Neuen Termin anlegen (nur f√ºr bestimmte Rollen)
    if user_rolle in [UserRole.MAKLER.value, UserRole.NOTAR.value]:
        with st.expander(f"‚ûï Neuen {termin_typ}-Termin anlegen"):
            render_neuer_termin_form(projekt, termin_typ, user_rolle)


def render_termin_card(termin: 'Termin', projekt: 'Projekt', user_rolle: str, context: str = ""):
    """Rendert eine Termin-Karte"""

    status_colors = {
        TerminStatus.BESTAETIGT.value: "üü¢",
        TerminStatus.TEILWEISE_BESTAETIGT.value: "üü°",
        TerminStatus.AUSSTEHEND.value: "üü†",
        TerminStatus.VORGESCHLAGEN.value: "üîµ",
        TerminStatus.ABGESAGT.value: "üî¥",
        TerminStatus.ABGESCHLOSSEN.value: "‚úÖ"
    }

    status_icon = status_colors.get(termin.status, "‚ö™")

    with st.container():
        col1, col2, col3 = st.columns([3, 2, 2])

        with col1:
            st.markdown(f"**{status_icon} {termin.termin_typ}**")
            st.write(f"üìÖ {termin.datum.strftime('%d.%m.%Y')} | ‚è∞ {termin.uhrzeit_start} - {termin.uhrzeit_ende}")
            st.write(f"üìç {termin.ort}")

        with col2:
            st.write(f"**Status:** {termin.status}")
            if termin.status == TerminStatus.BESTAETIGT.value:
                st.success("Alle Parteien haben best√§tigt")

        with col3:
            # Best√§tigungsbutton (wenn noch nicht best√§tigt)
            user_id = st.session_state.current_user.user_id
            bereits_bestaetigt = False

            if user_rolle == UserRole.MAKLER.value:
                bereits_bestaetigt = termin.bestaetigt_von_makler is not None
            elif user_rolle == UserRole.KAEUFER.value:
                bereits_bestaetigt = user_id in termin.bestaetigt_von_kaeufer
            elif user_rolle == UserRole.VERKAEUFER.value:
                bereits_bestaetigt = user_id in termin.bestaetigt_von_verkaeufer
            elif user_rolle == UserRole.NOTAR.value:
                bereits_bestaetigt = termin.bestaetigt_von_notar is not None

            if termin.status not in [TerminStatus.BESTAETIGT.value, TerminStatus.ABGESAGT.value, TerminStatus.ABGESCHLOSSEN.value]:
                if bereits_bestaetigt:
                    st.success("‚úì Sie haben best√§tigt")
                else:
                    if st.button("‚úÖ Termin best√§tigen", key=f"confirm_{termin.termin_id}_{user_rolle}_{context}"):
                        bestatige_termin(termin.termin_id, user_id, user_rolle)
                        st.success("Termin best√§tigt!")
                        st.rerun()

            # Download ICS
            if termin.status == TerminStatus.BESTAETIGT.value:
                ics_content = generate_ics_file(termin, projekt)
                st.download_button(
                    "üì• Kalenderdatei (.ics)",
                    data=ics_content,
                    file_name=f"termin_{termin.termin_id}.ics",
                    mime="text/calendar",
                    key=f"ics_{termin.termin_id}_{context}"
                )

        st.markdown("---")


def render_terminvorschlag_card(vorschlag: 'TerminVorschlag', projekt: 'Projekt', user_rolle: str):
    """Rendert eine Terminvorschlag-Karte"""

    st.markdown(f"**Terminvorschl√§ge vom {vorschlag.erstellt_am.strftime('%d.%m.%Y %H:%M')}**")

    for i, slot in enumerate(vorschlag.vorschlaege):
        col1, col2 = st.columns([3, 1])
        with col1:
            st.write(f"**Option {i+1}:** {slot['datum'].strftime('%d.%m.%Y')} ({slot['tageszeit']})")
            st.write(f"‚è∞ {slot['uhrzeit_start']} - {slot['uhrzeit_ende']} Uhr")
        with col2:
            if user_rolle in [UserRole.MAKLER.value, UserRole.KAEUFER.value, UserRole.VERKAEUFER.value]:
                if st.button(f"Ausw√§hlen", key=f"select_{vorschlag.vorschlag_id}_{i}"):
                    termin = create_termin_from_vorschlag(vorschlag, i, projekt)
                    if termin:
                        st.success(f"Termin wurde erstellt! Bitte best√§tigen Sie den Termin.")
                        st.rerun()


def render_neuer_termin_form(projekt: 'Projekt', termin_typ: str, user_rolle: str):
    """Formular zum Anlegen eines neuen Termins"""

    col1, col2 = st.columns(2)

    with col1:
        datum = st.date_input("Datum", min_value=date.today(), key=f"new_termin_datum_{projekt.projekt_id}_{termin_typ}")
        tageszeit = st.selectbox("Tageszeit", ["Vormittag", "Nachmittag"], key=f"new_termin_tageszeit_{projekt.projekt_id}_{termin_typ}")

    with col2:
        uhrzeit_start = st.time_input("Beginn", value=datetime.strptime("10:00", "%H:%M").time(), key=f"new_termin_start_{projekt.projekt_id}_{termin_typ}")
        uhrzeit_ende = st.time_input("Ende", value=datetime.strptime("11:00", "%H:%M").time(), key=f"new_termin_ende_{projekt.projekt_id}_{termin_typ}")

    ort = st.text_input("Ort/Adresse", value=projekt.adresse, key=f"new_termin_ort_{projekt.projekt_id}_{termin_typ}")
    beschreibung = st.text_area("Beschreibung/Hinweise", key=f"new_termin_beschr_{projekt.projekt_id}_{termin_typ}")

    if st.button(f"Termin erstellen", key=f"create_termin_{projekt.projekt_id}_{termin_typ}"):
        # Kontakte sammeln
        kontakte = []
        if projekt.makler_id:
            makler = st.session_state.users.get(projekt.makler_id)
            if makler:
                kontakte.append({'name': makler.name, 'telefon': '', 'rolle': 'Makler'})

        for kid in projekt.kaeufer_ids:
            kaeufer = st.session_state.users.get(kid)
            if kaeufer:
                kontakte.append({'name': kaeufer.name, 'telefon': '', 'rolle': 'K√§ufer'})

        for vid in projekt.verkaeufer_ids:
            verkaeufer = st.session_state.users.get(vid)
            if verkaeufer:
                kontakte.append({'name': verkaeufer.name, 'telefon': '', 'rolle': 'Verk√§ufer'})

        if projekt.notar_id:
            notar = st.session_state.users.get(projekt.notar_id)
            if notar:
                kontakte.append({'name': notar.name, 'telefon': '', 'rolle': 'Notar'})

        termin_id = f"termin_{len(st.session_state.termine)}"
        termin = Termin(
            termin_id=termin_id,
            projekt_id=projekt.projekt_id,
            termin_typ=termin_typ,
            datum=datum,
            uhrzeit_start=uhrzeit_start.strftime("%H:%M"),
            uhrzeit_ende=uhrzeit_ende.strftime("%H:%M"),
            tageszeit=tageszeit,
            ort=ort,
            beschreibung=beschreibung,
            status=TerminStatus.AUSSTEHEND.value,
            erstellt_von=st.session_state.current_user.user_id,
            kontakte=kontakte
        )

        st.session_state.termine[termin_id] = termin

        if termin_id not in projekt.termine:
            projekt.termine.append(termin_id)
            st.session_state.projekte[projekt.projekt_id] = projekt

        st.success("‚úÖ Termin wurde erstellt!")
        st.rerun()


# ============================================================================
# KALENDER-ANSICHT F√úR TERMINE
# ============================================================================

def get_termin_farbe(termin_typ: str) -> str:
    """Gibt die Farbe f√ºr einen Termin-Typ zur√ºck"""
    farben = {
        TerminTyp.BEURKUNDUNG.value: "#e74c3c",  # Rot - wichtig
        TerminTyp.BESICHTIGUNG.value: "#3498db",  # Blau
        TerminTyp.UEBERGABE.value: "#2ecc71",  # Gr√ºn
        TerminTyp.KAUFPREISFAELLIGKEIT.value: "#9b59b6",  # Lila
        TerminTyp.SCHLUESSELUEBERGABE.value: "#27ae60",  # Dunkelgr√ºn
        TerminTyp.DATENEINREICHUNG_FRIST.value: "#f39c12",  # Orange - Warnung
        TerminTyp.FINANZIERUNGSZUSAGE.value: "#1abc9c",  # T√ºrkis
        TerminTyp.GRUNDBUCHEINTRAG.value: "#34495e",  # Dunkelgrau
        TerminTyp.NOTARTERMIN_VORBESPRECHUNG.value: "#e67e22",  # Orange
        TerminTyp.WIDERRUFSENDE.value: "#c0392b",  # Dunkelrot
        TerminTyp.SONSTIGES.value: "#95a5a6",  # Grau
    }
    return farben.get(termin_typ, "#3498db")

def get_termin_icon(termin_typ: str) -> str:
    """Gibt das Icon f√ºr einen Termin-Typ zur√ºck"""
    icons = {
        TerminTyp.BEURKUNDUNG.value: "üìú",
        TerminTyp.BESICHTIGUNG.value: "üè†",
        TerminTyp.UEBERGABE.value: "üîë",
        TerminTyp.KAUFPREISFAELLIGKEIT.value: "üí∞",
        TerminTyp.SCHLUESSELUEBERGABE.value: "üóùÔ∏è",
        TerminTyp.DATENEINREICHUNG_FRIST.value: "üìã",
        TerminTyp.FINANZIERUNGSZUSAGE.value: "üè¶",
        TerminTyp.GRUNDBUCHEINTRAG.value: "üìñ",
        TerminTyp.NOTARTERMIN_VORBESPRECHUNG.value: "‚öñÔ∏è",
        TerminTyp.WIDERRUFSENDE.value: "‚è∞",
        TerminTyp.SONSTIGES.value: "üìÖ",
    }
    return icons.get(termin_typ, "üìÖ")

def check_und_sende_erinnerungen(user_id: str, user_rolle: str):
    """Pr√ºft und sendet automatische Erinnerungen f√ºr anstehende Termine"""
    heute = date.today()

    for termin_id, termin in st.session_state.termine.items():
        # Pr√ºfe ob User f√ºr diesen Termin relevant ist
        projekt = st.session_state.projekte.get(termin.projekt_id)
        if not projekt:
            continue

        # Pr√ºfe Sichtbarkeit
        if user_rolle not in termin.sichtbar_fuer:
            continue

        # Berechne Tage bis zum Termin
        tage_bis_termin = (termin.datum - heute).days

        # Pr√ºfe f√ºr jeden Erinnerungstag
        for tage_vorher in termin.erinnerung_tage_vorher:
            if tage_bis_termin == tage_vorher and tage_vorher not in termin.alle_erinnerungen_gesendet:
                # Sende Erinnerung
                if termin.termin_typ == TerminTyp.BEURKUNDUNG.value:
                    titel = f"üîî Reminder: Beurkundung in {tage_vorher} Tag{'en' if tage_vorher > 1 else ''}!"
                    nachricht = f"Morgen findet die Beurkundung f√ºr '{projekt.name}' statt. Bitte bereiten Sie alle erforderlichen Unterlagen vor."
                else:
                    titel = f"üîî Terminerinnerung: {termin.termin_typ}"
                    nachricht = f"In {tage_vorher} Tag{'en' if tage_vorher > 1 else ''}: {termin.termin_typ} f√ºr '{projekt.name}' am {termin.datum.strftime('%d.%m.%Y')} um {termin.uhrzeit_start} Uhr."

                # Erstelle Benachrichtigung f√ºr alle relevanten User
                empfaenger_ids = []

                if "K√§ufer" in termin.sichtbar_fuer:
                    empfaenger_ids.extend(projekt.kaeufer_ids)
                if "Verk√§ufer" in termin.sichtbar_fuer:
                    empfaenger_ids.extend(projekt.verkaeufer_ids)
                if "Makler" in termin.sichtbar_fuer and projekt.makler_id:
                    empfaenger_ids.append(projekt.makler_id)
                if "Notar" in termin.sichtbar_fuer and projekt.notar_id:
                    empfaenger_ids.append(projekt.notar_id)
                if "Finanzierer" in termin.sichtbar_fuer:
                    empfaenger_ids.extend(projekt.finanzierer_ids)

                for emp_id in set(empfaenger_ids):
                    create_notification(
                        user_id=emp_id,
                        titel=titel,
                        nachricht=nachricht,
                        typ=NotificationType.WARNING.value if tage_vorher <= 1 else NotificationType.INFO.value
                    )

                # Markiere als gesendet
                termin.alle_erinnerungen_gesendet[tage_vorher] = datetime.now()

def get_alle_termine_fuer_user(user_id: str, user_rolle: str) -> List['Termin']:
    """Holt alle relevanten Termine f√ºr einen User"""
    termine = []

    # Hole alle Projekte des Users
    user = st.session_state.users.get(user_id)
    if not user:
        return termine

    for projekt_id in user.projekt_ids:
        projekt = st.session_state.projekte.get(projekt_id)
        if not projekt:
            continue

        for termin_id in projekt.termine:
            termin = st.session_state.termine.get(termin_id)
            if termin and user_rolle in termin.sichtbar_fuer:
                termine.append(termin)

    # Sortiere nach Datum
    termine.sort(key=lambda t: (t.datum, t.uhrzeit_start))
    return termine

def render_kalender_monatsansicht(termine: List['Termin'], user_rolle: str, monat: int, jahr: int):
    """Rendert eine Monatsansicht des Kalenders"""
    import calendar

    # Kalender f√ºr den Monat
    cal = calendar.Calendar(firstweekday=0)  # Montag als erster Tag
    monatstage = cal.monthdayscalendar(jahr, monat)

    monatsnamen = ["", "Januar", "Februar", "M√§rz", "April", "Mai", "Juni",
                   "Juli", "August", "September", "Oktober", "November", "Dezember"]

    st.markdown(f"### üìÖ {monatsnamen[monat]} {jahr}")

    # Wochentags-Header
    wochentage = ["Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"]

    # CSS f√ºr Kalender
    st.markdown("""
    <style>
    .kalender-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 2px;
        margin-bottom: 20px;
    }
    .kalender-header {
        background: #2c3e50;
        color: white;
        padding: 8px;
        text-align: center;
        font-weight: bold;
        font-size: 12px;
    }
    .kalender-tag {
        background: #f8f9fa;
        min-height: 80px;
        padding: 5px;
        border: 1px solid #e0e0e0;
        font-size: 11px;
    }
    .kalender-tag.leer {
        background: #f0f0f0;
    }
    .kalender-tag.heute {
        background: #e3f2fd;
        border: 2px solid #2196f3;
    }
    .kalender-tag-nummer {
        font-weight: bold;
        margin-bottom: 5px;
    }
    .kalender-termin {
        padding: 2px 4px;
        border-radius: 3px;
        margin-bottom: 2px;
        font-size: 10px;
        color: white;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    </style>
    """, unsafe_allow_html=True)

    # Header
    header_html = '<div class="kalender-grid">'
    for tag in wochentage:
        header_html += f'<div class="kalender-header">{tag}</div>'
    header_html += '</div>'
    st.markdown(header_html, unsafe_allow_html=True)

    # Termine nach Datum gruppieren
    termine_nach_datum = {}
    for termin in termine:
        if termin.datum.month == monat and termin.datum.year == jahr:
            tag = termin.datum.day
            if tag not in termine_nach_datum:
                termine_nach_datum[tag] = []
            termine_nach_datum[tag].append(termin)

    # Kalender-Tage
    heute = date.today()
    kalender_html = '<div class="kalender-grid">'

    for woche in monatstage:
        for tag in woche:
            if tag == 0:
                kalender_html += '<div class="kalender-tag leer"></div>'
            else:
                ist_heute = (tag == heute.day and monat == heute.month and jahr == heute.year)
                klasse = "kalender-tag heute" if ist_heute else "kalender-tag"

                kalender_html += f'<div class="{klasse}">'
                kalender_html += f'<div class="kalender-tag-nummer">{tag}</div>'

                # Termine f√ºr diesen Tag
                if tag in termine_nach_datum:
                    for termin in termine_nach_datum[tag][:3]:  # Max 3 anzeigen
                        farbe = get_termin_farbe(termin.termin_typ)
                        icon = get_termin_icon(termin.termin_typ)
                        kalender_html += f'<div class="kalender-termin" style="background:{farbe};">{icon} {termin.uhrzeit_start}</div>'

                    if len(termine_nach_datum[tag]) > 3:
                        kalender_html += f'<div style="font-size:10px;color:#666;">+{len(termine_nach_datum[tag]) - 3} weitere</div>'

                kalender_html += '</div>'

    kalender_html += '</div>'
    st.markdown(kalender_html, unsafe_allow_html=True)

def render_kalender_listenansicht(termine: List['Termin'], user_rolle: str):
    """Rendert eine Listenansicht der kommenden Termine"""
    heute = date.today()

    # Filtere zuk√ºnftige Termine
    zukunft = [t for t in termine if t.datum >= heute]
    vergangen = [t for t in termine if t.datum < heute]

    if zukunft:
        st.markdown("### üìÜ Kommende Termine")

        for termin in zukunft[:10]:  # Max 10 anzeigen
            tage_bis = (termin.datum - heute).days
            projekt = st.session_state.projekte.get(termin.projekt_id)
            projekt_name = projekt.name if projekt else "Unbekanntes Projekt"

            farbe = get_termin_farbe(termin.termin_typ)
            icon = get_termin_icon(termin.termin_typ)

            # Dringlichkeits-Badge
            if tage_bis == 0:
                badge = "üî¥ HEUTE"
            elif tage_bis == 1:
                badge = "üü† MORGEN"
            elif tage_bis <= 7:
                badge = f"üü° in {tage_bis} Tagen"
            else:
                badge = f"in {tage_bis} Tagen"

            with st.container():
                col1, col2, col3 = st.columns([0.1, 0.6, 0.3])

                with col1:
                    st.markdown(f"""
                    <div style="background:{farbe}; color:white; padding:10px; border-radius:8px; text-align:center;">
                        <div style="font-size:24px;">{termin.datum.day}</div>
                        <div style="font-size:10px;">{termin.datum.strftime('%b')}</div>
                    </div>
                    """, unsafe_allow_html=True)

                with col2:
                    st.markdown(f"**{icon} {termin.termin_typ}**")
                    st.caption(f"üè† {projekt_name}")
                    st.caption(f"üïê {termin.uhrzeit_start} - {termin.uhrzeit_ende} Uhr")
                    if termin.ort:
                        st.caption(f"üìç {termin.ort}")

                with col3:
                    st.markdown(f"**{badge}**")
                    if termin.gesetzt_von_rolle:
                        st.caption(f"Von: {termin.gesetzt_von_rolle}")

                st.markdown("---")
    else:
        st.info("Keine kommenden Termine vorhanden.")

    # Vergangene Termine (eingeklappt)
    if vergangen:
        with st.expander(f"üìú Vergangene Termine ({len(vergangen)})", expanded=False):
            for termin in vergangen[-5:]:  # Letzte 5
                projekt = st.session_state.projekte.get(termin.projekt_id)
                projekt_name = projekt.name if projekt else "Unbekanntes Projekt"
                icon = get_termin_icon(termin.termin_typ)
                st.markdown(f"- {icon} **{termin.datum.strftime('%d.%m.%Y')}** - {termin.termin_typ} ({projekt_name})")

def render_termin_kalender(user_id: str, user_rolle: str, projekt_filter: str = "alle"):
    """Rendert den vollst√§ndigen Termin-Kalender"""

    # Erinnerungen pr√ºfen
    check_und_sende_erinnerungen(user_id, user_rolle)

    # Alle Termine holen
    alle_termine = get_alle_termine_fuer_user(user_id, user_rolle)

    # Projekt-Filter
    if projekt_filter != "alle":
        alle_termine = [t for t in alle_termine if t.projekt_id == projekt_filter]

    # Ansichts-Tabs
    ansicht = st.radio(
        "Ansicht",
        options=["üìã Liste", "üìÖ Monatskalender"],
        horizontal=True,
        key=f"kalender_ansicht_{user_id}"
    )

    if ansicht == "üìÖ Monatskalender":
        # Monat/Jahr Auswahl
        col1, col2 = st.columns(2)
        heute = date.today()

        with col1:
            monat = st.selectbox(
                "Monat",
                options=list(range(1, 13)),
                format_func=lambda m: ["", "Januar", "Februar", "M√§rz", "April", "Mai", "Juni",
                                       "Juli", "August", "September", "Oktober", "November", "Dezember"][m],
                index=heute.month - 1,
                key=f"kalender_monat_{user_id}"
            )
        with col2:
            jahr = st.selectbox(
                "Jahr",
                options=[heute.year - 1, heute.year, heute.year + 1],
                index=1,
                key=f"kalender_jahr_{user_id}"
            )

        render_kalender_monatsansicht(alle_termine, user_rolle, monat, jahr)

        # Legende
        with st.expander("üé® Legende", expanded=False):
            col1, col2 = st.columns(2)
            termin_typen = list(TerminTyp)
            mitte = len(termin_typen) // 2

            with col1:
                for typ in termin_typen[:mitte]:
                    farbe = get_termin_farbe(typ.value)
                    icon = get_termin_icon(typ.value)
                    st.markdown(f'<span style="background:{farbe};color:white;padding:2px 8px;border-radius:4px;">{icon} {typ.value}</span>', unsafe_allow_html=True)
            with col2:
                for typ in termin_typen[mitte:]:
                    farbe = get_termin_farbe(typ.value)
                    icon = get_termin_icon(typ.value)
                    st.markdown(f'<span style="background:{farbe};color:white;padding:2px 8px;border-radius:4px;">{icon} {typ.value}</span>', unsafe_allow_html=True)

    else:
        render_kalender_listenansicht(alle_termine, user_rolle)

    # Termine an diesem Tag Details
    st.markdown("---")
    st.markdown("### üìù Termin-Details")

    if alle_termine:
        termin_auswahl = st.selectbox(
            "Termin ausw√§hlen",
            options=alle_termine,
            format_func=lambda t: f"{t.datum.strftime('%d.%m.%Y')} - {get_termin_icon(t.termin_typ)} {t.termin_typ}",
            key=f"termin_detail_{user_id}"
        )

        if termin_auswahl:
            projekt = st.session_state.projekte.get(termin_auswahl.projekt_id)
            render_termin_card(termin_auswahl, projekt, user_rolle, context="kalender") if projekt else None
    else:
        st.info("Keine Termine zum Anzeigen vorhanden.")

def render_alle_termine(projekt: 'Projekt', user_rolle: str):
    """Zeigt alle Termine eines Projekts"""

    if not projekt.termine:
        st.info("Noch keine Termine vorhanden.")
        return

    for termin_id in projekt.termine:
        termin = st.session_state.termine.get(termin_id)
        if termin:
            render_termin_card(termin, projekt, user_rolle, context="alle")


def generate_expose_druckversion(expose: 'ExposeData') -> str:
    """
    Generiert eine druckbare HTML-Version des Expos√©s.
    Professionelles Layout f√ºr Druck und PDF-Export.
    """
    html = f"""<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expos√© - {expose.objekttitel}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }}
        .expose {{
            max-width: 900px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }}
        .header {{
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }}
        .header h1 {{
            font-size: 32px;
            margin-bottom: 15px;
        }}
        .preis {{
            font-size: 28px;
            background: rgba(255,255,255,0.2);
            display: inline-block;
            padding: 10px 30px;
            border-radius: 30px;
            margin-top: 10px;
        }}
        .content {{
            padding: 40px;
        }}
        .section {{
            margin-bottom: 30px;
        }}
        .section h2 {{
            color: #1a365d;
            border-bottom: 2px solid #2c5282;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }}
        .grid {{
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }}
        .data-item {{
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }}
        .data-item .label {{
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }}
        .data-item .value {{
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }}
        .beschreibung {{
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            border-left: 4px solid #2c5282;
        }}
        .energie-badge {{
            display: inline-block;
            padding: 5px 15px;
            background: #48bb78;
            color: white;
            border-radius: 20px;
            font-weight: bold;
        }}
        .kosten-tabelle {{
            width: 100%;
            border-collapse: collapse;
        }}
        .kosten-tabelle td {{
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
        }}
        .kosten-tabelle td:first-child {{
            color: #666;
        }}
        .kosten-tabelle td:last-child {{
            text-align: right;
            font-weight: 600;
        }}
        .footer {{
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            font-size: 12px;
            color: #666;
        }}
        @media print {{
            body {{
                background: white;
                padding: 0;
            }}
            .expose {{
                box-shadow: none;
            }}
        }}
    </style>
</head>
<body>
    <div class="expose">
        <div class="header">
            <h1>{expose.objekttitel}</h1>
            <p>{expose.strasse} {expose.hausnummer}, {expose.plz} {expose.ort}</p>
            <div class="preis">{format_euro(expose.kaufpreis)} ‚Ç¨</div>
        </div>

        <div class="content">
            <div class="section">
                <h2>üìã Objektdaten</h2>
                <div class="grid">
                    <div class="data-item">
                        <div class="label">Objektart</div>
                        <div class="value">{expose.objektart}</div>
                    </div>
                    <div class="data-item">
                        <div class="label">Wohnfl√§che</div>
                        <div class="value">{expose.wohnflaeche} m¬≤</div>
                    </div>
                    <div class="data-item">
                        <div class="label">Zimmer</div>
                        <div class="value">{expose.anzahl_zimmer}</div>
                    </div>
                    <div class="data-item">
                        <div class="label">Baujahr</div>
                        <div class="value">{expose.baujahr if expose.baujahr > 0 else 'N/A'}</div>
                    </div>
                    <div class="data-item">
                        <div class="label">Etage</div>
                        <div class="value">{expose.etage if expose.etage else 'N/A'}</div>
                    </div>
                    <div class="data-item">
                        <div class="label">Zustand</div>
                        <div class="value">{expose.zustand if expose.zustand else 'N/A'}</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üìù Objektbeschreibung</h2>
                <div class="beschreibung">
                    <p>{expose.objektbeschreibung or 'Keine Beschreibung verf√ºgbar.'}</p>
                </div>
            </div>

            <div class="section">
                <h2>‚ö° Energieausweis</h2>
                <div class="grid">
                    <div class="data-item">
                        <div class="label">Effizienzklasse</div>
                        <div class="value"><span class="energie-badge">{expose.energieeffizienzklasse or 'N/A'}</span></div>
                    </div>
                    <div class="data-item">
                        <div class="label">Endenergieverbrauch</div>
                        <div class="value">{expose.endenergieverbrauch} kWh/m¬≤a</div>
                    </div>
                    <div class="data-item">
                        <div class="label">Wesentlicher Energietr√§ger</div>
                        <div class="value">{expose.wesentlicher_energietraeger or 'N/A'}</div>
                    </div>
                    <div class="data-item">
                        <div class="label">Ausweistyp</div>
                        <div class="value">{expose.energieausweis_typ or 'N/A'}</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üí∞ Kosten</h2>
                <table class="kosten-tabelle">
                    <tr>
                        <td>Kaufpreis</td>
                        <td>{format_euro(expose.kaufpreis)} ‚Ç¨</td>
                    </tr>
                    <tr>
                        <td>Hausgeld (monatlich)</td>
                        <td>{format_euro(expose.hausgeld)} ‚Ç¨</td>
                    </tr>
                    <tr>
                        <td>Grundsteuer (j√§hrlich)</td>
                        <td>{format_euro(expose.grundsteuer)} ‚Ç¨</td>
                    </tr>
                    <tr>
                        <td>Provision</td>
                        <td>{expose.provision or 'N/A'}</td>
                    </tr>
                </table>
            </div>

            {"<div class='section'><h2>üìç Lagebeschreibung</h2><div class='beschreibung'><p>" + expose.lagebeschreibung + "</p></div></div>" if expose.lagebeschreibung else ""}

            {"<div class='section'><h2>üè† Ausstattung</h2><div class='beschreibung'><p>" + expose.ausstattung + "</p></div></div>" if expose.ausstattung else ""}
        </div>

        <div class="footer">
            <p>Dieses Expos√© wurde √ºber die Immobilien-Transaktionsplattform erstellt.</p>
            <p>Erstellt am {datetime.now().strftime('%d.%m.%Y')}</p>
        </div>
    </div>

    <script>
        // Zum Drucken: window.print();
    </script>
</body>
</html>"""

    return html


def render_expose_editor(projekt: Projekt):
    """Rendert den Expos√©-Editor f√ºr ein Projekt"""

    # Expose-Daten suchen oder erstellen
    expose = None
    if projekt.expose_data_id:
        expose = st.session_state.expose_data.get(projekt.expose_data_id)

    if not expose:
        expose_id = f"expose_{len(st.session_state.expose_data)}"
        expose = ExposeData(
            expose_id=expose_id,
            projekt_id=projekt.projekt_id,
            objekttitel=projekt.name,
            objektbeschreibung=projekt.beschreibung,
            kaufpreis=projekt.kaufpreis
        )
        st.session_state.expose_data[expose_id] = expose
        projekt.expose_data_id = expose_id
        st.session_state.projekte[projekt.projekt_id] = projekt

    st.markdown("### üìÑ Expos√©-Daten bearbeiten")

    # Objektart ausw√§hlen
    property_type = st.selectbox(
        "Objektart*",
        options=[t.value for t in PropertyType],
        index=[t.value for t in PropertyType].index(expose.objektart) if expose.objektart else 0,
        key=f"expose_property_type_{expose.expose_id}"
    )

    # ===== ADRESSE MIT VALIDIERUNG =====
    st.markdown("#### Adresse")
    col1, col2, col3 = st.columns([3, 1, 2])
    with col1:
        strasse = st.text_input("Stra√üe*", value=expose.strasse, key=f"expose_strasse_{expose.expose_id}")
    with col2:
        hausnummer = st.text_input("Nr.*", value=expose.hausnummer, key=f"expose_hausnr_{expose.expose_id}")
    with col3:
        plz = st.text_input("PLZ*", value=expose.plz, key=f"expose_plz_{expose.expose_id}")

    col1, col2 = st.columns(2)
    with col1:
        ort = st.text_input("Ort*", value=expose.ort, key=f"expose_ort_{expose.expose_id}")
    with col2:
        land = st.text_input("Land", value=expose.land if expose.land else "Deutschland", key=f"expose_land_{expose.expose_id}")

    # Adress-Validierung Button
    col1, col2 = st.columns([1, 3])
    with col1:
        if st.button("Adresse pr√ºfen", key=f"validate_addr_{expose.expose_id}"):
            if strasse and plz and ort:
                with st.spinner("Validiere Adresse..."):
                    result = validate_address_online(strasse, hausnummer, plz, ort, land)
                    st.session_state[f"addr_validation_{expose.expose_id}"] = result
            else:
                st.warning("Bitte Stra√üe, PLZ und Ort eingeben.")

    with col2:
        # Validierungsergebnis anzeigen
        validation_result = st.session_state.get(f"addr_validation_{expose.expose_id}")
        if validation_result:
            if validation_result.get('gefunden'):
                if validation_result.get('abweichung'):
                    st.warning(f"Abweichung gefunden! Vorschlag: {validation_result.get('display_name', '')}")
                    if st.button("Vorschlag √ºbernehmen", key=f"accept_addr_{expose.expose_id}"):
                        expose.strasse = validation_result.get('strasse', strasse)
                        expose.hausnummer = validation_result.get('hausnummer', hausnummer)
                        expose.plz = validation_result.get('plz', plz)
                        expose.ort = validation_result.get('ort', ort)
                        expose.adresse_validiert = True
                        st.session_state.expose_data[expose.expose_id] = expose
                        st.rerun()
                else:
                    st.success("Adresse validiert!")
                    expose.adresse_validiert = True
            else:
                st.error(validation_result.get('nachricht', 'Adresse nicht gefunden'))

    # ===== NUTZUNGSART =====
    st.markdown("#### Nutzungsart / Erlaubnisse")
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        nutzungsart = st.selectbox(
            "Hauptnutzung",
            options=["Keine Angabe", "Dauerwohnen", "Ferienvermietung", "Zweitwohnung", "Gemischt"],
            index=["Keine Angabe", "Dauerwohnen", "Ferienvermietung", "Zweitwohnung", "Gemischt"].index(expose.nutzungsart) if expose.nutzungsart in ["Keine Angabe", "Dauerwohnen", "Ferienvermietung", "Zweitwohnung", "Gemischt"] else 0,
            key=f"expose_nutzung_{expose.expose_id}"
        )
    with col2:
        ferienvermietung_erlaubt = st.selectbox(
            "Ferienvermietung erlaubt?",
            options=["Keine Angabe", "Ja", "Nein"],
            index=["Keine Angabe", "Ja", "Nein"].index(expose.ferienvermietung_erlaubt) if expose.ferienvermietung_erlaubt in ["Keine Angabe", "Ja", "Nein"] else 0,
            key=f"expose_ferien_{expose.expose_id}"
        )
    with col3:
        dauerwohnen_erlaubt = st.selectbox(
            "Dauerwohnen erlaubt?",
            options=["Keine Angabe", "Ja", "Nein"],
            index=["Keine Angabe", "Ja", "Nein"].index(expose.dauerwohnen_erlaubt) if expose.dauerwohnen_erlaubt in ["Keine Angabe", "Ja", "Nein"] else 0,
            key=f"expose_dauer_{expose.expose_id}"
        )
    with col4:
        zweitwohnung_erlaubt = st.selectbox(
            "Zweitwohnung erlaubt?",
            options=["Keine Angabe", "Ja", "Nein"],
            index=["Keine Angabe", "Ja", "Nein"].index(expose.zweitwohnung_erlaubt) if expose.zweitwohnung_erlaubt in ["Keine Angabe", "Ja", "Nein"] else 0,
            key=f"expose_zweit_{expose.expose_id}"
        )

    # Basis-Informationen
    st.markdown("#### Basis-Informationen")
    col1, col2 = st.columns(2)
    with col1:
        objekttitel = st.text_input("Objekt-Titel*", value=expose.objekttitel, key=f"expose_titel_{expose.expose_id}")
        lage_beschreibung = st.text_area("Lage-Beschreibung", value=expose.lage_beschreibung, height=100, key=f"expose_lage_{expose.expose_id}")
    with col2:
        objektbeschreibung = st.text_area("Objekt-Beschreibung*", value=expose.objektbeschreibung, height=100, key=f"expose_beschr_{expose.expose_id}")
        ausstattung = st.text_area("Ausstattung", value=expose.ausstattung, height=100, key=f"expose_ausst_{expose.expose_id}")

    # Objektdaten
    st.markdown("#### Objektdaten")
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        wohnflaeche = st.number_input("Wohnfl√§che (m¬≤)", value=float(expose.wohnflaeche), min_value=0.0, step=1.0, key=f"expose_wfl_{expose.expose_id}")
        anzahl_zimmer = st.number_input("Anzahl Zimmer", value=float(expose.anzahl_zimmer), min_value=0.0, step=0.5, key=f"expose_zim_{expose.expose_id}")
    with col2:
        grundstuecksflaeche = st.number_input("Grundst√ºcksfl√§che (m¬≤)", value=float(expose.grundstuecksflaeche), min_value=0.0, step=1.0, key=f"expose_gfl_{expose.expose_id}")
        anzahl_schlafzimmer = st.number_input("Schlafzimmer", value=expose.anzahl_schlafzimmer, min_value=0, step=1, key=f"expose_schlaf_{expose.expose_id}")
    with col3:
        anzahl_badezimmer = st.number_input("Badezimmer", value=expose.anzahl_badezimmer, min_value=0, step=1, key=f"expose_bad_{expose.expose_id}")
        anzahl_etagen = st.number_input("Anzahl Etagen", value=expose.anzahl_etagen, min_value=0, step=1, key=f"expose_etagen_{expose.expose_id}")
    with col4:
        etage = st.text_input("Etage", value=expose.etage, key=f"expose_etage_{expose.expose_id}")
        baujahr = st.number_input("Baujahr", value=expose.baujahr if expose.baujahr > 0 else 2020, min_value=1800, max_value=2030, step=1, key=f"expose_bj_{expose.expose_id}")

    col1, col2 = st.columns(2)
    with col1:
        zustand = st.selectbox("Zustand", options=["", "Erstbezug", "Neuwertig", "Renoviert", "Gepflegt", "Sanierungsbed√ºrftig"], index=0 if not expose.zustand else ["", "Erstbezug", "Neuwertig", "Renoviert", "Gepflegt", "Sanierungsbed√ºrftig"].index(expose.zustand) if expose.zustand in ["", "Erstbezug", "Neuwertig", "Renoviert", "Gepflegt", "Sanierungsbed√ºrftig"] else 0, key=f"expose_zust_{expose.expose_id}")
    with col2:
        verfuegbar_ab = st.date_input("Verf√ºgbar ab", value=expose.verfuegbar_ab if expose.verfuegbar_ab else date.today(), key=f"expose_verf_{expose.expose_id}")

    # Preise und Kosten
    st.markdown("#### Preise und Kosten")

    # Kaufpreis-Vorschlag berechnen (auf Basis der bisherigen Daten)
    # Aktualisiere expose tempor√§r f√ºr Vorschlagsberechnung
    temp_expose = ExposeData(
        expose_id="temp",
        projekt_id="temp",
        objektart=property_type,
        wohnflaeche=expose.wohnflaeche,
        grundstuecksflaeche=expose.grundstuecksflaeche,
        baujahr=expose.baujahr,
        zustand=expose.zustand,
        hat_meerblick=expose.hat_meerblick,
        hat_fahrstuhl=expose.hat_fahrstuhl,
        hat_balkon=expose.hat_balkon,
        hat_terrasse=expose.hat_terrasse,
        hat_garage=expose.hat_garage,
        hat_tiefgarage=expose.hat_tiefgarage,
        hat_schwimmbad=expose.hat_schwimmbad,
        hat_gemeinschaftspool=expose.hat_gemeinschaftspool,
        energieeffizienzklasse=expose.energieeffizienzklasse
    )
    preis_vorschlag = calculate_price_suggestion(temp_expose)

    col1, col2, col3, col4 = st.columns(4)
    with col1:
        kaufpreis = st.number_input("Kaufpreis (‚Ç¨)*", value=float(expose.kaufpreis), min_value=0.0, step=1000.0, key=f"expose_kp_{expose.expose_id}")
        # Preis-Vorschlag anzeigen
        if preis_vorschlag > 0:
            diff = kaufpreis - preis_vorschlag
            diff_prozent = (diff / preis_vorschlag * 100) if preis_vorschlag > 0 else 0
            if diff_prozent > 10:
                st.warning(f"Vorschlag: {format_euro(preis_vorschlag, 0)} ‚Ç¨ (+{diff_prozent:.1f}% √ºber Markt)")
            elif diff_prozent < -10:
                st.info(f"Vorschlag: {format_euro(preis_vorschlag, 0)} ‚Ç¨ ({diff_prozent:.1f}% unter Markt)")
            else:
                st.success(f"Vorschlag: {format_euro(preis_vorschlag, 0)} ‚Ç¨ (marktgerecht)")
    with col2:
        provision = st.text_input("Provision", value=expose.provision, placeholder="z.B. 3,57% inkl. MwSt.", key=f"expose_prov_{expose.expose_id}")
    with col3:
        hausgeld = st.number_input("Hausgeld (‚Ç¨/Monat)", value=float(expose.hausgeld), min_value=0.0, step=10.0, key=f"expose_hg_{expose.expose_id}")
    with col4:
        grundsteuer = st.number_input("Grundsteuer (‚Ç¨/Jahr)", value=float(expose.grundsteuer), min_value=0.0, step=10.0, key=f"expose_gst_{expose.expose_id}")

    # WEG-spezifisch (nur f√ºr Wohnungen)
    if property_type == PropertyType.WOHNUNG.value:
        st.markdown("#### WEG-Daten (Wohnungseigent√ºmergemeinschaft)")
        col1, col2 = st.columns(2)
        with col1:
            weg_verwaltung = st.text_input("WEG-Verwaltung", value=expose.weg_verwaltung, key=f"expose_weg_{expose.expose_id}")
        with col2:
            ruecklage = st.number_input("R√ºcklage (‚Ç¨)", value=float(expose.ruecklage), min_value=0.0, step=100.0, key=f"expose_rl_{expose.expose_id}")

    # Energieausweis
    st.markdown("#### Energieausweis")
    col1, col2, col3 = st.columns(3)
    with col1:
        energieausweis_typ = st.selectbox("Typ", options=["", "Verbrauch", "Bedarf"], index=0 if not expose.energieausweis_typ else ["", "Verbrauch", "Bedarf"].index(expose.energieausweis_typ) if expose.energieausweis_typ in ["", "Verbrauch", "Bedarf"] else 0, key=f"expose_ea_typ_{expose.expose_id}")
        endenergieverbrauch = st.number_input("Endenergieverbrauch (kWh/m¬≤a)", value=float(expose.endenergieverbrauch), min_value=0.0, step=1.0, key=f"expose_eev_{expose.expose_id}")
    with col2:
        energieeffizienzklasse = st.selectbox("Energieeffizienzklasse", options=["", "A+", "A", "B", "C", "D", "E", "F", "G", "H"], index=0 if not expose.energieeffizienzklasse else ["", "A+", "A", "B", "C", "D", "E", "F", "G", "H"].index(expose.energieeffizienzklasse) if expose.energieeffizienzklasse in ["", "A+", "A", "B", "C", "D", "E", "F", "G", "H"] else 0, key=f"expose_eek_{expose.expose_id}")
        baujahr_energieausweis = st.number_input("Baujahr Energieausweis", value=expose.baujahr_energieausweis if expose.baujahr_energieausweis > 0 else 2020, min_value=1990, max_value=2030, step=1, key=f"expose_ea_bj_{expose.expose_id}")
    with col3:
        wesentliche_energietraeger = st.text_input("Wesentliche Energietr√§ger", value=expose.wesentliche_energietraeger, placeholder="z.B. Gas, Fernw√§rme", key=f"expose_et_{expose.expose_id}")
        gueltig_bis = st.date_input("G√ºltig bis", value=expose.gueltig_bis if expose.gueltig_bis else date.today(), key=f"expose_gb_{expose.expose_id}")

    # ===== AUSSTATTUNGSMERKMALE =====
    st.markdown("#### Ausstattungsmerkmale")
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        hat_balkon = st.checkbox("Balkon", value=expose.hat_balkon, key=f"expose_balkon_{expose.expose_id}")
        hat_terrasse = st.checkbox("Terrasse", value=expose.hat_terrasse, key=f"expose_terrasse_{expose.expose_id}")
        hat_garten = st.checkbox("Garten", value=expose.hat_garten, key=f"expose_garten_{expose.expose_id}")
        hat_fahrstuhl = st.checkbox("Fahrstuhl", value=expose.hat_fahrstuhl, key=f"expose_fahrstuhl_{expose.expose_id}")
    with col2:
        hat_garage = st.checkbox("Garage", value=expose.hat_garage, key=f"expose_garage_{expose.expose_id}")
        hat_tiefgarage = st.checkbox("Tiefgarage", value=expose.hat_tiefgarage, key=f"expose_tiefgarage_{expose.expose_id}")
        hat_stellplatz = st.checkbox("Stellplatz", value=expose.hat_stellplatz, key=f"expose_stellplatz_{expose.expose_id}")
        nichtraucher = st.checkbox("Nichtraucher-Objekt", value=expose.nichtraucher, key=f"expose_nichtraucher_{expose.expose_id}")
    with col3:
        hat_sauna = st.checkbox("Sauna (privat)", value=expose.hat_sauna, key=f"expose_sauna_{expose.expose_id}")
        hat_gemeinschaftssauna = st.checkbox("Gemeinschafts-Sauna", value=expose.hat_gemeinschaftssauna, key=f"expose_gem_sauna_{expose.expose_id}")
        hat_schwimmbad = st.checkbox("Schwimmbad (privat)", value=expose.hat_schwimmbad, key=f"expose_pool_{expose.expose_id}")
        hat_gemeinschaftspool = st.checkbox("Gemeinschafts-Pool", value=expose.hat_gemeinschaftspool, key=f"expose_gem_pool_{expose.expose_id}")
    with col4:
        hat_meerblick = st.checkbox("Meerblick", value=expose.hat_meerblick, key=f"expose_meerblick_{expose.expose_id}")
        hat_bergblick = st.checkbox("Bergblick", value=expose.hat_bergblick, key=f"expose_bergblick_{expose.expose_id}")
        hat_seeblick = st.checkbox("Seeblick", value=expose.hat_seeblick, key=f"expose_seeblick_{expose.expose_id}")
        haustiere_erlaubt = st.selectbox(
            "Haustiere erlaubt?",
            options=["Keine Angabe", "Ja", "Nein", "Auf Anfrage"],
            index=["Keine Angabe", "Ja", "Nein", "Auf Anfrage"].index(expose.haustiere_erlaubt) if expose.haustiere_erlaubt in ["Keine Angabe", "Ja", "Nein", "Auf Anfrage"] else 0,
            key=f"expose_tiere_{expose.expose_id}"
        )

    # ===== ENTFERNUNGEN =====
    st.markdown("#### Entfernungen")
    col1, col2, col3 = st.columns(3)
    with col1:
        entfernung_strand_m = st.number_input("Strand (Meter)", value=expose.entfernung_strand_m, min_value=0, step=50, key=f"expose_strand_{expose.expose_id}")
        entfernung_zentrum_m = st.number_input("Ortszentrum (Meter)", value=expose.entfernung_zentrum_m, min_value=0, step=50, key=f"expose_zentrum_{expose.expose_id}")
    with col2:
        entfernung_stadt_m = st.number_input("N√§chste Stadt (Meter)", value=expose.entfernung_stadt_m, min_value=0, step=100, key=f"expose_stadt_{expose.expose_id}")
        entfernung_supermarkt_m = st.number_input("Supermarkt (Meter)", value=expose.entfernung_supermarkt_m, min_value=0, step=50, key=f"expose_supermarkt_{expose.expose_id}")
    with col3:
        entfernung_arzt_m = st.number_input("Arzt/Apotheke (Meter)", value=expose.entfernung_arzt_m, min_value=0, step=50, key=f"expose_arzt_{expose.expose_id}")
        entfernung_flughafen_km = st.number_input("Flughafen (km)", value=expose.entfernung_flughafen_km, min_value=0, step=5, key=f"expose_flughafen_{expose.expose_id}")

    # Besonderheiten (Freitext f√ºr Sonstiges)
    st.markdown("#### Sonstige Besonderheiten")
    besonderheiten = st.text_area("Weitere Besonderheiten", value=expose.besonderheiten, height=100, placeholder="z.B. Dachterrasse, Kamin, Smart Home, etc.", key=f"expose_bes_{expose.expose_id}")

    # ===== MARKTANALYSE MIT VERGLEICHSOBJEKTEN =====
    st.markdown("#### üìä Marktanalyse - Vergleichsobjekte")
    st.caption("F√ºgen Sie Links zu vergleichbaren Objekten hinzu, um die Preisfindung zu unterst√ºtzen.")

    # Bestehende Vergleichsobjekte anzeigen
    if expose.vergleichsobjekte:
        for i, vgl in enumerate(expose.vergleichsobjekte):
            col1, col2, col3, col4 = st.columns([3, 2, 2, 1])
            with col1:
                st.markdown(f"[{vgl.get('titel', 'Vergleichsobjekt')}]({vgl.get('url', '#')})")
            with col2:
                st.write(f"{format_euro(vgl.get('preis', 0), 0)} ‚Ç¨")
            with col3:
                st.write(f"{vgl.get('flaeche', 0)} m¬≤ ‚Ä¢ {vgl.get('zimmer', 0)} Zi.")
            with col4:
                if st.button("üóëÔ∏è", key=f"del_vgl_{expose.expose_id}_{i}"):
                    expose.vergleichsobjekte.pop(i)
                    st.session_state.expose_data[expose.expose_id] = expose
                    st.rerun()

    # Neues Vergleichsobjekt hinzuf√ºgen
    with st.expander("‚ûï Vergleichsobjekt hinzuf√ºgen"):
        vgl_col1, vgl_col2 = st.columns(2)
        with vgl_col1:
            vgl_titel = st.text_input("Titel", placeholder="z.B. Sch√∂ne 3-Zi-Wohnung", key=f"vgl_titel_{expose.expose_id}")
            vgl_url = st.text_input("URL zum Inserat", placeholder="https://www.immobilienscout24.de/...", key=f"vgl_url_{expose.expose_id}")
        with vgl_col2:
            vgl_preis = st.number_input("Preis (‚Ç¨)", min_value=0.0, step=1000.0, key=f"vgl_preis_{expose.expose_id}")
            vgl_col2a, vgl_col2b = st.columns(2)
            with vgl_col2a:
                vgl_flaeche = st.number_input("Fl√§che (m¬≤)", min_value=0.0, step=1.0, key=f"vgl_flaeche_{expose.expose_id}")
            with vgl_col2b:
                vgl_zimmer = st.number_input("Zimmer", min_value=0.0, step=0.5, key=f"vgl_zimmer_{expose.expose_id}")

        vgl_notiz = st.text_input("Notiz (optional)", placeholder="z.B. √Ñhnliche Lage, bessere Ausstattung", key=f"vgl_notiz_{expose.expose_id}")

        if st.button("Vergleichsobjekt hinzuf√ºgen", key=f"add_vgl_{expose.expose_id}"):
            if vgl_url:
                neues_vgl = {
                    'titel': vgl_titel if vgl_titel else "Vergleichsobjekt",
                    'url': vgl_url,
                    'preis': vgl_preis,
                    'flaeche': vgl_flaeche,
                    'zimmer': vgl_zimmer,
                    'notiz': vgl_notiz,
                    'hinzugefuegt_am': datetime.now().isoformat()
                }
                if not expose.vergleichsobjekte:
                    expose.vergleichsobjekte = []
                expose.vergleichsobjekte.append(neues_vgl)
                st.session_state.expose_data[expose.expose_id] = expose
                st.success("‚úÖ Vergleichsobjekt hinzugef√ºgt!")
                st.rerun()
            else:
                st.warning("Bitte geben Sie mindestens eine URL ein.")

    # Marktvergleich-Zusammenfassung anzeigen
    if expose.vergleichsobjekte and len(expose.vergleichsobjekte) >= 2:
        preise = [v.get('preis', 0) for v in expose.vergleichsobjekte if v.get('preis', 0) > 0]
        flaechen = [v.get('flaeche', 0) for v in expose.vergleichsobjekte if v.get('flaeche', 0) > 0]

        if preise and flaechen:
            avg_preis = sum(preise) / len(preise)
            avg_flaeche = sum(flaechen) / len(flaechen)
            avg_qm_preis = avg_preis / avg_flaeche if avg_flaeche > 0 else 0

            st.info(f"""
            **Marktvergleich ({len(expose.vergleichsobjekte)} Objekte):**
            - √ò Preis: {format_euro(avg_preis, 0)} ‚Ç¨
            - √ò Fl√§che: {avg_flaeche:.0f} m¬≤
            - √ò Preis/m¬≤: {format_euro(avg_qm_preis, 0)} ‚Ç¨
            """)

            # Vergleich mit eigenem Objekt
            if expose.kaufpreis > 0 and expose.wohnflaeche > 0:
                eigener_qm_preis = expose.kaufpreis / expose.wohnflaeche
                diff_prozent = ((eigener_qm_preis - avg_qm_preis) / avg_qm_preis * 100) if avg_qm_preis > 0 else 0

                if diff_prozent > 5:
                    st.warning(f"Ihr Objekt: {format_euro(eigener_qm_preis, 0)} ‚Ç¨/m¬≤ (+{diff_prozent:.1f}% √ºber Markt)")
                elif diff_prozent < -5:
                    st.success(f"Ihr Objekt: {format_euro(eigener_qm_preis, 0)} ‚Ç¨/m¬≤ ({diff_prozent:.1f}% unter Markt)")
                else:
                    st.success(f"Ihr Objekt: {format_euro(eigener_qm_preis, 0)} ‚Ç¨/m¬≤ (marktgerecht)")

    # Bilder
    st.markdown("#### Bilder und Dokumente")
    col1, col2 = st.columns(2)
    with col1:
        titelbild = st.file_uploader("Titelbild", type=["png", "jpg", "jpeg"], key=f"expose_titelbild_{expose.expose_id}")
        if expose.titelbild:
            st.image(expose.titelbild, width=200, caption="Aktuelles Titelbild")
        elif titelbild:
            st.image(titelbild, width=200)
    with col2:
        weitere_bilder = st.file_uploader("Weitere Bilder", type=["png", "jpg", "jpeg"], accept_multiple_files=True, key=f"expose_bilder_{expose.expose_id}")
        if expose.weitere_bilder:
            st.write(f"Bereits {len(expose.weitere_bilder)} Bilder hochgeladen")

    grundrisse = st.file_uploader("Grundrisse", type=["png", "jpg", "jpeg", "pdf"], accept_multiple_files=True, key=f"expose_grundrisse_{expose.expose_id}")
    if expose.grundrisse:
        st.write(f"Bereits {len(expose.grundrisse)} Grundrisse hochgeladen")

    lageplan = st.file_uploader("Lageplan", type=["png", "jpg", "jpeg", "pdf"], key=f"expose_lageplan_{expose.expose_id}")

    # Speichern
    col1, col2, col3 = st.columns(3)
    with col1:
        if st.button("üíæ Expos√© speichern", key=f"expose_save_{expose.expose_id}", type="primary"):
            # Alle Daten aktualisieren
            expose.objektart = property_type
            expose.objekttitel = objekttitel
            expose.objektbeschreibung = objektbeschreibung
            expose.lage_beschreibung = lage_beschreibung
            expose.ausstattung = ausstattung

            expose.wohnflaeche = wohnflaeche
            expose.grundstuecksflaeche = grundstuecksflaeche
            expose.anzahl_zimmer = anzahl_zimmer
            expose.anzahl_schlafzimmer = anzahl_schlafzimmer
            expose.anzahl_badezimmer = anzahl_badezimmer
            expose.anzahl_etagen = anzahl_etagen
            expose.etage = etage
            expose.baujahr = baujahr
            expose.zustand = zustand
            expose.verfuegbar_ab = verfuegbar_ab

            expose.kaufpreis = kaufpreis
            expose.provision = provision
            expose.hausgeld = hausgeld
            expose.grundsteuer = grundsteuer

            if property_type == PropertyType.WOHNUNG.value:
                expose.weg_verwaltung = weg_verwaltung
                expose.ruecklage = ruecklage

            expose.energieausweis_typ = energieausweis_typ
            expose.energieeffizienzklasse = energieeffizienzklasse
            expose.endenergieverbrauch = endenergieverbrauch
            expose.wesentliche_energietraeger = wesentliche_energietraeger
            expose.baujahr_energieausweis = baujahr_energieausweis
            expose.gueltig_bis = gueltig_bis

            expose.besonderheiten = besonderheiten

            # Bilder verarbeiten
            if titelbild:
                expose.titelbild = titelbild.read()
            if weitere_bilder:
                expose.weitere_bilder = [img.read() for img in weitere_bilder]
            if grundrisse:
                expose.grundrisse = [gr.read() for gr in grundrisse]
            if lageplan:
                expose.lageplan = lageplan.read()

            # Neue Felder: Adresse
            expose.strasse = strasse
            expose.hausnummer = hausnummer
            expose.plz = plz
            expose.ort = ort
            expose.land = land

            # Neue Felder: Nutzungsart
            expose.nutzungsart = nutzungsart
            expose.ferienvermietung_erlaubt = ferienvermietung_erlaubt
            expose.dauerwohnen_erlaubt = dauerwohnen_erlaubt
            expose.zweitwohnung_erlaubt = zweitwohnung_erlaubt

            # Neue Felder: Ausstattungsmerkmale
            expose.hat_balkon = hat_balkon
            expose.hat_terrasse = hat_terrasse
            expose.hat_garten = hat_garten
            expose.hat_garage = hat_garage
            expose.hat_tiefgarage = hat_tiefgarage
            expose.hat_stellplatz = hat_stellplatz
            expose.hat_sauna = hat_sauna
            expose.hat_gemeinschaftssauna = hat_gemeinschaftssauna
            expose.hat_schwimmbad = hat_schwimmbad
            expose.hat_gemeinschaftspool = hat_gemeinschaftspool
            expose.hat_fahrstuhl = hat_fahrstuhl
            expose.hat_meerblick = hat_meerblick
            expose.hat_bergblick = hat_bergblick
            expose.hat_seeblick = hat_seeblick
            expose.nichtraucher = nichtraucher
            expose.haustiere_erlaubt = haustiere_erlaubt

            # Neue Felder: Entfernungen
            expose.entfernung_strand_m = entfernung_strand_m
            expose.entfernung_zentrum_m = entfernung_zentrum_m
            expose.entfernung_stadt_m = entfernung_stadt_m
            expose.entfernung_supermarkt_m = entfernung_supermarkt_m
            expose.entfernung_arzt_m = entfernung_arzt_m
            expose.entfernung_flughafen_km = entfernung_flughafen_km

            expose.updated_at = datetime.now()

            # Speichern
            st.session_state.expose_data[expose.expose_id] = expose
            projekt.property_type = property_type
            st.session_state.projekte[projekt.projekt_id] = projekt

            st.success("‚úÖ Expos√© erfolgreich gespeichert!")
            # Nicht mehr return True - damit die anderen Buttons sichtbar bleiben
            st.session_state[f"expose_saved_{expose.expose_id}"] = True

    with col2:
        if st.button("üìÑ Web-Expos√© Vorschau", key=f"expose_preview_{expose.expose_id}"):
            st.session_state[f"show_web_preview_{expose.expose_id}"] = True

    with col3:
        if st.button("üì• PDF generieren", key=f"expose_pdf_{expose.expose_id}"):
            st.info("PDF-Generierung w√ºrde hier mit reportlab/weasyprint erfolgen")

    # Web-Expos√© Vorschau
    if st.session_state.get(f"show_web_preview_{expose.expose_id}", False):
        st.markdown("---")
        st.markdown("### üåê Web-Expos√© Vorschau")

        # Simpler HTML-basierter Expos√©-Preview
        preview_html = f"""
        <div style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background: white; border: 1px solid #ddd;">
            <h1 style="color: #333;">{expose.objekttitel}</h1>
            <p style="font-size: 1.2em; color: #e74c3c;"><strong>Kaufpreis: {format_euro(expose.kaufpreis)} ‚Ç¨</strong></p>

            <h2>Objektbeschreibung</h2>
            <p>{expose.objektbeschreibung}</p>

            <h2>Objektdaten</h2>
            <table style="width: 100%; border-collapse: collapse;">
                <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Objektart:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">{expose.objektart}</td></tr>
                <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Wohnfl√§che:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">{expose.wohnflaeche} m¬≤</td></tr>
                <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Zimmer:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">{expose.anzahl_zimmer}</td></tr>
                <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Baujahr:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">{expose.baujahr if expose.baujahr > 0 else 'N/A'}</td></tr>
                <tr><td style="padding: 8px; border-bottom: 1px solid #ddd;"><strong>Zustand:</strong></td><td style="padding: 8px; border-bottom: 1px solid #ddd;">{expose.zustand if expose.zustand else 'N/A'}</td></tr>
            </table>

            <h2>Energieausweis</h2>
            <p><strong>Energieeffizienzklasse:</strong> {expose.energieeffizienzklasse if expose.energieeffizienzklasse else 'N/A'}</p>
            <p><strong>Endenergieverbrauch:</strong> {expose.endenergieverbrauch} kWh/m¬≤a</p>

            <h2>Kosten</h2>
            <p><strong>Hausgeld:</strong> {expose.hausgeld} ‚Ç¨ / Monat</p>
            <p><strong>Grundsteuer:</strong> {expose.grundsteuer} ‚Ç¨ / Jahr</p>
            <p><strong>Provision:</strong> {expose.provision if expose.provision else 'N/A'}</p>
        </div>
        """

        import streamlit.components.v1 as components
        components.html(preview_html, height=800, scrolling=True)

        # Download-Button f√ºr das Expos√©
        full_expose_html = generate_expose_druckversion(expose)
        col1, col2 = st.columns(2)
        with col1:
            st.download_button(
                label="üì• Expos√© als HTML herunterladen",
                data=full_expose_html,
                file_name=f"Expose_{expose.objekttitel.replace(' ', '_')}.html",
                mime="text/html",
                key=f"download_expose_{expose.expose_id}"
            )
        with col2:
            if st.button("‚ùå Vorschau schlie√üen", key=f"close_preview_{expose.expose_id}"):
                st.session_state[f"show_web_preview_{expose.expose_id}"] = False
                st.rerun()


# ============================================================================
# TIMELINE-KOMPONENTE
# ============================================================================

def render_timeline(projekt_id: str, role: str):
    """Rendert die grafische Timeline"""
    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt:
        return

    st.markdown("### üìä Projekt-Timeline")

    # Timeline-Events f√ºr dieses Projekt
    events = []
    for event_id in projekt.timeline_events:
        event = st.session_state.timeline_events.get(event_id)
        if event:
            events.append(event)

    events.sort(key=lambda e: e.position)

    if not events:
        st.info("Noch keine Timeline-Events vorhanden.")
        return

    # Finde aktuellen Schritt
    current_step = None
    for event in events:
        if not event.completed:
            current_step = event
            break

    # Timeline mit st.components rendern (robuster als pure markdown)
    import streamlit.components.v1 as components

    # Komplettes HTML mit embedded CSS
    full_html = """
    <!DOCTYPE html>
    <html>
    <head>
    <style>
    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }
    .timeline-container {
        position: relative;
        padding: 20px 10px;
    }
    .timeline-item {
        display: flex;
        margin-bottom: 30px;
        position: relative;
    }
    .timeline-marker {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        flex-shrink: 0;
        margin-right: 20px;
        z-index: 1;
        font-size: 18px;
    }
    .timeline-marker-completed {
        background: #28a745;
        color: white;
    }
    .timeline-marker-current {
        background: #ffc107;
        color: black;
        animation: pulse 2s infinite;
    }
    .timeline-marker-pending {
        background: #6c757d;
        color: white;
    }
    .timeline-line {
        position: absolute;
        left: 19px;
        top: 40px;
        bottom: -30px;
        width: 2px;
        background: #dee2e6;
    }
    .timeline-content {
        flex: 1;
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #dee2e6;
    }
    .timeline-content-completed {
        border-left-color: #28a745;
    }
    .timeline-content-current {
        border-left-color: #ffc107;
        background: #fff3cd;
    }
    .timeline-content-pending {
        border-left-color: #6c757d;
    }
    .timeline-title {
        font-weight: bold;
        font-size: 1.1em;
        margin-bottom: 5px;
    }
    .timeline-description {
        color: #6c757d;
        margin-bottom: 10px;
    }
    .timeline-waiting {
        background: #fff3cd;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
        border-left: 3px solid #ffc107;
    }
    .timeline-date {
        font-size: 0.9em;
        color: #6c757d;
    }
    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
    }
    </style>
    </head>
    <body>
    <div class="timeline-container">
    """

    for i, event in enumerate(events):
        is_completed = event.completed
        is_current = (current_step and event.event_id == current_step.event_id)

        # Marker-Klasse und Icon
        if is_completed:
            marker_class = "timeline-marker-completed"
            content_class = "timeline-content-completed"
            icon = "‚úì"
        elif is_current:
            marker_class = "timeline-marker-current"
            content_class = "timeline-content-current"
            icon = "‚è≥"
        else:
            marker_class = "timeline-marker-pending"
            content_class = "timeline-content-pending"
            icon = str(event.position)

        # Timeline Item
        full_html += f'''
        <div class="timeline-item">
            {"" if i == len(events) - 1 else '<div class="timeline-line"></div>'}
            <div class="timeline-marker {marker_class}">{icon}</div>
            <div class="timeline-content {content_class}">
                <div class="timeline-title">{event.titel}</div>
                <div class="timeline-description">{event.beschreibung}</div>
        '''

        if is_completed and event.completed_at:
            full_html += f'<div class="timeline-date">‚úÖ Abgeschlossen am {event.completed_at.strftime("%d.%m.%Y %H:%M")}</div>'

        if is_current and event.wartet_auf:
            full_html += f'''
            <div class="timeline-waiting">
                <strong>‚è∞ Wartet auf:</strong><br>
                {event.wartet_auf}
            </div>
            '''

        full_html += '''
            </div>
        </div>
        '''

    full_html += """
    </div>
    </body>
    </html>
    """

    # Render mit components.html (mehr Kontrolle √ºber HTML)
    components.html(full_html, height=len(events) * 120 + 100, scrolling=False)

    # Aktuelle Warteinfo prominent anzeigen
    if current_step and current_step.wartet_auf:
        st.warning(f"**‚è∞ Aktueller Status:** {current_step.titel}\n\n**N√§chster Schritt:** {current_step.wartet_auf}")

# ============================================================================
# AUTHENTIFIZIERUNG
# ============================================================================

def get_version_number() -> str:
    """Generiert Versionsnummer im Format: JJ.MMTT.HH:MM"""
    now = datetime.now()
    year = now.strftime("%y")  # Letzte 2 Ziffern des Jahres
    month_day = f"{now.month}{now.day}"  # Monat + Tag
    time = now.strftime("%H:%M")  # Uhrzeit
    return f"{year}.{month_day}.{time}"


def login_page():
    """Login-Seite"""
    st.title("üè† Immobilien-Transaktionsplattform")

    # Versionsnummer anzeigen
    version = get_version_number()
    st.caption(f"Version {version}")

    # Session-Persistenz JavaScript injizieren
    inject_session_persistence()

    # Versuche Session aus URL-Parametern wiederherzustellen
    restored_user = restore_session_from_storage()
    if restored_user:
        st.session_state.current_user = restored_user
        is_mitarbeiter = hasattr(restored_user, 'notar_id')  # Mitarbeiter haben notar_id
        st.session_state.is_notar_mitarbeiter = is_mitarbeiter
        st.rerun()

    st.subheader("Anmeldung")

    with st.form("login_form"):
        email = st.text_input("E-Mail")
        password = st.text_input("Passwort", type="password")
        remember_me = st.checkbox("üîê Angemeldet bleiben", value=True,
                                  help="Ihre Sitzung bleibt auch nach einem Seiten-Reload aktiv")
        submit = st.form_submit_button("Anmelden")

        if submit:
            user = None
            mitarbeiter = None

            # Zuerst normale Benutzer pr√ºfen
            for u in st.session_state.users.values():
                if u.email == email and u.password_hash == hash_password(password):
                    user = u
                    break

            # Falls kein normaler Benutzer, Notar-Mitarbeiter pr√ºfen
            if not user:
                for ma in st.session_state.notar_mitarbeiter.values():
                    if ma.email == email and ma.password_hash == hash_password(password):
                        if ma.aktiv:
                            mitarbeiter = ma
                            break
                        else:
                            st.error("‚ùå Ihr Account wurde deaktiviert. Kontaktieren Sie Ihren Notar.")
                            return

            if user:
                st.session_state.current_user = user
                st.session_state.is_notar_mitarbeiter = False

                # Session-Token erstellen und speichern wenn "Angemeldet bleiben" aktiv
                if remember_me:
                    token = get_session_token(email)
                    if 'valid_tokens' not in st.session_state:
                        st.session_state.valid_tokens = {}
                    st.session_state.valid_tokens[email] = token
                    save_session_to_browser(email, token)

                # Login-Event tracken
                safe_track_interaktion(
                    interaktions_typ='login',
                    details={'rolle': user.role, 'remember_me': remember_me},
                    nutzer_id=user.user_id
                )

                create_notification(
                    user.user_id,
                    "Willkommen zur√ºck!",
                    f"Sie haben sich erfolgreich angemeldet als {user.role}.",
                    NotificationType.SUCCESS.value
                )
                st.rerun()
            elif mitarbeiter:
                # F√ºr Mitarbeiter ein pseudo-User-Objekt erstellen
                st.session_state.current_user = mitarbeiter
                st.session_state.is_notar_mitarbeiter = True

                # Session-Token f√ºr Mitarbeiter
                if remember_me:
                    token = get_session_token(email)
                    if 'valid_tokens' not in st.session_state:
                        st.session_state.valid_tokens = {}
                    st.session_state.valid_tokens[email] = token
                    save_session_to_browser(email, token)

                # Mitarbeiter-Login tracken
                safe_track_interaktion(
                    interaktions_typ='login',
                    details={
                        'rolle': 'notar_mitarbeiter',
                        'mitarbeiter_rolle': mitarbeiter.rolle,
                        'remember_me': remember_me
                    },
                    nutzer_id=mitarbeiter.mitarbeiter_id
                )

                st.success(f"‚úÖ Willkommen zur√ºck, {mitarbeiter.name}! Sie sind angemeldet als Notar-Mitarbeiter.")
                st.rerun()
            else:
                st.error("‚ùå Ung√ºltige Anmeldedaten")

    with st.expander("üìã Demo-Zugangsdaten"):
        st.markdown("""
        **Makler:** `makler@demo.de` | `makler123`

        **K√§ufer:** `kaeufer@demo.de` | `kaeufer123`

        **Verk√§ufer:** `verkaeufer@demo.de` | `verkaeufer123`

        **Finanzierer:** `finanz@demo.de` | `finanz123`

        **Notar:** `notar@demo.de` | `notar123`
        """)

def logout():
    """Benutzer abmelden und Session aus Browser l√∂schen"""
    # Session-Token invalidieren
    if st.session_state.current_user:
        email = st.session_state.current_user.email
        if 'valid_tokens' in st.session_state and email in st.session_state.valid_tokens:
            del st.session_state.valid_tokens[email]

    # Browser-Session l√∂schen
    clear_session_from_browser()

    # URL-Parameter entfernen
    try:
        st.query_params.clear()
    except Exception:
        pass

    st.session_state.current_user = None
    st.session_state.is_notar_mitarbeiter = False
    st.rerun()

# ============================================================================
# MAKLER-BEREICH
# ============================================================================

def makler_dashboard():
    """Dashboard f√ºr Makler"""
    st.title("üìä Makler-Dashboard")

    # Aktentasche in der Sidebar
    user_id = st.session_state.current_user.user_id
    render_aktentasche_sidebar(user_id)

    # Benachrichtigungs-Badge in der Sidebar
    render_benachrichtigungs_badge(user_id)

    # Teilen-Dialog anzeigen falls aktiv
    render_aktentasche_teilen_dialog(user_id)

    # Download-Dialog anzeigen falls aktiv
    render_aktentasche_download(user_id)

    # Suchleiste
    search_term = render_dashboard_search("makler")
    if search_term:
        st.session_state['makler_search'] = search_term

    tabs = st.tabs([
        "üìã Timeline",
        "üìÅ Projekte",
        "üìä Marktanalyse",
        "üë§ Profil",
        "üíº Bankenmappe",
        "‚öñÔ∏è Rechtliche Dokumente",
        "üë• Teilnehmer-Status",
        "‚úâÔ∏è Einladungen",
        "üí¨ Kommentare",
        "ü™™ Ausweisdaten erfassen",
        "üìÖ Termine",
        "üë• Mitarbeiter",
        "üì® Nachrichten",
        "üîÑ Vertragsvergleich",  # NEU: Side-by-Side Diff
        "‚è∞ Fristen",  # NEU: Fristenmanagement
        "üìà Reporting"  # NEU: KPIs und Berichte
    ])

    with tabs[0]:
        makler_timeline_view()

    with tabs[1]:
        makler_projekte_view()

    with tabs[2]:
        makler_marktanalyse_view()

    with tabs[3]:
        makler_profil_view()

    with tabs[4]:
        render_bank_folder_view()

    with tabs[5]:
        makler_rechtliche_dokumente()

    with tabs[6]:
        makler_teilnehmer_status()

    with tabs[7]:
        makler_einladungen()

    with tabs[8]:
        makler_kommentare()

    with tabs[9]:
        makler_ausweis_erfassung()

    with tabs[10]:
        # Termin-√úbersicht f√ºr Makler mit Kalender
        st.subheader("üìÖ Meine Termine")
        user_id = st.session_state.current_user.user_id

        # Kalender-Ansicht
        termin_ansicht = st.tabs(["üìÖ Kalender", "üìã Nach Projekt"])

        with termin_ansicht[0]:
            render_termin_kalender(user_id, UserRole.MAKLER.value)

        with termin_ansicht[1]:
            projekte = [p for p in st.session_state.projekte.values() if p.makler_id == user_id]
            if projekte:
                for projekt in projekte:
                    with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
                        render_termin_verwaltung(projekt, UserRole.MAKLER.value)
            else:
                st.info("Noch keine Projekte vorhanden.")

    with tabs[11]:
        # Mitarbeiter-Verwaltung
        render_makler_mitarbeiter_verwaltung(user_id)

    with tabs[12]:
        # Kommunikationszentrale
        render_kommunikationszentrale(user_id)

    with tabs[13]:
        # Vertragsvergleich - Side-by-Side Diff
        st.subheader("üîÑ Vertragsversionen vergleichen")
        makler_projekte = [p for p in st.session_state.projekte.values()
                          if p.makler_id == user_id]
        if makler_projekte:
            projekt_auswahl = {p.projekt_id: p.name for p in makler_projekte}
            selected_projekt_id = st.selectbox(
                "Projekt ausw√§hlen",
                list(projekt_auswahl.keys()),
                format_func=lambda x: projekt_auswahl[x],
                key="makler_vertragsvergleich_projekt"
            )
            if selected_projekt_id:
                render_vertragsvergleich_tab(selected_projekt_id, user_id, UserRole.MAKLER.value)
        else:
            st.info("Noch keine Projekte vorhanden.")

    with tabs[14]:
        # Fristenmanagement
        render_fristenmanagement(user_id)

    with tabs[15]:
        # Reporting Dashboard
        render_reporting_dashboard(user_id)

def makler_timeline_view():
    """Timeline-Ansicht f√ºr Makler"""
    st.subheader("üìä Projekt-√úbersicht mit Timeline")

    makler_id = st.session_state.current_user.user_id
    search_term = st.session_state.get('makler_search', '')

    alle_projekte = [p for p in st.session_state.projekte.values() if p.makler_id == makler_id]
    projekte = filter_projekte_by_search(alle_projekte, search_term)

    display_search_results_info(len(alle_projekte), len(projekte), search_term)

    if not projekte:
        st.info("Keine Projekte gefunden." if search_term else "Noch keine Projekte vorhanden.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name} - Status: {projekt.status}", expanded=True):
            render_timeline(projekt.projekt_id, UserRole.MAKLER.value)


def makler_marktanalyse_view():
    """Marktanalyse und Vergleichsobjekte f√ºr die Preisfindung"""
    st.subheader("üìä Marktanalyse & Vergleichsobjekte")

    st.info("""
    Hier k√∂nnen Sie Vergleichsobjekte erfassen und analysieren, um eine fundierte Preisfindung
    f√ºr Ihre Immobilien zu unterst√ºtzen. Die Daten werden auch dem Verk√§ufer zur Verf√ºgung gestellt.
    """)

    makler_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.makler_id == makler_id]

    if not projekte:
        st.warning("Sie haben noch keine Projekte angelegt.")
        return

    # Projekt ausw√§hlen
    projekt_namen = {p.projekt_id: f"{p.name} - {p.adresse or 'Keine Adresse'}" for p in projekte}
    ausgewaehltes_id = st.selectbox(
        "Projekt ausw√§hlen",
        list(projekt_namen.keys()),
        format_func=lambda x: projekt_namen[x],
        key="marktanalyse_projekt_select"
    )

    projekt = next((p for p in projekte if p.projekt_id == ausgewaehltes_id), None)
    if not projekt:
        return

    # Expose-Daten holen oder erstellen
    if projekt.expose_data_id and projekt.expose_data_id in st.session_state.expose_data:
        expose = st.session_state.expose_data[projekt.expose_data_id]
    else:
        st.warning("F√ºr dieses Projekt sind noch keine Expos√©-Daten vorhanden. Bitte erstellen Sie zuerst ein Expos√© unter 'Projekte'.")
        return

    # Projektinfo anzeigen
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Kaufpreis", f"{expose.kaufpreis:,.0f} ‚Ç¨" if expose.kaufpreis else "Nicht angegeben")
    with col2:
        st.metric("Wohnfl√§che", f"{expose.wohnflaeche} m¬≤" if expose.wohnflaeche else "N/A")
    with col3:
        if expose.kaufpreis and expose.wohnflaeche and expose.wohnflaeche > 0:
            qm_preis = expose.kaufpreis / expose.wohnflaeche
            st.metric("Preis/m¬≤", f"{qm_preis:,.0f} ‚Ç¨")
        else:
            st.metric("Preis/m¬≤", "N/A")

    st.markdown("---")

    # ===== AUTOMATISCHE MARKTANALYSE =====
    render_automatische_marktanalyse(projekt, makler_id, kann_bearbeiten=True)

    st.markdown("---")

    # ===== VERGLEICHSOBJEKTE VERWALTEN =====
    st.markdown("### üèòÔ∏è Manuelle Vergleichsobjekte")

    # Bestehende Vergleichsobjekte anzeigen
    if expose.vergleichsobjekte:
        st.markdown(f"**{len(expose.vergleichsobjekte)} Vergleichsobjekt(e) erfasst:**")

        for i, vgl in enumerate(expose.vergleichsobjekte):
            with st.container():
                col1, col2, col3, col4, col5 = st.columns([3, 2, 2, 2, 1])
                with col1:
                    titel = vgl.get('titel', 'Vergleichsobjekt')
                    url = vgl.get('url', '#')
                    if url and url != '#':
                        st.markdown(f"**[{titel}]({url})**")
                    else:
                        st.markdown(f"**{titel}**")
                with col2:
                    st.write(f"üí∞ {vgl.get('preis', 0):,.0f} ‚Ç¨")
                with col3:
                    st.write(f"üìê {vgl.get('flaeche', 0):.0f} m¬≤")
                with col4:
                    st.write(f"üö™ {vgl.get('zimmer', 0)} Zimmer")
                with col5:
                    if st.button("üóëÔ∏è", key=f"del_markt_vgl_{expose.expose_id}_{i}"):
                        expose.vergleichsobjekte.pop(i)
                        st.session_state.expose_data[expose.expose_id] = expose
                        st.rerun()

                if vgl.get('notiz'):
                    st.caption(f"üìù {vgl.get('notiz')}")

                # Quadratmeterpreis anzeigen
                if vgl.get('preis', 0) > 0 and vgl.get('flaeche', 0) > 0:
                    vgl_qm = vgl.get('preis') / vgl.get('flaeche')
                    st.caption(f"‚Üí {vgl_qm:,.0f} ‚Ç¨/m¬≤")

                st.markdown("---")
    else:
        st.info("Noch keine Vergleichsobjekte erfasst. F√ºgen Sie unten welche hinzu.")

    # Neues Vergleichsobjekt hinzuf√ºgen
    st.markdown("### ‚ûï Neues Vergleichsobjekt hinzuf√ºgen")

    with st.form(f"neues_vergleichsobjekt_{projekt.projekt_id}"):
        col1, col2 = st.columns(2)

        with col1:
            vgl_titel = st.text_input(
                "Titel / Bezeichnung",
                placeholder="z.B. 3-Zi-Wohnung S√ºdstadt",
                key=f"markt_vgl_titel_{projekt.projekt_id}"
            )
            vgl_url = st.text_input(
                "URL zum Inserat (optional)",
                placeholder="https://www.immobilienscout24.de/...",
                key=f"markt_vgl_url_{projekt.projekt_id}"
            )
            vgl_quelle = st.selectbox(
                "Quelle",
                ["ImmobilienScout24", "Immowelt", "eBay Kleinanzeigen", "Eigene Datenbank", "Sonstige"],
                key=f"markt_vgl_quelle_{projekt.projekt_id}"
            )

        with col2:
            vgl_preis = st.number_input(
                "Angebotspreis (‚Ç¨)",
                min_value=0.0,
                step=5000.0,
                key=f"markt_vgl_preis_{projekt.projekt_id}"
            )
            col2a, col2b = st.columns(2)
            with col2a:
                vgl_flaeche = st.number_input(
                    "Wohnfl√§che (m¬≤)",
                    min_value=0.0,
                    step=1.0,
                    key=f"markt_vgl_flaeche_{projekt.projekt_id}"
                )
            with col2b:
                vgl_zimmer = st.number_input(
                    "Zimmer",
                    min_value=0.0,
                    step=0.5,
                    key=f"markt_vgl_zimmer_{projekt.projekt_id}"
                )

        vgl_notiz = st.text_area(
            "Notizen (optional)",
            placeholder="z.B. √Ñhnliche Lage, bessere Ausstattung, renovierungsbed√ºrftig...",
            height=80,
            key=f"markt_vgl_notiz_{projekt.projekt_id}"
        )

        submitted = st.form_submit_button("‚úÖ Vergleichsobjekt hinzuf√ºgen", type="primary")

        if submitted:
            if vgl_titel or vgl_url:
                neues_vgl = {
                    'titel': vgl_titel if vgl_titel else "Vergleichsobjekt",
                    'url': vgl_url,
                    'quelle': vgl_quelle,
                    'preis': vgl_preis,
                    'flaeche': vgl_flaeche,
                    'zimmer': vgl_zimmer,
                    'notiz': vgl_notiz,
                    'hinzugefuegt_am': datetime.now().isoformat(),
                    'hinzugefuegt_von': makler_id
                }
                if not expose.vergleichsobjekte:
                    expose.vergleichsobjekte = []
                expose.vergleichsobjekte.append(neues_vgl)
                st.session_state.expose_data[expose.expose_id] = expose
                st.success("‚úÖ Vergleichsobjekt hinzugef√ºgt!")
                st.rerun()
            else:
                st.warning("Bitte geben Sie mindestens einen Titel oder eine URL ein.")

    # ===== MARKTANALYSE-ZUSAMMENFASSUNG =====
    if expose.vergleichsobjekte and len(expose.vergleichsobjekte) >= 1:
        st.markdown("---")
        st.markdown("### üìà Marktanalyse-Zusammenfassung")

        preise = [v.get('preis', 0) for v in expose.vergleichsobjekte if v.get('preis', 0) > 0]
        flaechen = [v.get('flaeche', 0) for v in expose.vergleichsobjekte if v.get('flaeche', 0) > 0]
        qm_preise = [v.get('preis') / v.get('flaeche') for v in expose.vergleichsobjekte
                     if v.get('preis', 0) > 0 and v.get('flaeche', 0) > 0]

        col1, col2, col3, col4 = st.columns(4)

        with col1:
            if preise:
                st.metric("√ò Preis", f"{sum(preise)/len(preise):,.0f} ‚Ç¨")
                st.caption(f"Min: {min(preise):,.0f} ‚Ç¨ | Max: {max(preise):,.0f} ‚Ç¨")
            else:
                st.metric("√ò Preis", "N/A")

        with col2:
            if flaechen:
                st.metric("√ò Fl√§che", f"{sum(flaechen)/len(flaechen):.0f} m¬≤")
            else:
                st.metric("√ò Fl√§che", "N/A")

        with col3:
            if qm_preise:
                avg_qm = sum(qm_preise) / len(qm_preise)
                st.metric("√ò Preis/m¬≤", f"{avg_qm:,.0f} ‚Ç¨")
                st.caption(f"Min: {min(qm_preise):,.0f} ‚Ç¨ | Max: {max(qm_preise):,.0f} ‚Ç¨")
            else:
                st.metric("√ò Preis/m¬≤", "N/A")

        with col4:
            st.metric("Anzahl Objekte", len(expose.vergleichsobjekte))

        # Vergleich mit eigenem Objekt
        if expose.kaufpreis > 0 and expose.wohnflaeche > 0 and qm_preise:
            st.markdown("---")
            st.markdown("#### üéØ Vergleich mit Ihrem Objekt")

            eigener_qm_preis = expose.kaufpreis / expose.wohnflaeche
            avg_qm = sum(qm_preise) / len(qm_preise)
            differenz = eigener_qm_preis - avg_qm
            differenz_prozent = (differenz / avg_qm) * 100 if avg_qm > 0 else 0

            col1, col2, col3 = st.columns(3)

            with col1:
                st.metric("Ihr Preis/m¬≤", f"{eigener_qm_preis:,.0f} ‚Ç¨")

            with col2:
                st.metric("Markt √ò/m¬≤", f"{avg_qm:,.0f} ‚Ç¨")

            with col3:
                if differenz > 0:
                    st.metric("Differenz", f"+{differenz:,.0f} ‚Ç¨/m¬≤", delta=f"+{differenz_prozent:.1f}%")
                    st.caption("√úber Marktdurchschnitt")
                else:
                    st.metric("Differenz", f"{differenz:,.0f} ‚Ç¨/m¬≤", delta=f"{differenz_prozent:.1f}%")
                    st.caption("Unter Marktdurchschnitt")

            # Empfehlung
            if abs(differenz_prozent) <= 5:
                st.success("‚úÖ **Einsch√§tzung:** Der Preis liegt im markt√ºblichen Bereich.")
            elif differenz_prozent > 5:
                st.warning(f"‚ö†Ô∏è **Einsch√§tzung:** Der Preis liegt {differenz_prozent:.1f}% √ºber dem Marktdurchschnitt. Pr√ºfen Sie besondere Ausstattungsmerkmale oder Lagefaktoren.")
            else:
                st.info(f"üí° **Einsch√§tzung:** Der Preis liegt {abs(differenz_prozent):.1f}% unter dem Marktdurchschnitt. Ggf. Spielraum f√ºr Preisanpassung.")


def makler_projekte_view():
    """Projekt-Verwaltung f√ºr Makler"""
    st.subheader("üìÅ Meine Projekte")

    makler_projekte = [p for p in st.session_state.projekte.values()
                       if p.makler_id == st.session_state.current_user.user_id]

    if st.button("‚ûï Neues Projekt anlegen"):
        st.session_state.show_new_projekt = True

    if st.session_state.get("show_new_projekt", False):
        with st.form("new_projekt_form"):
            st.markdown("### Neues Projekt anlegen")

            name = st.text_input("Projekt-Name*", placeholder="z.B. Eigentumswohnung M√ºnchen-Schwabing")
            beschreibung = st.text_area("Beschreibung*", placeholder="Kurze Beschreibung der Immobilie")
            adresse = st.text_input("Adresse", placeholder="Stra√üe, PLZ Ort")
            kaufpreis = st.number_input("Kaufpreis (‚Ç¨)", min_value=0.0, value=0.0, step=1000.0)

            st.markdown("#### ‚öôÔ∏è Projekt-Einstellungen")
            rechtsdokumente_erforderlich = st.checkbox(
                "üìú K√§ufer/Verk√§ufer m√ºssen Datenschutz & AGB akzeptieren",
                value=True,
                help="Wenn aktiviert, m√ºssen K√§ufer und Verk√§ufer die Rechtsdokumente des Notars akzeptieren, bevor sie auf ihr Dashboard zugreifen k√∂nnen."
            )
            preisverhandlung_erlaubt = st.checkbox(
                "üí∞ Preisverhandlung zwischen K√§ufer und Verk√§ufer erlauben",
                value=False,
                help="Wenn aktiviert, k√∂nnen K√§ufer und Verk√§ufer direkt √ºber den Preis verhandeln."
            )

            col1, col2 = st.columns(2)
            with col1:
                submit = st.form_submit_button("üíæ Projekt erstellen", type="primary")
            with col2:
                cancel = st.form_submit_button("‚ùå Abbrechen")

            if submit and name and beschreibung:
                projekt_id = f"projekt_{len(st.session_state.projekte)}"

                projekt = Projekt(
                    projekt_id=projekt_id,
                    name=name,
                    beschreibung=beschreibung,
                    adresse=adresse,
                    kaufpreis=kaufpreis,
                    makler_id=st.session_state.current_user.user_id,
                    rechtsdokumente_erforderlich=rechtsdokumente_erforderlich,
                    preisverhandlung_erlaubt=preisverhandlung_erlaubt
                )

                st.session_state.projekte[projekt_id] = projekt

                # Timeline initialisieren
                create_timeline_for_projekt(projekt_id)

                st.session_state.show_new_projekt = False
                st.success(f"‚úÖ Projekt '{name}' erfolgreich erstellt!")
                st.rerun()

            if cancel:
                st.session_state.show_new_projekt = False
                st.rerun()

    st.markdown("---")

    for projekt in makler_projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            col1, col2 = st.columns([2, 1])

            with col1:
                st.markdown(f"**Beschreibung:** {projekt.beschreibung}")
                if projekt.adresse:
                    st.markdown(f"**Adresse:** {projekt.adresse}")
                if projekt.kaufpreis > 0:
                    st.markdown(f"**Kaufpreis:** {format_euro(projekt.kaufpreis)} ‚Ç¨")
                st.markdown(f"**Status:** {projekt.status}")
                st.markdown(f"**Erstellt:** {projekt.created_at.strftime('%d.%m.%Y')}")

            with col2:
                st.markdown("**Teilnehmer:**")
                st.write(f"üë• K√§ufer: {len(projekt.kaeufer_ids)}")
                st.write(f"üë• Verk√§ufer: {len(projekt.verkaeufer_ids)}")
                st.write(f"üíº Finanzierer: {len(projekt.finanzierer_ids)}")
                st.write(f"‚öñÔ∏è Notar: {'Ja' if projekt.notar_id else 'Nein'}")

            # Projekt-Einstellungen
            with st.expander("‚öôÔ∏è Projekt-Einstellungen", expanded=False):
                rechtsdokumente_aktuell = getattr(projekt, 'rechtsdokumente_erforderlich', True)
                preisverhandlung_aktuell = getattr(projekt, 'preisverhandlung_erlaubt', False)

                rechtsdokumente_neu = st.checkbox(
                    "üìú K√§ufer/Verk√§ufer m√ºssen Datenschutz & AGB akzeptieren",
                    value=rechtsdokumente_aktuell,
                    key=f"rechtsdok_{projekt.projekt_id}",
                    help="Wenn deaktiviert, k√∂nnen K√§ufer und Verk√§ufer sofort auf ihr Dashboard zugreifen."
                )
                preisverhandlung_neu = st.checkbox(
                    "üí∞ Preisverhandlung zwischen K√§ufer und Verk√§ufer erlauben",
                    value=preisverhandlung_aktuell,
                    key=f"preisverh_{projekt.projekt_id}",
                    help="Wenn aktiviert, k√∂nnen K√§ufer und Verk√§ufer direkt √ºber den Preis verhandeln."
                )

                if st.button("üíæ Einstellungen speichern", key=f"save_settings_{projekt.projekt_id}"):
                    projekt.rechtsdokumente_erforderlich = rechtsdokumente_neu
                    projekt.preisverhandlung_erlaubt = preisverhandlung_neu
                    st.success("‚úÖ Projekt-Einstellungen gespeichert!")
                    st.rerun()

            # NEU: Parteien-Verwaltung (Gesellschaften, Organe)
            with st.expander("üë• Parteien & Gesellschaften", expanded=False):
                render_parteien_verwaltung(projekt, UserRole.MAKLER.value)

            # NEU: Gating-√úbersicht (Finanzierung & Legal)
            with st.expander("üîê Freigabe-Status", expanded=False):
                render_gating_uebersicht(projekt.projekt_id, UserRole.MAKLER.value)

            # ===== VERBESSERUNG 3: MAKLER-EINSICHT PREISVERHANDLUNG =====
            angebote = get_preisangebote_fuer_projekt(projekt.projekt_id)
            if angebote:
                with st.expander(f"üí∞ Preisverhandlung ({len(angebote)} Angebote)", expanded=False):
                    # Aktueller Status
                    letztes_angebot = angebote[0] if angebote else None
                    angenommene = [a for a in angebote if a.status == PreisangebotStatus.ANGENOMMEN.value]

                    if angenommene:
                        einigung = angenommene[0]
                        st.success(f"‚úÖ **Preiseinigung erzielt:** {format_euro(einigung.betrag)} ‚Ç¨ am {einigung.beantwortet_am.strftime('%d.%m.%Y') if einigung.beantwortet_am else einigung.erstellt_am.strftime('%d.%m.%Y')}")
                    elif letztes_angebot and letztes_angebot.status == PreisangebotStatus.OFFEN.value:
                        von_user = st.session_state.users.get(letztes_angebot.von_user_id)
                        von_name = von_user.name if von_user else "Unbekannt"
                        st.info(f"‚è≥ **Offenes Angebot:** {format_euro(letztes_angebot.betrag)} ‚Ç¨ von {von_name} ({letztes_angebot.von_rolle})")

                    # Vollst√§ndiger Verlauf
                    st.markdown("**Verhandlungsverlauf:**")
                    for angebot in angebote:
                        von_user = st.session_state.users.get(angebot.von_user_id)
                        von_name = von_user.name if von_user else "Unbekannt"
                        status_icon = {
                            PreisangebotStatus.OFFEN.value: "‚è≥",
                            PreisangebotStatus.ANGENOMMEN.value: "‚úÖ",
                            PreisangebotStatus.ABGELEHNT.value: "‚ùå",
                            PreisangebotStatus.GEGENANGEBOT.value: "üí¨",
                            PreisangebotStatus.ZURUECKGEZOGEN.value: "üîô"
                        }.get(angebot.status, "‚ùì")

                        st.markdown(f"""
                        {status_icon} **{format_euro(angebot.betrag)} ‚Ç¨** - {von_name} ({angebot.von_rolle})
                        - Status: {angebot.status} | {angebot.erstellt_am.strftime('%d.%m.%Y %H:%M')}
                        {"- *" + angebot.nachricht + "*" if angebot.nachricht else ""}
                        """)

            st.markdown("---")

            # ===== EXPOS√â-VERWALTUNG (DIREKT SICHTBAR) =====
            st.markdown("#### üìÑ Expos√©-Daten")

            # Expos√©-Status anzeigen
            if projekt.expose_data_id:
                expose = st.session_state.expose_data.get(projekt.expose_data_id)
                if expose and expose.objekttitel:
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.write(f"**Objektart:** {expose.objektart}")
                        st.write(f"**Wohnfl√§che:** {expose.wohnflaeche} m¬≤")
                    with col2:
                        st.write(f"**Zimmer:** {expose.anzahl_zimmer}")
                        st.write(f"**Kaufpreis:** {format_euro(expose.kaufpreis)} ‚Ç¨")
                    with col3:
                        st.write(f"**Letzte √Ñnderung:** {expose.updated_at.strftime('%d.%m.%Y %H:%M')}")
                        if expose.adresse_validiert:
                            st.success("‚úÖ Adresse validiert")

            # Expos√©-Editor immer in einem Expander anzeigen (standardm√§√üig eingeklappt wenn Daten vorhanden)
            expose_exists = bool(projekt.expose_data_id and
                                st.session_state.expose_data.get(projekt.expose_data_id) and
                                st.session_state.expose_data.get(projekt.expose_data_id).objekttitel)

            with st.expander("üìù Expos√© bearbeiten" if expose_exists else "üìù Expos√©-Daten eingeben", expanded=not expose_exists):
                render_expose_editor(projekt)

            st.markdown("---")

            # ===== PREISFINDUNG MIT MARKTANALYSE =====
            with st.expander("üìä Preisfindung mit Marktanalyse", expanded=False):
                render_preisfindung_mit_marktanalyse(projekt, st.session_state.current_user.user_id)

            st.markdown("---")

            # ===== TERMIN-VERWALTUNG =====
            with st.expander("üìÖ Terminverwaltung", expanded=False):
                render_termin_verwaltung(projekt, UserRole.MAKLER.value)

                # Best√§tigte Beurkundungstermine hervorheben
                beurkundungstermine = [st.session_state.termine.get(tid) for tid in projekt.termine
                                       if st.session_state.termine.get(tid) and
                                       st.session_state.termine.get(tid).termin_typ == TerminTyp.BEURKUNDUNG.value and
                                       st.session_state.termine.get(tid).status == TerminStatus.BESTAETIGT.value]

                if beurkundungstermine:
                    for termin in beurkundungstermine:
                        st.success(f"üü¢ **Notartermin best√§tigt:** {termin.datum.strftime('%d.%m.%Y')} um {termin.uhrzeit_start} Uhr")

def create_timeline_for_projekt(projekt_id: str):
    """Erstellt Timeline-Events f√ºr ein neues Projekt"""
    events = [
        ("Projekt erstellt", "Projekt wurde vom Makler angelegt", ProjektStatus.VORBEREITUNG.value, True, 1, None),
        ("Expos√© hochgeladen", "Expos√© wurde bereitgestellt", ProjektStatus.EXPOSE_ERSTELLT.value, False, 2, "Makler muss Expos√©-PDF hochladen"),
        ("Teilnehmer eingeladen", "K√§ufer und Verk√§ufer wurden eingeladen", ProjektStatus.TEILNEHMER_EINGELADEN.value, False, 3, "Makler muss K√§ufer und Verk√§ufer einladen"),
        ("Onboarding-Dokumente akzeptieren", "K√§ufer und Verk√§ufer m√ºssen rechtliche Dokumente akzeptieren", ProjektStatus.ONBOARDING_LAUFEND.value, False, 4, "K√§ufer und Verk√§ufer m√ºssen alle rechtlichen Dokumente akzeptieren"),
        ("Wirtschaftsdaten hochladen", "K√§ufer l√§dt Bonit√§tsunterlagen hoch", ProjektStatus.WIRTSCHAFTSDATEN_HOCHGELADEN.value, False, 5, "K√§ufer muss Bonit√§tsunterlagen hochladen"),
        ("Finanzierungsanfrage", "Finanzierer pr√ºft Unterlagen", ProjektStatus.FINANZIERUNG_ANGEFRAGT.value, False, 6, "Finanzierer muss Finanzierungsangebot erstellen"),
        ("Finanzierung gesichert", "K√§ufer nimmt Angebot an", ProjektStatus.FINANZIERUNG_GESICHERT.value, False, 7, "K√§ufer muss Finanzierungsangebot annehmen"),
        ("Notartermin vereinbaren", "Notartermin wird festgelegt", ProjektStatus.NOTARTERMIN_VEREINBART.value, False, 8, "Notar muss Termin festlegen"),
        ("Kaufvertrag unterzeichnen", "Unterzeichnung beim Notar", ProjektStatus.KAUFVERTRAG_UNTERZEICHNET.value, False, 9, "Alle Parteien beim Notartermin"),
        ("Transaktion abgeschlossen", "√úbergabe und Grundbuch", ProjektStatus.ABGESCHLOSSEN.value, False, 10, "Notar best√§tigt Abschluss"),
    ]

    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt:
        return

    for i, (titel, beschreibung, status, completed, position, wartet_auf) in enumerate(events):
        event_id = f"evt_{projekt_id}_{i}"

        event = TimelineEvent(
            event_id=event_id,
            projekt_id=projekt_id,
            titel=titel,
            beschreibung=beschreibung,
            status=status,
            completed=completed,
            completed_at=datetime.now() if completed else None,
            position=position,
            wartet_auf=wartet_auf
        )

        st.session_state.timeline_events[event_id] = event
        projekt.timeline_events.append(event_id)

def makler_profil_view():
    """Makler-Profil-Verwaltung"""
    st.subheader("üë§ Mein Makler-Profil")

    makler_id = st.session_state.current_user.user_id

    # Profil suchen oder erstellen
    profile = None
    for p in st.session_state.makler_profiles.values():
        if p.makler_id == makler_id:
            profile = p
            break

    if not profile:
        st.info("Sie haben noch kein Profil erstellt. Erstellen Sie jetzt Ihr Makler-Profil!")
        if st.button("‚ûï Profil erstellen"):
            profile_id = f"profile_{len(st.session_state.makler_profiles)}"
            profile = MaklerProfile(
                profile_id=profile_id,
                makler_id=makler_id,
                firmenname="",
                adresse="",
                telefon="",
                email=""
            )
            st.session_state.makler_profiles[profile_id] = profile
            st.rerun()
        return

    # Profil bearbeiten
    with st.form("profil_bearbeiten"):
        st.markdown("### Firmendaten")

        col1, col2 = st.columns([1, 2])

        with col1:
            st.markdown("**Logo**")
            logo_file = st.file_uploader("Firmenlogo hochladen", type=["png", "jpg", "jpeg"], key="logo_upload")
            if profile.logo:
                st.image(profile.logo, width=150)
            elif logo_file:
                st.image(logo_file, width=150)

        with col2:
            firmenname = st.text_input("Firmenname*", value=profile.firmenname)
            adresse = st.text_area("Adresse*", value=profile.adresse, height=100)

            col_tel, col_email = st.columns(2)
            with col_tel:
                telefon = st.text_input("Telefon*", value=profile.telefon)
            with col_email:
                email = st.text_input("E-Mail*", value=profile.email)

            website = st.text_input("Website", value=profile.website)

        st.markdown("---")
        st.markdown("### Backoffice-Kontakt")
        col1, col2, col3 = st.columns(3)
        with col1:
            backoffice_kontakt = st.text_input("Name", value=profile.backoffice_kontakt)
        with col2:
            backoffice_email = st.text_input("E-Mail", value=profile.backoffice_email)
        with col3:
            backoffice_telefon = st.text_input("Telefon", value=profile.backoffice_telefon)

        st.markdown("---")

        if st.form_submit_button("üíæ Profil speichern", type="primary"):
            profile.firmenname = firmenname
            profile.adresse = adresse
            profile.telefon = telefon
            profile.email = email
            profile.website = website
            profile.backoffice_kontakt = backoffice_kontakt
            profile.backoffice_email = backoffice_email
            profile.backoffice_telefon = backoffice_telefon

            if logo_file:
                profile.logo = logo_file.read()

            st.session_state.makler_profiles[profile.profile_id] = profile
            st.success("‚úÖ Profil erfolgreich gespeichert!")

    st.markdown("---")
    st.markdown("### üë• Team-Mitglieder")

    # Team-Mitglieder anzeigen
    if profile.team_mitglieder:
        for agent in profile.team_mitglieder:
            with st.expander(f"üë§ {agent.name} - {agent.position}"):
                col1, col2 = st.columns([1, 3])

                with col1:
                    if agent.foto:
                        st.image(agent.foto, width=100)
                    else:
                        st.write("Kein Foto")

                with col2:
                    st.write(f"**Position:** {agent.position}")
                    st.write(f"**Telefon:** {agent.telefon}")
                    st.write(f"**E-Mail:** {agent.email}")

                if st.button(f"üóëÔ∏è Entfernen", key=f"remove_{agent.agent_id}"):
                    profile.team_mitglieder = [a for a in profile.team_mitglieder if a.agent_id != agent.agent_id]
                    st.session_state.makler_profiles[profile.profile_id] = profile
                    st.success(f"Team-Mitglied {agent.name} entfernt!")
                    st.rerun()
    else:
        st.info("Noch keine Team-Mitglieder hinzugef√ºgt.")

    # Neues Team-Mitglied hinzuf√ºgen
    with st.expander("‚ûï Team-Mitglied hinzuf√ºgen"):
        with st.form("neues_team_mitglied"):
            col1, col2 = st.columns([1, 2])

            with col1:
                foto_file = st.file_uploader("Foto", type=["png", "jpg", "jpeg"], key="agent_foto")
                if foto_file:
                    st.image(foto_file, width=100)

            with col2:
                agent_name = st.text_input("Name*")
                agent_position = st.text_input("Position*", placeholder="z.B. Immobilienberater")
                agent_telefon = st.text_input("Telefon*")
                agent_email = st.text_input("E-Mail*")

            if st.form_submit_button("‚ûï Hinzuf√ºgen"):
                if agent_name and agent_position and agent_telefon and agent_email:
                    agent_id = f"agent_{len(profile.team_mitglieder)}"
                    foto_bytes = foto_file.read() if foto_file else None

                    new_agent = MaklerAgent(
                        agent_id=agent_id,
                        name=agent_name,
                        position=agent_position,
                        telefon=agent_telefon,
                        email=agent_email,
                        foto=foto_bytes
                    )

                    profile.team_mitglieder.append(new_agent)
                    st.session_state.makler_profiles[profile.profile_id] = profile
                    st.success(f"‚úÖ {agent_name} wurde zum Team hinzugef√ºgt!")
                    st.rerun()
                else:
                    st.error("Bitte alle Pflichtfelder ausf√ºllen!")

def makler_rechtliche_dokumente():
    """Verwaltung rechtlicher Dokumente"""
    st.subheader("‚öñÔ∏è Rechtliche Dokumente / Mandanten-Setup")
    st.markdown("""
    Hier hinterlegen Sie die rechtlichen Standarddokumente, die K√§ufer und Verk√§ufer
    **vor Einsicht ins Expos√©** akzeptieren m√ºssen.
    """)

    doc_types = [
        DocumentType.MAKLERAUFTRAG.value,
        DocumentType.DATENSCHUTZ.value,
        DocumentType.WIDERRUFSBELEHRUNG.value,
        DocumentType.WIDERRUFSVERZICHT.value
    ]

    for doc_type in doc_types:
        with st.expander(f"üìÑ {doc_type}", expanded=False):
            doc_key = f"{st.session_state.current_user.user_id}_{doc_type}"
            existing_doc = st.session_state.legal_documents.get(doc_key)

            if existing_doc:
                st.success(f"‚úÖ Version {existing_doc.version} vom {existing_doc.created_at.strftime('%d.%m.%Y %H:%M')}")
                st.text_area("Aktueller Inhalt", existing_doc.content_text, height=150, disabled=True, key=f"view_{doc_key}")

                if st.button("üîÑ Neue Version erstellen", key=f"update_{doc_key}"):
                    st.session_state[f"edit_mode_{doc_key}"] = True
                    st.rerun()

            if existing_doc is None or st.session_state.get(f"edit_mode_{doc_key}", False):
                with st.form(f"form_{doc_key}"):
                    text_content = st.text_area(
                        "Dokumenten-Text",
                        value=existing_doc.content_text if existing_doc else "",
                        height=200
                    )
                    pdf_file = st.file_uploader("PDF-Version (optional)", type=['pdf'], key=f"pdf_{doc_key}")

                    col1, col2 = st.columns(2)
                    with col1:
                        submit = st.form_submit_button("üíæ Speichern")
                    with col2:
                        cancel = st.form_submit_button("‚ùå Abbrechen")

                    if submit and text_content:
                        if existing_doc:
                            old_version = float(existing_doc.version.replace('v', ''))
                            new_version = f"v{old_version + 0.1:.1f}"
                        else:
                            new_version = "v1.0"

                        pdf_data = pdf_file.read() if pdf_file else None
                        doc = LegalDocument(
                            doc_type=doc_type,
                            version=new_version,
                            content_text=text_content,
                            pdf_data=pdf_data
                        )
                        st.session_state.legal_documents[doc_key] = doc
                        if f"edit_mode_{doc_key}" in st.session_state:
                            del st.session_state[f"edit_mode_{doc_key}"]
                        st.success(f"‚úÖ {doc_type} {new_version} gespeichert!")
                        st.rerun()

                    if cancel:
                        if f"edit_mode_{doc_key}" in st.session_state:
                            del st.session_state[f"edit_mode_{doc_key}"]
                        st.rerun()

def makler_teilnehmer_status():
    """Zeigt Status der Dokumenten-Akzeptanz aller Teilnehmer"""
    st.subheader("üë• Teilnehmer-Status")

    for projekt in st.session_state.projekte.values():
        if projekt.makler_id != st.session_state.current_user.user_id:
            continue

        st.markdown(f"### üèòÔ∏è {projekt.name}")

        teilnehmer_ids = projekt.kaeufer_ids + projekt.verkaeufer_ids

        if not teilnehmer_ids:
            st.info("Noch keine Teilnehmer eingeladen.")
            continue

        status_data = []
        for user_id in teilnehmer_ids:
            user = st.session_state.users.get(user_id)
            if not user:
                continue

            acceptances = {acc.document_type: acc for acc in user.document_acceptances}

            row = {
                "Name": user.name,
                "Rolle": user.role,
                "Maklerauftrag": "‚úÖ" if DocumentType.MAKLERAUFTRAG.value in acceptances else "‚ùå",
                "Datenschutz": "‚úÖ" if DocumentType.DATENSCHUTZ.value in acceptances else "‚ùå",
                "Widerrufsbelehrung": "‚úÖ" if DocumentType.WIDERRUFSBELEHRUNG.value in acceptances else "‚ùå",
                "Widerrufsverzicht": "‚úÖ" if DocumentType.WIDERRUFSVERZICHT.value in acceptances else "‚ùå",
                "Onboarding": "‚úÖ" if user.onboarding_complete else "‚ùå"
            }
            status_data.append(row)

        if status_data:
            import pandas as pd
            df = pd.DataFrame(status_data)
            st.dataframe(df, use_container_width=True, hide_index=True)

        st.markdown("---")

def makler_einladungen():
    """Einladungs-Verwaltung"""
    st.subheader("‚úâÔ∏è Teilnehmer einladen")

    makler_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.makler_id == makler_id]

    if not projekte:
        st.info("Noch keine Projekte vorhanden.")
        return

    with st.form("invitation_form"):
        st.markdown("### Neue Einladung")

        projekt_options = {p.name: p.projekt_id for p in projekte}
        selected_projekt_name = st.selectbox("Projekt ausw√§hlen", list(projekt_options.keys()))
        projekt_id = projekt_options[selected_projekt_name]

        email = st.text_input("E-Mail-Adresse")
        rolle = st.selectbox("Rolle", [UserRole.KAEUFER.value, UserRole.VERKAEUFER.value, UserRole.FINANZIERER.value, UserRole.NOTAR.value])

        submit = st.form_submit_button("üìß Einladung senden")

        if submit and email:
            # Token generieren
            token = hashlib.sha256(f"{email}{projekt_id}{datetime.now()}".encode()).hexdigest()[:16]

            invitation_id = f"inv_{len(st.session_state.invitations)}"
            invitation = Invitation(
                invitation_id=invitation_id,
                projekt_id=projekt_id,
                email=email,
                rolle=rolle,
                eingeladen_von=makler_id,
                token=token,
                created_at=datetime.now()
            )

            st.session_state.invitations[invitation_id] = invitation

            st.success(f"‚úÖ Einladung an {email} wurde versendet!")
            st.info(f"**Einladungslink (Demo):** `https://plattform.immobilien/invite/{token}`")

            st.rerun()

    # Offene Einladungen anzeigen
    st.markdown("---")
    st.markdown("### Versendete Einladungen")

    invitations = [inv for inv in st.session_state.invitations.values()
                   if inv.eingeladen_von == makler_id and not inv.verwendet]

    if invitations:
        for inv in invitations:
            projekt = st.session_state.projekte.get(inv.projekt_id)
            projekt_name = projekt.name if projekt else "Unbekannt"

            col1, col2, col3 = st.columns([2, 2, 1])
            with col1:
                st.write(f"üìß {inv.email}")
            with col2:
                st.write(f"üèòÔ∏è {projekt_name} | {inv.rolle}")
            with col3:
                st.caption(inv.created_at.strftime("%d.%m.%Y"))
    else:
        st.info("Keine offenen Einladungen.")

def makler_kommentare():
    """Kommentar-Bereich"""
    st.subheader("üí¨ Kommentare & Nachrichten")

    makler_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.makler_id == makler_id]

    if not projekte:
        st.info("Noch keine Projekte vorhanden.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            # Kommentare anzeigen
            projekt_comments = [c for c in st.session_state.comments.values()
                              if c.projekt_id == projekt.projekt_id]
            projekt_comments.sort(key=lambda c: c.created_at, reverse=True)

            if projekt_comments:
                for comment in projekt_comments:
                    user = st.session_state.users.get(comment.user_id)
                    user_name = user.name if user else "Unbekannt"

                    st.markdown(f"""
                    <div style='background:#f0f0f0; padding:10px; border-radius:5px; margin:10px 0;'>
                        <strong>{user_name}</strong> <small>({comment.created_at.strftime('%d.%m.%Y %H:%M')})</small><br>
                        {comment.nachricht}
                    </div>
                    """, unsafe_allow_html=True)
            else:
                st.info("Noch keine Kommentare.")

            # Neuer Kommentar
            with st.form(f"comment_form_{projekt.projekt_id}"):
                nachricht = st.text_area("Nachricht schreiben", key=f"msg_{projekt.projekt_id}")

                sichtbar = st.multiselect(
                    "Sichtbar f√ºr",
                    ["K√§ufer", "Verk√§ufer", "Finanzierer", "Notar"],
                    default=["K√§ufer", "Verk√§ufer"]
                )

                if st.form_submit_button("üì§ Senden"):
                    if nachricht:
                        comment_id = f"comment_{len(st.session_state.comments)}"
                        comment = Comment(
                            comment_id=comment_id,
                            projekt_id=projekt.projekt_id,
                            user_id=makler_id,
                            nachricht=nachricht,
                            created_at=datetime.now(),
                            sichtbar_fuer=sichtbar
                        )
                        st.session_state.comments[comment_id] = comment

                        # Benachrichtigungen
                        for rolle in sichtbar:
                            if rolle == "K√§ufer":
                                for kid in projekt.kaeufer_ids:
                                    create_notification(kid, "Neue Nachricht", f"Neue Nachricht im Projekt {projekt.name}", NotificationType.INFO.value)
                            elif rolle == "Verk√§ufer":
                                for vid in projekt.verkaeufer_ids:
                                    create_notification(vid, "Neue Nachricht", f"Neue Nachricht im Projekt {projekt.name}", NotificationType.INFO.value)

                        st.success("‚úÖ Nachricht gesendet!")
                        st.rerun()


def makler_ausweis_erfassung():
    """Ausweisdaten f√ºr K√§ufer und Verk√§ufer erfassen (Makler)"""
    st.subheader("ü™™ Ausweisdaten erfassen")
    st.caption("Erfassen Sie hier die Ausweisdaten der K√§ufer und Verk√§ufer f√ºr Ihre Projekte.")

    makler_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.makler_id == makler_id]

    if not projekte:
        st.info("Noch keine Projekte vorhanden.")
        return

    # Projekt ausw√§hlen
    projekt_options = {p.name: p for p in projekte}
    selected_projekt_name = st.selectbox(
        "Projekt ausw√§hlen",
        list(projekt_options.keys()),
        key="makler_ausweis_projekt"
    )
    selected_projekt = projekt_options[selected_projekt_name]

    # Tabs f√ºr K√§ufer und Verk√§ufer
    ausweis_tabs = st.tabs(["üë§ K√§ufer", "üë§ Verk√§ufer"])

    with ausweis_tabs[0]:
        st.markdown("### K√§ufer-Ausweisdaten")
        if selected_projekt.kaeufer_ids:
            for kaeufer_id in selected_projekt.kaeufer_ids:
                kaeufer = st.session_state.users.get(kaeufer_id)
                if kaeufer:
                    with st.expander(f"ü™™ {kaeufer.name}", expanded=True):
                        # Pr√ºfen ob Daten bereits erfasst
                        personal_key = f"personal_{kaeufer_id}"
                        if personal_key in st.session_state:
                            st.success("‚úÖ Ausweisdaten bereits erfasst")
                            daten = st.session_state[personal_key]
                            st.write(f"**Name:** {daten.get('vorname', '')} {daten.get('nachname', '')}")
                            st.write(f"**Geburtsdatum:** {daten.get('geburtsdatum', '')}")
                            st.write(f"**Adresse:** {daten.get('adresse', '')}")

                            if st.button(f"üîÑ Neu erfassen", key=f"reupload_k_{kaeufer_id}"):
                                del st.session_state[personal_key]
                                st.rerun()
                        else:
                            st.info("Ausweisdaten noch nicht erfasst.")
                            render_ausweis_upload(kaeufer_id, UserRole.KAEUFER.value, context=f"makler_{kaeufer_id}")
        else:
            st.info("Noch keine K√§ufer f√ºr dieses Projekt.")

    with ausweis_tabs[1]:
        st.markdown("### Verk√§ufer-Ausweisdaten")
        if selected_projekt.verkaeufer_ids:
            for verkaeufer_id in selected_projekt.verkaeufer_ids:
                verkaeufer = st.session_state.users.get(verkaeufer_id)
                if verkaeufer:
                    with st.expander(f"ü™™ {verkaeufer.name}", expanded=True):
                        # Pr√ºfen ob Daten bereits erfasst
                        personal_key = f"personal_{verkaeufer_id}"
                        if personal_key in st.session_state:
                            st.success("‚úÖ Ausweisdaten bereits erfasst")
                            daten = st.session_state[personal_key]
                            st.write(f"**Name:** {daten.get('vorname', '')} {daten.get('nachname', '')}")
                            st.write(f"**Geburtsdatum:** {daten.get('geburtsdatum', '')}")
                            st.write(f"**Adresse:** {daten.get('adresse', '')}")

                            if st.button(f"üîÑ Neu erfassen", key=f"reupload_v_{verkaeufer_id}"):
                                del st.session_state[personal_key]
                                st.rerun()
                        else:
                            st.info("Ausweisdaten noch nicht erfasst.")
                            render_ausweis_upload(verkaeufer_id, UserRole.VERKAEUFER.value, context=f"makler_{verkaeufer_id}")
        else:
            st.info("Noch keine Verk√§ufer f√ºr dieses Projekt.")


# ============================================================================
# K√ÑUFER/VERK√ÑUFER ONBOARDING
# ============================================================================

def onboarding_flow():
    """Onboarding-Flow f√ºr K√§ufer/Verk√§ufer"""
    st.title("üëã Willkommen!")
    st.markdown("""
    Bevor wir Ihnen das Expos√© und die Projektdaten anzeigen,
    bitten wir Sie, die folgenden Unterlagen zu pr√ºfen und zu best√§tigen.
    """)

    makler_id = "makler1"

    doc_types = [
        DocumentType.MAKLERAUFTRAG.value,
        DocumentType.DATENSCHUTZ.value,
        DocumentType.WIDERRUFSBELEHRUNG.value,
        DocumentType.WIDERRUFSVERZICHT.value
    ]

    user = st.session_state.current_user
    accepted_docs = {acc.document_type for acc in user.document_acceptances}

    all_accepted = True
    acceptances_to_save = []

    st.markdown("---")

    for doc_type in doc_types:
        doc_key = f"{makler_id}_{doc_type}"
        doc = st.session_state.legal_documents.get(doc_key)

        if not doc:
            st.warning(f"‚ö†Ô∏è {doc_type} wurde vom Makler noch nicht hinterlegt.")
            all_accepted = False
            continue

        st.subheader(f"üìÑ {doc_type}")
        st.caption(f"Version {doc.version}")

        with st.expander("üìñ Volltext anzeigen", expanded=False):
            st.text_area("", doc.content_text, height=200, disabled=True, key=f"read_{doc_type}")

        if doc.pdf_data:
            st.download_button(
                "üì• PDF herunterladen",
                doc.pdf_data,
                file_name=f"{doc_type}_{doc.version}.pdf",
                mime="application/pdf",
                key=f"dl_{doc_type}"
            )

        already_accepted = doc_type in accepted_docs

        if already_accepted:
            st.success(f"‚úÖ Bereits akzeptiert")
        else:
            accept_key = f"accept_{doc_type}"
            if st.checkbox(
                f"Hiermit akzeptiere ich {doc_type.lower()}.",
                key=accept_key,
                value=False
            ):
                acceptances_to_save.append(
                    DocumentAcceptance(
                        user_id=user.user_id,
                        document_type=doc_type,
                        document_version=doc.version,
                        accepted_at=datetime.now(),
                        role=user.role
                    )
                )
            else:
                all_accepted = False

        st.markdown("---")

    if all_accepted or len(acceptances_to_save) == len([dt for dt in doc_types if f"{makler_id}_{dt}" in st.session_state.legal_documents]):
        if st.button("‚úÖ Fortfahren & Expos√© anzeigen", type="primary", use_container_width=True):
            for acc in acceptances_to_save:
                user.document_acceptances.append(acc)
            user.onboarding_complete = True

            # Timeline aktualisieren
            for projekt_id in user.projekt_ids:
                projekt = st.session_state.projekte.get(projekt_id)
                if projekt:
                    # Pr√ºfe ob alle Teilnehmer fertig sind
                    all_onboarded = True
                    for uid in projekt.kaeufer_ids + projekt.verkaeufer_ids:
                        u = st.session_state.users.get(uid)
                        if u and not u.onboarding_complete:
                            all_onboarded = False
                            break

                    if all_onboarded:
                        for event_id in projekt.timeline_events:
                            event = st.session_state.timeline_events.get(event_id)
                            if event and event.titel == "Onboarding-Dokumente akzeptieren" and not event.completed:
                                event.completed = True
                                event.completed_at = datetime.now()
                        update_projekt_status(projekt_id)

            st.success("‚úÖ Alle Dokumente akzeptiert!")
            st.rerun()
    else:
        st.info("‚è≥ Bitte akzeptieren Sie alle Dokumente, um fortzufahren.")

# ============================================================================
# K√ÑUFER-BEREICH
# ============================================================================

def kaeufer_dashboard():
    """Dashboard f√ºr K√§ufer"""
    st.title("üè† K√§ufer-Dashboard")

    if not st.session_state.current_user.onboarding_complete:
        onboarding_flow()
        return

    # Pflicht-Akzeptanz von Rechtsdokumenten pr√ºfen
    user_id = st.session_state.current_user.user_id
    if not render_rechtsdokumente_akzeptanz_pflicht(user_id, UserRole.KAEUFER.value):
        # User muss erst Dokumente akzeptieren
        return

    # Aktentasche in der Sidebar
    render_aktentasche_sidebar(user_id)

    # Benachrichtigungs-Badge in der Sidebar
    render_benachrichtigungs_badge(user_id)

    # Teilen-Dialog anzeigen falls aktiv
    render_aktentasche_teilen_dialog(user_id)

    # Download-Dialog anzeigen falls aktiv
    render_aktentasche_download(user_id)

    # Suchleiste
    search_term = render_dashboard_search("kaeufer")
    if search_term:
        st.session_state['kaeufer_search'] = search_term
    else:
        st.session_state['kaeufer_search'] = ''

    tabs = st.tabs([
        "üè† Mein Portal",  # NEU: Mandanten-Portal √úbersicht
        "üìä Timeline",
        "üìã Projekte",
        "üìù Aufgaben",
        "üí∞ Finanzierung",
        "üîß Handwerker",
        "ü™™ Ausweis",
        "üí¨ Nachrichten",
        "üìÑ Dokumente",
        "üîÑ Vertragsvergleich",  # NEU: Side-by-Side Diff
        "üìÖ Termine"
    ])

    with tabs[0]:
        # Mandanten-Portal √úbersicht
        render_mandanten_portal(user_id, UserRole.KAEUFER.value)

    with tabs[1]:
        kaeufer_timeline_view()

    with tabs[2]:
        kaeufer_projekte_view()

    with tabs[3]:
        kaeufer_aufgaben_view()

    with tabs[4]:
        kaeufer_finanzierung_view()

    with tabs[5]:
        kaeufer_handwerker_empfehlungen()

    with tabs[6]:
        # Personalausweis-Upload mit OCR
        st.subheader("ü™™ Ausweisdaten erfassen")
        render_ausweis_upload(st.session_state.current_user.user_id, UserRole.KAEUFER.value)

    with tabs[7]:
        kaeufer_nachrichten()

    with tabs[8]:
        kaeufer_dokumente_view()

    with tabs[9]:
        # Vertragsvergleich - Side-by-Side Diff
        st.subheader("üîÑ Vertragsversionen vergleichen")
        kaeufer_projekte = [p for p in st.session_state.projekte.values()
                           if user_id in p.kaeufer_ids]
        if kaeufer_projekte:
            projekt_auswahl = {p.projekt_id: p.name for p in kaeufer_projekte}
            selected_projekt_id = st.selectbox(
                "Projekt ausw√§hlen",
                list(projekt_auswahl.keys()),
                format_func=lambda x: projekt_auswahl[x],
                key="kaeufer_vertragsvergleich_projekt"
            )
            if selected_projekt_id:
                render_vertragsvergleich_tab(selected_projekt_id, user_id, UserRole.KAEUFER.value)
        else:
            st.info("Sie sind noch keinem Projekt zugewiesen.")

    with tabs[10]:
        # Termin-√úbersicht f√ºr K√§ufer mit Kalender
        st.subheader("üìÖ Meine Termine")
        user_id = st.session_state.current_user.user_id

        # Kalender-Ansicht
        termin_ansicht = st.tabs(["üìÖ Kalender", "üìã Nach Projekt"])

        with termin_ansicht[0]:
            # Vollst√§ndiger Kalender mit allen Terminen
            render_termin_kalender(user_id, UserRole.KAEUFER.value)

        with termin_ansicht[1]:
            # Projekt-basierte Ansicht
            projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids]
            if projekte:
                for projekt in projekte:
                    with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
                        render_termin_verwaltung(projekt, UserRole.KAEUFER.value)
            else:
                st.info("Noch keine Projekte vorhanden.")

def kaeufer_timeline_view():
    """Timeline f√ºr K√§ufer"""
    st.subheader("üìä Projekt-Fortschritt")

    user_id = st.session_state.current_user.user_id
    search_term = st.session_state.get('kaeufer_search', '')

    alle_projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids]
    projekte = filter_projekte_by_search(alle_projekte, search_term)

    display_search_results_info(len(alle_projekte), len(projekte), search_term)

    if not projekte:
        st.info("Keine Projekte gefunden." if search_term else "Noch keine Projekte vorhanden.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            render_timeline(projekt.projekt_id, UserRole.KAEUFER.value)

def kaeufer_projekte_view():
    """Projekt-Ansicht f√ºr K√§ufer"""
    st.subheader("üìã Meine Projekte")

    user_id = st.session_state.current_user.user_id
    search_term = st.session_state.get('kaeufer_search', '')

    alle_projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids]
    projekte = filter_projekte_by_search(alle_projekte, search_term)

    display_search_results_info(len(alle_projekte), len(projekte), search_term)

    if not projekte:
        st.info("Keine Projekte gefunden." if search_term else "Noch keine Projekte vorhanden.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            st.markdown(f"**Beschreibung:** {projekt.beschreibung}")
            if projekt.adresse:
                st.markdown(f"**Adresse:** {projekt.adresse}")
            if projekt.kaufpreis > 0:
                st.markdown(f"**Kaufpreis:** {format_euro(projekt.kaufpreis)} ‚Ç¨")

            if projekt.expose_pdf:
                col_dl, col_akt = st.columns(2)
                with col_dl:
                    st.download_button(
                        "üì• Expos√© herunterladen",
                        projekt.expose_pdf,
                        file_name=f"Expose_{projekt.name}.pdf",
                        mime="application/pdf",
                        use_container_width=True
                    )
                with col_akt:
                    render_zur_aktentasche_button(
                        user_id=user_id,
                        inhalt_typ=AktentascheInhaltTyp.EXPOSE.value,
                        titel=f"Expos√© {projekt.name}",
                        beschreibung=projekt.adresse or "",
                        referenz_id=projekt.projekt_id,
                        referenz_typ="Projekt",
                        dateiname=f"Expose_{projekt.name}.pdf",
                        dateigr√∂√üe=len(projekt.expose_pdf) if projekt.expose_pdf else 0,
                        pdf_data=projekt.expose_pdf,
                        projekt_id=projekt.projekt_id,
                        projekt_name=projekt.name,
                        key_suffix=f"expose_{projekt.projekt_id}"
                    )
            else:
                st.info("Expos√© wird vom Makler noch bereitgestellt.")

            # === PREISVERHANDLUNG ===
            if kann_preisverhandlung_fuehren(projekt, user_id, "K√§ufer"):
                st.markdown("---")
                st.markdown("### üí∞ Preisverhandlung")

                # Zeige aktuellen Verhandlungsstand
                angebote = get_preisangebote_fuer_projekt(projekt.projekt_id)
                letztes_offenes = get_letztes_offenes_angebot(projekt.projekt_id)

                if letztes_offenes:
                    von_user = st.session_state.users.get(letztes_offenes.von_user_id)
                    von_name = von_user.name if von_user else "Unbekannt"

                    if letztes_offenes.von_user_id == user_id:
                        # Eigenes offenes Angebot
                        st.info(f"‚è≥ Ihr Angebot √ºber **{format_euro(letztes_offenes.betrag)} ‚Ç¨** wartet auf Antwort des Verk√§ufers.")
                        if letztes_offenes.nachricht:
                            st.caption(f"Ihre Nachricht: {letztes_offenes.nachricht}")

                        if st.button("üîô Angebot zur√ºckziehen", key=f"zurueck_{letztes_offenes.angebot_id}"):
                            letztes_offenes.status = PreisangebotStatus.ZURUECKGEZOGEN.value
                            st.success("Angebot zur√ºckgezogen.")
                            st.rerun()
                    else:
                        # Offenes Angebot vom Verk√§ufer
                        st.warning(f"üì¨ **{von_name}** bietet **{format_euro(letztes_offenes.betrag)} ‚Ç¨**")
                        if letztes_offenes.nachricht:
                            st.caption(f"Nachricht: {letztes_offenes.nachricht}")

                        col1, col2, col3 = st.columns(3)
                        with col1:
                            if st.button("‚úÖ Annehmen", key=f"annehmen_{letztes_offenes.angebot_id}"):
                                respond_to_preisangebot(letztes_offenes.angebot_id, PreisangebotStatus.ANGENOMMEN.value)
                                st.success("Angebot angenommen!")
                                st.rerun()
                        with col2:
                            if st.button("‚ùå Ablehnen", key=f"ablehnen_{letztes_offenes.angebot_id}"):
                                respond_to_preisangebot(letztes_offenes.angebot_id, PreisangebotStatus.ABGELEHNT.value)
                                st.warning("Angebot abgelehnt.")
                                st.rerun()
                        with col3:
                            if st.button("üí¨ Gegenangebot", key=f"gegen_{letztes_offenes.angebot_id}"):
                                st.session_state[f"zeige_gegenangebot_{projekt.projekt_id}"] = True

                        if st.session_state.get(f"zeige_gegenangebot_{projekt.projekt_id}"):
                            gegen_betrag = st.number_input(
                                "Ihr Gegenangebot (‚Ç¨)",
                                min_value=0.0,
                                value=float(letztes_offenes.betrag),
                                step=1000.0,
                                key=f"gegen_betrag_{projekt.projekt_id}"
                            )
                            gegen_nachricht = st.text_input("Nachricht (optional)", key=f"gegen_msg_{projekt.projekt_id}")
                            if st.button("üì§ Gegenangebot senden", key=f"sende_gegen_{projekt.projekt_id}"):
                                respond_to_preisangebot(
                                    letztes_offenes.angebot_id,
                                    PreisangebotStatus.GEGENANGEBOT.value,
                                    gegen_nachricht,
                                    gegen_betrag
                                )
                                st.session_state[f"zeige_gegenangebot_{projekt.projekt_id}"] = False
                                st.success("Gegenangebot gesendet!")
                                st.rerun()
                else:
                    # Kein offenes Angebot - neues Angebot machen
                    st.markdown("**Neues Preisangebot abgeben:**")
                    angebot_betrag = st.number_input(
                        "Ihr Angebot (‚Ç¨)",
                        min_value=0.0,
                        value=float(projekt.kaufpreis) if projekt.kaufpreis > 0 else 0.0,
                        step=1000.0,
                        key=f"neues_angebot_{projekt.projekt_id}"
                    )
                    angebot_nachricht = st.text_input("Nachricht an Verk√§ufer (optional)", key=f"msg_{projekt.projekt_id}")

                    if st.button("üì§ Angebot senden", key=f"sende_{projekt.projekt_id}"):
                        create_preisangebot(
                            projekt_id=projekt.projekt_id,
                            von_user_id=user_id,
                            von_rolle="K√§ufer",
                            betrag=angebot_betrag,
                            nachricht=angebot_nachricht
                        )
                        st.success(f"Angebot √ºber {format_euro(angebot_betrag)} ‚Ç¨ gesendet!")
                        st.rerun()

                # Zeige Verhandlungsverlauf
                if angebote:
                    with st.expander("üìú Verhandlungsverlauf", expanded=False):
                        for angebot in angebote:
                            von_user = st.session_state.users.get(angebot.von_user_id)
                            von_name = von_user.name if von_user else "Unbekannt"
                            status_icon = {
                                PreisangebotStatus.OFFEN.value: "‚è≥",
                                PreisangebotStatus.ANGENOMMEN.value: "‚úÖ",
                                PreisangebotStatus.ABGELEHNT.value: "‚ùå",
                                PreisangebotStatus.GEGENANGEBOT.value: "üí¨",
                                PreisangebotStatus.ZURUECKGEZOGEN.value: "üîô"
                            }.get(angebot.status, "‚ùì")

                            st.markdown(f"""
                            {status_icon} **{format_euro(angebot.betrag)} ‚Ç¨** von {von_name} ({angebot.von_rolle})
                            - Status: {angebot.status}
                            - Datum: {angebot.erstellt_am.strftime('%d.%m.%Y %H:%M')}
                            {"- Nachricht: " + angebot.nachricht if angebot.nachricht else ""}
                            """)
            elif projekt.makler_id:
                # Makler vorhanden aber Verhandlung nicht erlaubt
                st.markdown("---")
                st.info("üí° Preisverhandlungen sind f√ºr dieses Projekt nicht aktiviert. Bei Interesse wenden Sie sich an den Makler.")


def generate_handwerker_steckbrief(handwerker: 'Handwerker') -> str:
    """
    Generiert ein druckbares HTML-Steckbrief/Expos√© f√ºr einen Handwerker.
    Enth√§lt alle Kontaktdaten und Beschreibung in einem professionellen Layout.
    """
    sterne = "‚≠ê" * handwerker.bewertung if handwerker.bewertung > 0 else "Keine Bewertung"

    html = f"""<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steckbrief - {handwerker.firmenname}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }}
        .steckbrief {{
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }}
        .header {{
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }}
        .header h1 {{
            font-size: 28px;
            margin-bottom: 10px;
        }}
        .header .kategorie {{
            font-size: 16px;
            opacity: 0.9;
            background: rgba(255,255,255,0.2);
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
        }}
        .content {{
            padding: 30px;
        }}
        .bewertung {{
            text-align: center;
            font-size: 24px;
            margin-bottom: 20px;
        }}
        .beschreibung {{
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            border-left: 4px solid #2563eb;
        }}
        .beschreibung h3 {{
            color: #2563eb;
            margin-bottom: 10px;
        }}
        .kontakt {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }}
        .kontakt-item {{
            display: flex;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }}
        .kontakt-item .icon {{
            font-size: 24px;
            margin-right: 15px;
            width: 40px;
            text-align: center;
        }}
        .kontakt-item .label {{
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }}
        .kontakt-item .value {{
            font-size: 16px;
            font-weight: 500;
        }}
        .footer {{
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            font-size: 12px;
            color: #666;
        }}
        @media print {{
            body {{
                background: white;
                padding: 0;
            }}
            .steckbrief {{
                box-shadow: none;
            }}
        }}
    </style>
</head>
<body>
    <div class="steckbrief">
        <div class="header">
            <h1>{handwerker.firmenname}</h1>
            <span class="kategorie">üîß {handwerker.kategorie}</span>
        </div>

        <div class="content">
            <div class="bewertung">{sterne}</div>

            <div class="beschreibung">
                <h3>üìù √úber uns</h3>
                <p>{handwerker.beschreibung or 'Keine Beschreibung verf√ºgbar.'}</p>
            </div>

            <h3 style="margin-bottom: 15px; color: #333;">üìû Kontaktdaten</h3>
            <div class="kontakt">
                {"<div class='kontakt-item'><span class='icon'>üë§</span><div><div class='label'>Ansprechpartner</div><div class='value'>" + handwerker.kontaktperson + "</div></div></div>" if handwerker.kontaktperson else ""}

                {"<div class='kontakt-item'><span class='icon'>üìû</span><div><div class='label'>Telefon</div><div class='value'>" + handwerker.telefon + "</div></div></div>" if handwerker.telefon else ""}

                {"<div class='kontakt-item'><span class='icon'>üìß</span><div><div class='label'>E-Mail</div><div class='value'>" + handwerker.email + "</div></div></div>" if handwerker.email else ""}

                {"<div class='kontakt-item'><span class='icon'>üìç</span><div><div class='label'>Adresse</div><div class='value'>" + handwerker.adresse + "</div></div></div>" if handwerker.adresse else ""}

                {"<div class='kontakt-item'><span class='icon'>üåê</span><div><div class='label'>Webseite</div><div class='value'>" + handwerker.webseite + "</div></div></div>" if handwerker.webseite else ""}
            </div>
        </div>

        <div class="footer">
            <p>Dieser Steckbrief wurde √ºber die Immobilien-Transaktionsplattform erstellt.</p>
            <p>Empfohlen vom Notar | Erstellt am {datetime.now().strftime('%d.%m.%Y')}</p>
        </div>
    </div>

    <script>
        // Automatisch Druckdialog √∂ffnen
        // window.print();
    </script>
</body>
</html>"""

    return html


def kaeufer_handwerker_empfehlungen():
    """Zeigt vom Notar empfohlene Handwerker"""
    st.subheader("üîß Handwerker-Empfehlungen")
    st.caption("Hier finden Sie vom Notar empfohlene Handwerker f√ºr Renovierungen, Umbauten und mehr.")

    # Sicherstellen, dass handwerker_empfehlungen existiert
    if 'handwerker_empfehlungen' not in st.session_state:
        st.session_state.handwerker_empfehlungen = {}

    # Notar-IDs der K√§ufer-Projekte ermitteln
    user_id = st.session_state.current_user.user_id
    meine_projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids]
    meine_notar_ids = list(set(p.notar_id for p in meine_projekte if p.notar_id))

    # Nur freigegebene Handwerker vom zugewiesenen Notar anzeigen
    empfohlene_handwerker = [
        h for h in st.session_state.handwerker_empfehlungen.values()
        if h.empfohlen and h.notar_id in meine_notar_ids
    ]

    if not empfohlene_handwerker:
        if not meine_notar_ids:
            st.info("Ihren Projekten ist noch kein Notar zugewiesen.")
        else:
            st.info("Der Notar hat noch keine Handwerker-Empfehlungen hinterlegt.")
        return

    # Filter nach Kategorie
    kategorien_vorhanden = list(set(h.kategorie for h in empfohlene_handwerker))
    filter_kategorie = st.selectbox(
        "Nach Kategorie filtern",
        options=["Alle"] + sorted(kategorien_vorhanden),
        key="kaeufer_hw_filter"
    )

    if filter_kategorie != "Alle":
        empfohlene_handwerker = [h for h in empfohlene_handwerker if h.kategorie == filter_kategorie]

    # Gruppiert nach Kategorie anzeigen
    kategorien = {}
    for hw in empfohlene_handwerker:
        if hw.kategorie not in kategorien:
            kategorien[hw.kategorie] = []
        kategorien[hw.kategorie].append(hw)

    for kategorie, handwerker_liste in sorted(kategorien.items()):
        with st.expander(f"üîß {kategorie} ({len(handwerker_liste)})", expanded=True):
            for hw in handwerker_liste:
                col1, col2 = st.columns([0.7, 0.3])

                with col1:
                    # Sterne-Bewertung
                    sterne = "‚≠ê" * hw.bewertung if hw.bewertung > 0 else ""
                    st.markdown(f"### {hw.firmenname} {sterne}")

                    if hw.beschreibung:
                        st.write(hw.beschreibung)

                    # Kontaktdaten
                    kontakt_info = []
                    if hw.kontaktperson:
                        kontakt_info.append(f"üë§ **Ansprechpartner:** {hw.kontaktperson}")
                    if hw.telefon:
                        kontakt_info.append(f"üìû **Telefon:** {hw.telefon}")
                    if hw.email:
                        kontakt_info.append(f"üìß **E-Mail:** {hw.email}")
                    if hw.adresse:
                        kontakt_info.append(f"üìç **Adresse:** {hw.adresse}")

                    if kontakt_info:
                        st.markdown("  \n".join(kontakt_info))

                with col2:
                    if hw.webseite:
                        st.markdown(f"üåê [Webseite besuchen]({hw.webseite if hw.webseite.startswith('http') else 'https://' + hw.webseite})")

                    # Steckbrief-Download Button
                    steckbrief_html = generate_handwerker_steckbrief(hw)
                    st.download_button(
                        label="üìÑ Steckbrief",
                        data=steckbrief_html,
                        file_name=f"Steckbrief_{hw.firmenname.replace(' ', '_')}.html",
                        mime="text/html",
                        key=f"steckbrief_{hw.handwerker_id}"
                    )

                    # VERBESSERUNG 7: Bewertung abgeben
                    # Pr√ºfen ob K√§ufer schon bewertet hat
                    meine_bewertung = None
                    for bew in st.session_state.get('handwerker_bewertungen', {}).values():
                        if bew.handwerker_id == hw.handwerker_id and bew.kaeufer_id == user_id:
                            meine_bewertung = bew
                            break

                    if meine_bewertung:
                        st.success(f"‚úÖ Ihre Bewertung: {'‚≠ê' * meine_bewertung.sterne}")
                    else:
                        if st.button("‚≠ê Bewerten", key=f"rate_btn_{hw.handwerker_id}"):
                            st.session_state[f"show_rating_{hw.handwerker_id}"] = True

                    if st.session_state.get(f"show_rating_{hw.handwerker_id}"):
                        st.markdown("**Ihre Bewertung:**")
                        new_rating = st.slider(
                            "Sterne",
                            min_value=1,
                            max_value=5,
                            value=4,
                            key=f"rating_slider_{hw.handwerker_id}"
                        )
                        kommentar = st.text_area(
                            "Kommentar (optional)",
                            key=f"rating_comment_{hw.handwerker_id}",
                            height=80
                        )
                        if st.button("üíæ Bewertung speichern", key=f"save_rating_{hw.handwerker_id}"):
                            # Bewertung speichern
                            bewertung_id = f"hwbew_{len(st.session_state.get('handwerker_bewertungen', {}))}_{datetime.now().strftime('%Y%m%d%H%M%S')}"
                            neue_bewertung = HandwerkerBewertung(
                                bewertung_id=bewertung_id,
                                handwerker_id=hw.handwerker_id,
                                kaeufer_id=user_id,
                                projekt_id=meine_projekte[0].projekt_id if meine_projekte else "",
                                sterne=new_rating,
                                kommentar=kommentar
                            )
                            if 'handwerker_bewertungen' not in st.session_state:
                                st.session_state.handwerker_bewertungen = {}
                            st.session_state.handwerker_bewertungen[bewertung_id] = neue_bewertung

                            # Durchschnittsbewertung aktualisieren
                            alle_bewertungen = [
                                b.sterne for b in st.session_state.handwerker_bewertungen.values()
                                if b.handwerker_id == hw.handwerker_id
                            ]
                            hw.bewertung = round(sum(alle_bewertungen) / len(alle_bewertungen))
                            hw.anzahl_bewertungen = len(alle_bewertungen)

                            st.session_state[f"show_rating_{hw.handwerker_id}"] = False
                            st.success("‚úÖ Vielen Dank f√ºr Ihre Bewertung!")
                            st.rerun()

                # Anzahl Bewertungen anzeigen
                if getattr(hw, 'anzahl_bewertungen', 0) > 0:
                    st.caption(f"üìä {hw.anzahl_bewertungen} Bewertung(en)")

                st.markdown("---")


def generate_system_todos(user_id: str, projekt_id: str) -> List[KaeuferTodo]:
    """Generiert System-Todos basierend auf Projekt-Status"""
    import uuid
    system_todos = []

    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt:
        return system_todos

    # Finanzierungsanfragen abrufen
    anfragen = [a for a in st.session_state.get('finanzierungsanfragen', {}).values()
                if a.kaeufer_id == user_id and a.projekt_id == projekt_id]

    # Finanzierungsangebote abrufen
    angebote = [o for o in st.session_state.financing_offers.values()
                if o.projekt_id == projekt_id and o.status == FinanzierungsStatus.ANGENOMMEN.value]

    # Wirtschaftsdaten abrufen
    wirtschaftsdaten = [d for d in st.session_state.wirtschaftsdaten.values()
                       if d.kaeufer_id == user_id]

    # ============ FINANZIERUNG TODOS ============
    if not anfragen:
        system_todos.append(KaeuferTodo(
            todo_id=f"sys_fin_anfrage_{projekt_id}",
            kaeufer_id=user_id,
            projekt_id=projekt_id,
            titel="Finanzierungsanfrage stellen",
            beschreibung="Stellen Sie eine Finanzierungsanfrage, um Angebote von Finanzierern zu erhalten.",
            kategorie=TodoKategorie.FINANZIERUNG.value,
            prioritaet=TodoPrioritaet.HOCH.value,
            ist_system_todo=True,
            system_typ="finanzierung_anfrage"
        ))

    if not wirtschaftsdaten:
        system_todos.append(KaeuferTodo(
            todo_id=f"sys_wirtschaftsdaten_{projekt_id}",
            kaeufer_id=user_id,
            projekt_id=projekt_id,
            titel="Wirtschaftsdaten hochladen",
            beschreibung="Laden Sie Gehaltsnachweise, Steuerbescheide oder andere Bonit√§tsunterlagen hoch.",
            kategorie=TodoKategorie.FINANZIERUNG.value,
            prioritaet=TodoPrioritaet.HOCH.value,
            ist_system_todo=True,
            system_typ="wirtschaftsdaten_upload"
        ))
    elif len(wirtschaftsdaten) < 3:
        system_todos.append(KaeuferTodo(
            todo_id=f"sys_mehr_wirtschaftsdaten_{projekt_id}",
            kaeufer_id=user_id,
            projekt_id=projekt_id,
            titel="Weitere Bonit√§tsunterlagen hochladen",
            beschreibung=f"Bisher {len(wirtschaftsdaten)} Dokument(e) hochgeladen. Mehr Unterlagen verbessern Ihre Finanzierungschancen.",
            kategorie=TodoKategorie.FINANZIERUNG.value,
            prioritaet=TodoPrioritaet.MITTEL.value,
            ist_system_todo=True,
            system_typ="wirtschaftsdaten_mehr"
        ))

    if anfragen and not angebote:
        system_todos.append(KaeuferTodo(
            todo_id=f"sys_angebot_pruefen_{projekt_id}",
            kaeufer_id=user_id,
            projekt_id=projekt_id,
            titel="Finanzierungsangebote pr√ºfen",
            beschreibung="Warten Sie auf Angebote von Finanzierern und pr√ºfen Sie diese.",
            kategorie=TodoKategorie.FINANZIERUNG.value,
            prioritaet=TodoPrioritaet.HOCH.value,
            ist_system_todo=True,
            system_typ="angebot_pruefen"
        ))

    # ============ DOKUMENTE TODOS ============
    # Ausweisdaten pr√ºfen
    ausweis = st.session_state.get('ausweisdaten', {}).get(user_id)
    if not ausweis:
        system_todos.append(KaeuferTodo(
            todo_id=f"sys_ausweis_{projekt_id}",
            kaeufer_id=user_id,
            projekt_id=projekt_id,
            titel="Personalausweis erfassen",
            beschreibung="Laden Sie Ihren Personalausweis f√ºr die Identifikation hoch.",
            kategorie=TodoKategorie.DOKUMENTE.value,
            prioritaet=TodoPrioritaet.HOCH.value,
            ist_system_todo=True,
            system_typ="ausweis_upload"
        ))

    # ============ KAUFVERTRAG TODOS ============
    # Pr√ºfen, ob Rechtsdokumente akzeptiert wurden
    akzeptiert = st.session_state.get('document_acceptances', [])
    user_akzeptiert = [a for a in akzeptiert if a.user_id == user_id]

    benoetigte_docs = [DocumentType.DATENSCHUTZ.value, DocumentType.WIDERRUFSBELEHRUNG.value]
    akzeptierte_typen = [a.document_type for a in user_akzeptiert]

    for doc_type in benoetigte_docs:
        if doc_type not in akzeptierte_typen:
            system_todos.append(KaeuferTodo(
                todo_id=f"sys_doc_{doc_type}_{projekt_id}",
                kaeufer_id=user_id,
                projekt_id=projekt_id,
                titel=f"{doc_type} akzeptieren",
                beschreibung=f"Bitte lesen und akzeptieren Sie die {doc_type}.",
                kategorie=TodoKategorie.KAUFVERTRAG.value,
                prioritaet=TodoPrioritaet.HOCH.value,
                ist_system_todo=True,
                system_typ=f"doc_akzeptieren_{doc_type}"
            ))

    # Finanzierung gesichert?
    if angebote:
        system_todos.append(KaeuferTodo(
            todo_id=f"sys_finanzierung_bestaetigen_{projekt_id}",
            kaeufer_id=user_id,
            projekt_id=projekt_id,
            titel="Finanzierungszusage abwarten",
            beschreibung="Warten Sie auf die verbindliche Finanzierungszusage Ihrer Bank.",
            kategorie=TodoKategorie.KAUFVERTRAG.value,
            prioritaet=TodoPrioritaet.HOCH.value,
            ist_system_todo=True,
            system_typ="finanzierung_zusage"
        ))

    # Notartermin
    if projekt.status not in [ProjektStatus.NOTARTERMIN_VEREINBART.value,
                               ProjektStatus.KAUFVERTRAG_UNTERZEICHNET.value,
                               ProjektStatus.ABGESCHLOSSEN.value]:
        if angebote:  # Nur wenn Finanzierung l√§uft
            system_todos.append(KaeuferTodo(
                todo_id=f"sys_notartermin_{projekt_id}",
                kaeufer_id=user_id,
                projekt_id=projekt_id,
                titel="Notartermin vorbereiten",
                beschreibung="Sobald die Finanzierung gesichert ist, kann der Notartermin vereinbart werden.",
                kategorie=TodoKategorie.KAUFVERTRAG.value,
                prioritaet=TodoPrioritaet.MITTEL.value,
                ist_system_todo=True,
                system_typ="notartermin"
            ))

    return system_todos


def kaeufer_aufgaben_view():
    """Aufgaben-/Todo-Liste f√ºr K√§ufer"""
    import uuid

    st.subheader("üìù Meine Aufgaben")

    user_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids]

    if not projekte:
        st.info("Sie sind noch keinem Projekt zugeordnet. Aufgaben werden angezeigt, sobald Sie einem Projekt hinzugef√ºgt wurden.")
        return

    # Sicherstellen, dass kaeufer_todos existiert
    if 'kaeufer_todos' not in st.session_state:
        st.session_state.kaeufer_todos = {}

    # Projekt ausw√§hlen
    projekt_namen = {p.projekt_id: p.name for p in projekte}
    selected_projekt_id = st.selectbox(
        "Projekt ausw√§hlen",
        options=list(projekt_namen.keys()),
        format_func=lambda x: projekt_namen[x],
        key="aufgaben_projekt_select"
    )

    st.markdown("---")

    # Tabs f√ºr System-Todos, eigene Todos und Ideenboard
    aufgaben_tabs = st.tabs([
        "üîî Offene Aufgaben",
        "‚úÖ Erledigte Aufgaben",
        "‚ûï Eigene Aufgabe erstellen",
        "üí° Ideenboard"
    ])

    with aufgaben_tabs[0]:
        render_offene_aufgaben(user_id, selected_projekt_id)

    with aufgaben_tabs[1]:
        render_erledigte_aufgaben(user_id, selected_projekt_id)

    with aufgaben_tabs[2]:
        render_neue_aufgabe_form(user_id, selected_projekt_id)

    with aufgaben_tabs[3]:
        render_ideenboard(user_id, selected_projekt_id)


def render_offene_aufgaben(user_id: str, projekt_id: str):
    """Zeigt offene Aufgaben (System + eigene)"""

    # System-Todos generieren
    system_todos = generate_system_todos(user_id, projekt_id)

    # Eigene unerledigte Todos laden
    eigene_todos = [t for t in st.session_state.kaeufer_todos.values()
                   if t.kaeufer_id == user_id
                   and t.projekt_id == projekt_id
                   and not t.erledigt
                   and not t.ist_system_todo]

    # Filter-Optionen
    col1, col2 = st.columns(2)
    with col1:
        filter_kategorie = st.selectbox(
            "Nach Kategorie filtern",
            options=["Alle"] + [k.value for k in TodoKategorie],
            key="filter_kategorie_offen"
        )
    with col2:
        filter_prioritaet = st.selectbox(
            "Nach Priorit√§t filtern",
            options=["Alle"] + [p.value for p in TodoPrioritaet],
            key="filter_prioritaet_offen"
        )

    # Alle offenen Todos kombinieren
    alle_todos = system_todos + eigene_todos

    # Filtern
    if filter_kategorie != "Alle":
        alle_todos = [t for t in alle_todos if t.kategorie == filter_kategorie]
    if filter_prioritaet != "Alle":
        alle_todos = [t for t in alle_todos if t.prioritaet == filter_prioritaet]

    # Nach Priorit√§t sortieren
    prioritaet_order = {TodoPrioritaet.HOCH.value: 0, TodoPrioritaet.MITTEL.value: 1, TodoPrioritaet.NIEDRIG.value: 2}
    alle_todos.sort(key=lambda t: (prioritaet_order.get(t.prioritaet, 99), t.kategorie))

    if not alle_todos:
        st.success("üéâ Keine offenen Aufgaben! Alles erledigt.")
        return

    # Gruppiert nach Kategorie anzeigen
    kategorien = {}
    for todo in alle_todos:
        if todo.kategorie not in kategorien:
            kategorien[todo.kategorie] = []
        kategorien[todo.kategorie].append(todo)

    # Kategorie-Reihenfolge
    kategorie_order = [
        TodoKategorie.FINANZIERUNG.value,
        TodoKategorie.KAUFVERTRAG.value,
        TodoKategorie.DOKUMENTE.value,
        TodoKategorie.AUSSTATTUNG.value,
        TodoKategorie.UMZUG.value,
        TodoKategorie.SONSTIGES.value
    ]

    for kategorie in kategorie_order:
        if kategorie in kategorien:
            with st.expander(f"üìÅ {kategorie} ({len(kategorien[kategorie])})", expanded=True):
                for todo in kategorien[kategorie]:
                    render_todo_item(todo, user_id)


def render_todo_item(todo: KaeuferTodo, user_id: str):
    """Rendert ein einzelnes Todo-Item"""
    col1, col2, col3 = st.columns([0.1, 0.7, 0.2])

    # Priorit√§ts-Icon
    prio_icons = {
        TodoPrioritaet.HOCH.value: "üî¥",
        TodoPrioritaet.MITTEL.value: "üü°",
        TodoPrioritaet.NIEDRIG.value: "üü¢"
    }
    prio_icon = prio_icons.get(todo.prioritaet, "‚ö™")

    with col1:
        # Checkbox zum Erledigen (nur f√ºr eigene Todos oder wenn System-Todo als erledigt markierbar)
        if not todo.ist_system_todo:
            if st.checkbox("", key=f"check_{todo.todo_id}", value=todo.erledigt):
                # Als erledigt markieren
                if todo.todo_id in st.session_state.kaeufer_todos:
                    st.session_state.kaeufer_todos[todo.todo_id].erledigt = True
                    st.session_state.kaeufer_todos[todo.todo_id].erledigt_am = datetime.now()
                    st.rerun()
        else:
            st.markdown(f"{prio_icon}")

    with col2:
        # Titel und Beschreibung
        if todo.ist_system_todo:
            st.markdown(f"**{todo.titel}** `System`")
        else:
            st.markdown(f"**{todo.titel}**")
        if todo.beschreibung:
            st.caption(todo.beschreibung)
        if todo.faellig_am:
            days_left = (todo.faellig_am - date.today()).days
            if days_left < 0:
                st.markdown(f"‚ö†Ô∏è **√úberf√§llig** seit {abs(days_left)} Tag(en)")
            elif days_left == 0:
                st.markdown("‚è∞ **Heute f√§llig**")
            elif days_left <= 3:
                st.markdown(f"üìÖ F√§llig in {days_left} Tag(en)")

    with col3:
        st.caption(f"{prio_icon} {todo.prioritaet}")
        if not todo.ist_system_todo:
            if st.button("üóëÔ∏è", key=f"del_{todo.todo_id}", help="Aufgabe l√∂schen"):
                if todo.todo_id in st.session_state.kaeufer_todos:
                    del st.session_state.kaeufer_todos[todo.todo_id]
                    st.rerun()

    st.markdown("---")


def render_erledigte_aufgaben(user_id: str, projekt_id: str):
    """Zeigt erledigte Aufgaben"""

    # Erledigte Todos laden
    erledigte_todos = [t for t in st.session_state.kaeufer_todos.values()
                      if t.kaeufer_id == user_id
                      and t.projekt_id == projekt_id
                      and t.erledigt]

    if not erledigte_todos:
        st.info("Noch keine erledigten Aufgaben.")
        return

    # Nach Erledigt-Datum sortieren (neueste zuerst)
    erledigte_todos.sort(key=lambda t: t.erledigt_am or datetime.min, reverse=True)

    for todo in erledigte_todos:
        col1, col2, col3 = st.columns([0.1, 0.7, 0.2])

        with col1:
            if st.checkbox("", key=f"uncheck_{todo.todo_id}", value=True):
                pass  # Bleibt erledigt
            else:
                # Als unerledigt markieren
                st.session_state.kaeufer_todos[todo.todo_id].erledigt = False
                st.session_state.kaeufer_todos[todo.todo_id].erledigt_am = None
                st.rerun()

        with col2:
            st.markdown(f"~~{todo.titel}~~")
            if todo.erledigt_am:
                st.caption(f"Erledigt am {todo.erledigt_am.strftime('%d.%m.%Y %H:%M')}")

        with col3:
            st.caption(todo.kategorie)

        st.markdown("---")


def render_neue_aufgabe_form(user_id: str, projekt_id: str):
    """Formular zum Erstellen einer neuen Aufgabe"""
    import uuid

    st.markdown("### ‚ûï Neue Aufgabe erstellen")
    st.caption("Erstellen Sie eigene Aufgaben, z.B. f√ºr Ausstattungsideen, Umzugsplanung oder andere Notizen.")

    with st.form("neue_aufgabe_form"):
        titel = st.text_input("Titel *", placeholder="z.B. K√ºchenm√∂bel recherchieren")
        beschreibung = st.text_area("Beschreibung", placeholder="Weitere Details zur Aufgabe...")

        col1, col2 = st.columns(2)
        with col1:
            kategorie = st.selectbox(
                "Kategorie",
                options=[k.value for k in TodoKategorie],
                index=3  # Default: Ausstattung & Ideen
            )
        with col2:
            prioritaet = st.selectbox(
                "Priorit√§t",
                options=[p.value for p in TodoPrioritaet],
                index=1  # Default: Mittel
            )

        faellig_am = st.date_input(
            "F√§llig am (optional)",
            value=None,
            min_value=date.today()
        )

        submitted = st.form_submit_button("‚úÖ Aufgabe erstellen", use_container_width=True)

        if submitted:
            if not titel.strip():
                st.error("Bitte geben Sie einen Titel ein.")
            else:
                todo_id = f"todo_{uuid.uuid4().hex[:8]}"
                neue_aufgabe = KaeuferTodo(
                    todo_id=todo_id,
                    kaeufer_id=user_id,
                    projekt_id=projekt_id,
                    titel=titel.strip(),
                    beschreibung=beschreibung.strip(),
                    kategorie=kategorie,
                    prioritaet=prioritaet,
                    faellig_am=faellig_am,
                    ist_system_todo=False
                )
                st.session_state.kaeufer_todos[todo_id] = neue_aufgabe
                st.success(f"‚úÖ Aufgabe '{titel}' wurde erstellt!")
                st.rerun()


def render_ideenboard(user_id: str, projekt_id: str):
    """Ideenboard f√ºr kreative Ideen zum neuen Objekt"""
    import uuid

    st.markdown("### üí° Ideenboard")
    st.caption("""
    Sammeln Sie hier kreative Ideen f√ºr Ihr neues Objekt: Einrichtung, Renovierungsma√ünahmen,
    Lichtkonzepte, Smart Home und vieles mehr. Lassen Sie sich inspirieren!
    """)

    # Sicherstellen, dass ideenboard existiert
    if 'ideenboard' not in st.session_state:
        st.session_state.ideenboard = {}

    # Tabs f√ºr Ideen anzeigen und neue erstellen
    ideen_tabs = st.tabs(["üé® Meine Ideen", "‚ûï Neue Idee hinzuf√ºgen"])

    with ideen_tabs[0]:
        # Filter nach Kategorie
        col1, col2 = st.columns(2)
        with col1:
            filter_kategorie = st.selectbox(
                "Nach Kategorie filtern",
                options=["Alle"] + [k.value for k in IdeenKategorie],
                key="ideen_filter_kat"
            )
        with col2:
            show_umgesetzt = st.checkbox("Umgesetzte Ideen anzeigen", value=False, key="show_umgesetzt")

        # Ideen laden
        alle_ideen = [i for i in st.session_state.ideenboard.values()
                     if i.kaeufer_id == user_id and i.projekt_id == projekt_id]

        # Filtern
        if filter_kategorie != "Alle":
            alle_ideen = [i for i in alle_ideen if i.kategorie == filter_kategorie]
        if not show_umgesetzt:
            alle_ideen = [i for i in alle_ideen if not i.umgesetzt]

        # Sortieren nach Priorit√§t
        prioritaet_order = {TodoPrioritaet.HOCH.value: 0, TodoPrioritaet.MITTEL.value: 1, TodoPrioritaet.NIEDRIG.value: 2}
        alle_ideen.sort(key=lambda i: (prioritaet_order.get(i.prioritaet, 99), i.erstellt_am), reverse=False)

        if not alle_ideen:
            st.info("Noch keine Ideen vorhanden. Erstellen Sie Ihre erste Idee im Tab 'Neue Idee hinzuf√ºgen'.")
        else:
            # Gruppiert nach Kategorie anzeigen
            kategorien = {}
            for idee in alle_ideen:
                if idee.kategorie not in kategorien:
                    kategorien[idee.kategorie] = []
                kategorien[idee.kategorie].append(idee)

            for kategorie, ideen_liste in sorted(kategorien.items()):
                with st.expander(f"üí° {kategorie} ({len(ideen_liste)})", expanded=True):
                    for idee in ideen_liste:
                        render_idee_item(idee)

    with ideen_tabs[1]:
        st.markdown("### ‚ûï Neue Idee hinzuf√ºgen")

        with st.form("neue_idee_form"):
            titel = st.text_input("Titel *", placeholder="z.B. Offene K√ºche mit Kochinsel")
            beschreibung = st.text_area(
                "Beschreibung",
                placeholder="Beschreiben Sie Ihre Idee... Was stellen Sie sich vor? Welche Materialien, Farben, Stil?"
            )

            col1, col2 = st.columns(2)
            with col1:
                kategorie = st.selectbox(
                    "Kategorie",
                    options=[k.value for k in IdeenKategorie]
                )
            with col2:
                prioritaet = st.selectbox(
                    "Priorit√§t",
                    options=[p.value for p in TodoPrioritaet],
                    index=1
                )

            col3, col4 = st.columns(2)
            with col3:
                geschaetzte_kosten = st.number_input(
                    "Gesch√§tzte Kosten (‚Ç¨)",
                    min_value=0.0,
                    step=100.0,
                    value=0.0
                )
            with col4:
                bild_url = st.text_input(
                    "Inspirationsbild URL (optional)",
                    placeholder="https://..."
                )

            notizen = st.text_area(
                "Notizen",
                placeholder="Weitere Notizen, Links zu Produkten, Handwerkerkontakte..."
            )

            submitted = st.form_submit_button("üí° Idee speichern", use_container_width=True)

            if submitted:
                if not titel.strip():
                    st.error("Bitte geben Sie einen Titel ein.")
                else:
                    idee_id = f"idee_{uuid.uuid4().hex[:8]}"
                    neue_idee = IdeenboardEintrag(
                        idee_id=idee_id,
                        kaeufer_id=user_id,
                        projekt_id=projekt_id,
                        titel=titel.strip(),
                        beschreibung=beschreibung.strip(),
                        kategorie=kategorie,
                        prioritaet=prioritaet,
                        geschaetzte_kosten=geschaetzte_kosten,
                        bild_url=bild_url.strip(),
                        notizen=notizen.strip()
                    )
                    st.session_state.ideenboard[idee_id] = neue_idee
                    st.success(f"üí° Idee '{titel}' wurde gespeichert!")
                    st.rerun()


def render_idee_item(idee: IdeenboardEintrag):
    """Rendert einen einzelnen Ideenboard-Eintrag"""
    prio_icons = {
        TodoPrioritaet.HOCH.value: "üî¥",
        TodoPrioritaet.MITTEL.value: "üü°",
        TodoPrioritaet.NIEDRIG.value: "üü¢"
    }
    prio_icon = prio_icons.get(idee.prioritaet, "‚ö™")

    col1, col2, col3 = st.columns([0.6, 0.25, 0.15])

    with col1:
        if idee.umgesetzt:
            st.markdown(f"~~**{idee.titel}**~~ ‚úÖ Umgesetzt")
        else:
            st.markdown(f"**{idee.titel}** {prio_icon}")

        if idee.beschreibung:
            st.caption(idee.beschreibung)

        if idee.geschaetzte_kosten > 0:
            st.caption(f"üí∞ Gesch√§tzte Kosten: {format_euro(idee.geschaetzte_kosten)} ‚Ç¨")

    with col2:
        if idee.bild_url:
            st.caption(f"üñºÔ∏è [Inspirationsbild]({idee.bild_url})")
        if idee.notizen:
            with st.expander("üìù Notizen"):
                st.write(idee.notizen)

    with col3:
        if not idee.umgesetzt:
            if st.button("‚úÖ Umgesetzt", key=f"done_idee_{idee.idee_id}"):
                st.session_state.ideenboard[idee.idee_id].umgesetzt = True
                st.session_state.ideenboard[idee.idee_id].umgesetzt_am = datetime.now()
                st.rerun()
        else:
            if st.button("‚Ü©Ô∏è Reaktivieren", key=f"undo_idee_{idee.idee_id}"):
                st.session_state.ideenboard[idee.idee_id].umgesetzt = False
                st.session_state.ideenboard[idee.idee_id].umgesetzt_am = None
                st.rerun()

        if st.button("üóëÔ∏è L√∂schen", key=f"del_idee_{idee.idee_id}"):
            del st.session_state.ideenboard[idee.idee_id]
            st.rerun()

    st.markdown("---")


def kaeufer_finanzierung_view():
    """Finanzierungs-Bereich f√ºr K√§ufer - Erweitert"""
    st.subheader("üí∞ Finanzierung")

    user_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids]

    if not projekte:
        st.info("Sie sind noch keinem Projekt zugeordnet.")
        return

    tabs = st.tabs([
        "üè¶ Finanzierung anfragen",
        "üìä Angebote",
        "üìÅ Dokumente",
        "üì§ Meine Unterlagen",
        "üßÆ Kreditrechner",
        "üí∂ Kaufnebenkosten"
    ])

    with tabs[0]:
        kaeufer_finanzierung_anfragen(projekte)

    with tabs[1]:
        kaeufer_finanzierungsangebote()

    with tabs[2]:
        kaeufer_dokumente_zugriff(projekte)

    with tabs[3]:
        kaeufer_wirtschaftsdaten_upload()

    with tabs[4]:
        kaeufer_finanzierungsrechner()

    with tabs[5]:
        kaeufer_kaufnebenkosten_view(projekte)


def kaeufer_finanzierung_anfragen(projekte):
    """Finanzierung anfragen und Finanzierer einladen"""
    import uuid

    st.markdown("### üè¶ Finanzierung anfragen")

    user_id = st.session_state.current_user.user_id

    # Sicherstellen, dass die neuen Session State Variablen existieren
    if 'finanzierungsanfragen' not in st.session_state:
        st.session_state.finanzierungsanfragen = {}
    if 'finanzierer_einladungen' not in st.session_state:
        st.session_state.finanzierer_einladungen = {}
    if 'finanzierungsanfragen_an_finanzierer' not in st.session_state:
        st.session_state.finanzierungsanfragen_an_finanzierer = {}

    # ===== GESENDETE ANFRAGEN ANZEIGEN =====
    user_anfragen = [a for a in st.session_state.finanzierungsanfragen.values()
                     if a.kaeufer_id == user_id and a.anfrage_status == "Gesendet"]

    if user_anfragen:
        st.markdown("#### üì§ Ihre gesendeten Finanzierungsanfragen")

        for anfrage in user_anfragen:
            projekt = st.session_state.projekte.get(anfrage.projekt_id)
            modell = st.session_state.finanzierungsmodelle.get(anfrage.modell_id) if anfrage.modell_id else None

            projekt_name = projekt.name if projekt else "Unbekanntes Projekt"

            with st.expander(f"üì® Anfrage f√ºr {projekt_name} | {anfrage.finanzierungsbetrag:,.2f} ‚Ç¨ | {anfrage.erstellt_am.strftime('%d.%m.%Y')}", expanded=False):
                col1, col2 = st.columns(2)

                with col1:
                    st.markdown("**Finanzierungsdetails:**")
                    st.write(f"Kaufpreis: {anfrage.kaufpreis:,.2f} ‚Ç¨")
                    st.write(f"Eigenkapital: {anfrage.eigenkapital:,.2f} ‚Ç¨")
                    st.write(f"Finanzierungsbedarf: {anfrage.finanzierungsbetrag:,.2f} ‚Ç¨")
                    if modell:
                        st.write(f"Wunsch-Zinssatz: {modell.zinssatz:.2f}%")
                        st.write(f"Wunsch-Tilgung: {modell.tilgungssatz:.2f}%")
                        st.write(f"Monatliche Rate (Basis): {modell.monatliche_rate:,.2f} ‚Ç¨")

                with col2:
                    st.markdown("**Status bei Finanzierern:**")

                    # Finde einzelne Anfragen
                    einzelanfragen = [ea for ea in st.session_state.finanzierungsanfragen_an_finanzierer.values()
                                      if ea.hauptanfrage_id == anfrage.anfrage_id]

                    if einzelanfragen:
                        for ea in einzelanfragen:
                            fin_user = st.session_state.users.get(ea.finanzierer_id)
                            fin_name = fin_user.name if fin_user else "Finanzierer"

                            if ea.status == "Gesendet":
                                st.write(f"‚è≥ {fin_name}: Gesendet")
                            elif ea.status == "Gelesen":
                                st.write(f"üëÅÔ∏è {fin_name}: Gelesen")
                            elif ea.status == "Angebot_erstellt":
                                st.write(f"‚úÖ {fin_name}: Angebot erhalten!")
                            elif ea.status == "Abgelehnt":
                                st.write(f"‚ùå {fin_name}: Abgelehnt")
                            else:
                                st.write(f"üìã {fin_name}: {ea.status}")
                    else:
                        st.info("Anfrage wurde an Finanzierer gesendet.")

                if anfrage.notizen:
                    st.markdown(f"**Notizen:** {anfrage.notizen}")

        st.markdown("---")

    # ===== MODELLE ZUR ANFRAGE BEREIT =====
    angeforderte_modelle = [m for m in st.session_state.finanzierungsmodelle.values()
                           if m.kaeufer_id == user_id and m.status == FinanzierungsmodellStatus.ANGEFORDERT.value]

    # Filtere Modelle, f√ºr die noch keine Anfrage gesendet wurde
    bereits_gesendet_modelle = [a.modell_id for a in st.session_state.finanzierungsanfragen.values()
                                if a.kaeufer_id == user_id and a.anfrage_status == "Gesendet"]
    noch_nicht_gesendet = [m for m in angeforderte_modelle if m.modell_id not in bereits_gesendet_modelle]

    if noch_nicht_gesendet:
        st.markdown("#### üí° Modelle bereit zur Anfrage")
        st.info("Diese Modelle wurden zur Anfrage markiert. Klicken Sie auf 'Anfrage senden', um Angebote einzuholen.")

        for modell in noch_nicht_gesendet:
            with st.expander(f"üìã {modell.name} | {modell.darlehensbetrag:,.2f} ‚Ç¨ | {modell.monatliche_rate:,.2f} ‚Ç¨/Monat"):
                col1, col2 = st.columns(2)

                with col1:
                    st.write(f"**Zinssatz:** {modell.zinssatz:.2f}%")
                    st.write(f"**Tilgung:** {modell.tilgungssatz:.2f}%")
                    st.write(f"**Sollzinsbindung:** {modell.sollzinsbindung} Jahre")

                with col2:
                    st.write(f"**Gesamtzinsen:** {modell.gesamtzinsen:,.2f} ‚Ç¨")
                    st.write(f"**Restschuld:** {modell.restschuld_nach_zinsbindung:,.2f} ‚Ç¨")

                if st.button("üì® Anfrage jetzt senden", key=f"send_from_overview_{modell.modell_id}", type="primary"):
                    st.session_state[f'show_fin_dialog_{modell.modell_id}'] = True
                    st.rerun()

                if st.session_state.get(f'show_fin_dialog_{modell.modell_id}', False):
                    _render_finanzierer_auswahl_dialog(modell, f"overview_{modell.modell_id}")

        st.markdown("---")

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name} - Kaufpreis: {format_euro(projekt.kaufpreis)} ‚Ç¨", expanded=True):
            # Pr√ºfe ob bereits Finanzierungsanfrage existiert
            bestehende_anfrage = None
            for anfrage in st.session_state.finanzierungsanfragen.values():
                if anfrage.projekt_id == projekt.projekt_id and anfrage.kaeufer_id == user_id:
                    bestehende_anfrage = anfrage
                    break

            col1, col2 = st.columns(2)

            with col1:
                st.markdown("#### üíµ Finanzierungsbedarf")

                if bestehende_anfrage:
                    st.success("‚úÖ Finanzierungsanfrage gestellt")
                    st.write(f"**Kaufpreis:** {format_euro(bestehende_anfrage.kaufpreis)} ‚Ç¨")
                    st.write(f"**Eigenkapital:** {format_euro(bestehende_anfrage.eigenkapital)} ‚Ç¨")
                    st.write(f"**Finanzierungsbetrag:** {format_euro(bestehende_anfrage.finanzierungsbetrag)} ‚Ç¨")
                    if bestehende_anfrage.dokumente_freigegeben:
                        st.info("üìÑ Dokumente f√ºr Finanzierer freigegeben")
                else:
                    with st.form(f"finanz_anfrage_{projekt.projekt_id}"):
                        kaufpreis = st.number_input(
                            "Kaufpreis (‚Ç¨)",
                            value=projekt.kaufpreis,
                            min_value=0.0,
                            step=1000.0,
                            key=f"kp_{projekt.projekt_id}"
                        )
                        eigenkapital = st.number_input(
                            "Eigenkapital (‚Ç¨)",
                            value=0.0,
                            min_value=0.0,
                            step=1000.0,
                            key=f"ek_{projekt.projekt_id}"
                        )
                        finanzierungsbetrag = kaufpreis - eigenkapital

                        st.metric("Zu finanzierender Betrag", f"{format_euro(finanzierungsbetrag)} ‚Ç¨")

                        dokumente_freigeben = st.checkbox(
                            "Meine Unterlagen f√ºr Finanzierer freigeben",
                            value=True,
                            key=f"freig_{projekt.projekt_id}"
                        )

                        notizen = st.text_area(
                            "Notizen f√ºr Finanzierer (optional)",
                            key=f"notiz_{projekt.projekt_id}",
                            height=80
                        )

                        if st.form_submit_button("üí∞ Finanzierung anfragen", type="primary"):
                            anfrage_id = f"fa_{projekt.projekt_id}_{user_id}"
                            anfrage = FinanzierungsAnfrage(
                                anfrage_id=anfrage_id,
                                projekt_id=projekt.projekt_id,
                                kaeufer_id=user_id,
                                kaufpreis=kaufpreis,
                                eigenkapital=eigenkapital,
                                finanzierungsbetrag=finanzierungsbetrag,
                                dokumente_freigegeben=dokumente_freigeben,
                                notizen=notizen
                            )
                            st.session_state.finanzierungsanfragen[anfrage_id] = anfrage

                            # Benachrichtigung an alle zugeordneten Finanzierer
                            for fin_id in projekt.finanzierer_ids:
                                create_notification(
                                    fin_id,
                                    "Neue Finanzierungsanfrage",
                                    f"K√§ufer hat Finanzierung f√ºr {projekt.name} angefragt",
                                    NotificationType.INFO.value
                                )

                            st.success("‚úÖ Finanzierungsanfrage gestellt!")
                            st.rerun()

            with col2:
                st.markdown("#### üè¶ Finanzierer einladen")

                # Liste der eingeladenen Finanzierer
                einladungen = [e for e in st.session_state.finanzierer_einladungen.values()
                              if e.projekt_id == projekt.projekt_id]

                if einladungen:
                    st.markdown("**Eingeladene Finanzierer:**")
                    for einl in einladungen:
                        status_icon = "‚úÖ" if einl.status == FinanziererEinladungStatus.AKTIV.value else "‚è≥"
                        st.write(f"{status_icon} {einl.firmenname or einl.finanzierer_name or einl.finanzierer_email}")

                # Neue Einladung
                with st.form(f"einlade_fin_{projekt.projekt_id}"):
                    fin_email = st.text_input("E-Mail des Finanzierers", key=f"fin_email_{projekt.projekt_id}")
                    fin_name = st.text_input("Name/Bank (optional)", key=f"fin_name_{projekt.projekt_id}")

                    if st.form_submit_button("üìß Finanzierer einladen"):
                        if fin_email:
                            einl_id = f"fineinl_{len(st.session_state.finanzierer_einladungen)}"
                            token = str(uuid.uuid4())

                            neue_einladung = FinanziererEinladung(
                                einladung_id=einl_id,
                                projekt_id=projekt.projekt_id,
                                eingeladen_von=user_id,
                                finanzierer_email=fin_email,
                                finanzierer_name=fin_name,
                                onboarding_token=token
                            )
                            st.session_state.finanzierer_einladungen[einl_id] = neue_einladung

                            st.success(f"""
                            ‚úÖ Einladung gesendet!

                            **Simulierte E-Mail an:** {fin_email}

                            **Registrierungslink:**
                            https://plattform.example.com/finanzierer-registrierung?token={token}
                            """)
                            st.rerun()
                        else:
                            st.error("Bitte E-Mail-Adresse eingeben.")

def kaeufer_finanzierungsangebote():
    """Liste der Finanzierungsangebote f√ºr K√§ufer - Erweitert mit Ablauf und Details"""
    st.markdown("### üìä Eingegangene Finanzierungsangebote")

    user_id = st.session_state.current_user.user_id

    relevante_angebote = []
    for offer in st.session_state.financing_offers.values():
        projekt = st.session_state.projekte.get(offer.projekt_id)
        if projekt and user_id in projekt.kaeufer_ids:
            # Pr√ºfe auf abgelaufene Angebote
            if offer.gueltig_bis and datetime.now() > offer.gueltig_bis:
                if offer.auto_delete:
                    continue  # Angebot nicht anzeigen
                elif offer.status == FinanzierungsStatus.GESENDET.value:
                    offer.status = FinanzierungsStatus.ABGELAUFEN.value
                    st.session_state.financing_offers[offer.offer_id] = offer

            if offer.status in [FinanzierungsStatus.GESENDET.value, FinanzierungsStatus.ANGENOMMEN.value]:
                relevante_angebote.append(offer)

    if not relevante_angebote:
        st.info("üì≠ Noch keine Finanzierungsangebote vorhanden.")
        return

    # Sortiere nach Status (Gesendet zuerst) und Datum
    relevante_angebote.sort(key=lambda x: (x.status != FinanzierungsStatus.GESENDET.value, x.created_at), reverse=True)

    for offer in relevante_angebote:
        finanzierer = st.session_state.users.get(offer.finanzierer_id)
        finanzierer_name = finanzierer.name if finanzierer else "Unbekannt"

        status_icon = "‚úÖ" if offer.status == FinanzierungsStatus.ANGENOMMEN.value else "üìß"
        produkt_info = f" - {offer.produktname}" if offer.produktname else ""

        # G√ºltigkeit pr√ºfen
        ablauf_warnung = ""
        if offer.gueltig_bis and offer.status == FinanzierungsStatus.GESENDET.value:
            verbleibend = (offer.gueltig_bis - datetime.now()).days
            if verbleibend <= 3:
                ablauf_warnung = f" ‚ö†Ô∏è L√§uft in {verbleibend} Tag(en) ab!"
            elif verbleibend <= 7:
                ablauf_warnung = f" ‚è∞ G√ºltig bis {offer.gueltig_bis.strftime('%d.%m.%Y')}"

        with st.expander(f"{status_icon} {finanzierer_name}{produkt_info} - {offer.zinssatz}% Zinssatz{ablauf_warnung}",
                        expanded=(offer.status == FinanzierungsStatus.GESENDET.value)):

            # Haupt-Konditionen
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Darlehensbetrag", f"{format_euro(offer.darlehensbetrag)} ‚Ç¨")
                st.metric("Zinssatz (nom.)", f"{offer.zinssatz:.2f} %")
                if offer.effektivzins > 0:
                    st.metric("Effektivzins", f"{offer.effektivzins:.2f} %")

            with col2:
                st.metric("Tilgungssatz", f"{offer.tilgungssatz:.2f} %")
                st.metric("Monatliche Rate", f"{format_euro(offer.monatliche_rate)} ‚Ç¨")
                st.metric("Sollzinsbindung", f"{offer.sollzinsbindung} Jahre")

            with col3:
                st.metric("Gesamtlaufzeit", f"{offer.gesamtlaufzeit} Jahre")
                if offer.sondertilgung_prozent > 0:
                    st.metric("Sondertilgung", f"{offer.sondertilgung_prozent}% p.a.")
                if offer.bereitstellungszinsen_frei_monate > 0:
                    st.metric("Bereitst.-frei", f"{offer.bereitstellungszinsen_frei_monate} Mon.")

            # Tilgungsplan anzeigen
            if st.checkbox("üìä Tilgungsplan anzeigen", key=f"tilg_{offer.offer_id}"):
                render_tilgungsplan(
                    darlehensbetrag=offer.darlehensbetrag,
                    zinssatz=offer.zinssatz,
                    tilgungssatz=offer.tilgungssatz,
                    laufzeit_monate=offer.gesamtlaufzeit * 12,
                    key_prefix=f"offer_{offer.offer_id}"
                )

            if offer.besondere_bedingungen:
                st.markdown("**Besondere Bedingungen:**")
                st.info(offer.besondere_bedingungen)

            # G√ºltigkeit
            if offer.gueltig_bis:
                if datetime.now() > offer.gueltig_bis:
                    st.error(f"‚õî Angebot am {offer.gueltig_bis.strftime('%d.%m.%Y')} abgelaufen")
                else:
                    st.warning(f"‚è∞ G√ºltig bis: {offer.gueltig_bis.strftime('%d.%m.%Y %H:%M')}")

            if offer.pdf_data:
                col_dl, col_akt = st.columns(2)
                with col_dl:
                    st.download_button(
                        "üì• Angebot als PDF herunterladen",
                        offer.pdf_data,
                        file_name=f"Finanzierungsangebot_{offer.offer_id}.pdf",
                        mime="application/pdf",
                        key=f"dl_offer_{offer.offer_id}",
                        use_container_width=True
                    )
                with col_akt:
                    projekt = st.session_state.projekte.get(offer.projekt_id)
                    render_zur_aktentasche_button(
                        user_id=user_id,
                        inhalt_typ=AktentascheInhaltTyp.FINANZIERUNGSANGEBOT.value,
                        titel=f"Finanzierungsangebot {finanzierer_name}",
                        beschreibung=f"{offer.zinssatz}% Zinsen, {format_euro(offer.monatliche_rate)} ‚Ç¨/Monat",
                        referenz_id=offer.offer_id,
                        referenz_typ="FinancingOffer",
                        dateiname=f"Finanzierungsangebot_{offer.offer_id}.pdf",
                        dateigr√∂√üe=len(offer.pdf_data) if offer.pdf_data else 0,
                        pdf_data=offer.pdf_data,
                        projekt_id=offer.projekt_id,
                        projekt_name=projekt.name if projekt else "",
                        key_suffix=f"fin_{offer.offer_id}"
                    )

            if offer.status == FinanzierungsStatus.GESENDET.value:
                st.markdown("---")
                st.markdown("### üéØ Angebot annehmen")

                notar_checkbox = st.checkbox(
                    "Dieses Angebot soll f√ºr den Notar als Finanzierungsnachweis markiert werden",
                    key=f"notar_{offer.offer_id}"
                )

                if st.button("‚úÖ Finanzierungsangebot annehmen",
                           type="primary",
                           key=f"accept_{offer.offer_id}",
                           use_container_width=True):
                    offer.status = FinanzierungsStatus.ANGENOMMEN.value
                    offer.accepted_at = datetime.now()
                    offer.fuer_notar_markiert = notar_checkbox

                    # Timeline aktualisieren
                    projekt = st.session_state.projekte.get(offer.projekt_id)
                    if projekt:
                        for event_id in projekt.timeline_events:
                            event = st.session_state.timeline_events.get(event_id)
                            if event and event.titel == "Finanzierung gesichert" and not event.completed:
                                event.completed = True
                                event.completed_at = datetime.now()
                        update_projekt_status(offer.projekt_id)

                    # Benachrichtigungen
                    create_notification(offer.finanzierer_id, "Angebot angenommen", "Ihr Finanzierungsangebot wurde angenommen!", NotificationType.SUCCESS.value)
                    if projekt and projekt.makler_id:
                        create_notification(projekt.makler_id, "Finanzierung gesichert", f"K√§ufer hat Finanzierungsangebot angenommen f√ºr {projekt.name}", NotificationType.SUCCESS.value)

                    st.success("‚úÖ Finanzierungsangebot erfolgreich angenommen!")
                    st.balloons()
                    st.rerun()

            elif offer.status == FinanzierungsStatus.ANGENOMMEN.value:
                st.success(f"‚úÖ Angenommen am {offer.accepted_at.strftime('%d.%m.%Y %H:%M')}")
                if offer.fuer_notar_markiert:
                    st.info("üìã Als Finanzierungsnachweis f√ºr Notar markiert")


def render_tilgungsplan(darlehensbetrag: float, zinssatz: float, tilgungssatz: float,
                       laufzeit_monate: int, sondertilgung_jaehrlich: float = 0,
                       key_prefix: str = "tilg"):
    """Zeigt einen Tilgungsplan mit monatlichen Raten an"""
    import pandas as pd

    if darlehensbetrag <= 0 or zinssatz <= 0 or tilgungssatz <= 0:
        st.warning("Bitte g√ºltige Werte eingeben.")
        return

    # Berechnung
    monatszins = zinssatz / 100 / 12
    anfaengliche_rate = darlehensbetrag * (zinssatz + tilgungssatz) / 100 / 12

    tilgungsplan = []
    restschuld = darlehensbetrag
    gesamt_zinsen = 0
    gesamt_tilgung = 0

    for monat in range(1, min(laufzeit_monate + 1, 361)):  # Max 30 Jahre
        if restschuld <= 0:
            break

        zinsen = restschuld * monatszins
        tilgung = anfaengliche_rate - zinsen

        # Sondertilgung am Jahresende
        if monat % 12 == 0 and sondertilgung_jaehrlich > 0:
            tilgung += sondertilgung_jaehrlich

        if tilgung > restschuld:
            tilgung = restschuld

        restschuld -= tilgung
        gesamt_zinsen += zinsen
        gesamt_tilgung += tilgung

        tilgungsplan.append({
            'Monat': monat,
            'Jahr': (monat - 1) // 12 + 1,
            'Rate': anfaengliche_rate,
            'Zinsen': zinsen,
            'Tilgung': tilgung,
            'Restschuld': max(0, restschuld)
        })

    if tilgungsplan:
        df = pd.DataFrame(tilgungsplan)

        # Zusammenfassung
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Monatliche Rate", f"{format_euro(anfaengliche_rate)} ‚Ç¨")
        with col2:
            st.metric("Gesamtzinsen", f"{format_euro(gesamt_zinsen)} ‚Ç¨")
        with col3:
            st.metric("Restschuld nach Laufzeit", f"{format_euro(tilgungsplan[-1]['Restschuld'])} ‚Ç¨")

        # J√§hrliche Zusammenfassung
        anzeige_option = st.radio(
            "Anzeige",
            ["J√§hrlich", "Monatlich (erste 24 Monate)"],
            horizontal=True,
            key=f"{key_prefix}_anzeige"
        )

        if anzeige_option == "J√§hrlich":
            df_jaehrlich = df.groupby('Jahr').agg({
                'Zinsen': 'sum',
                'Tilgung': 'sum',
                'Restschuld': 'last'
            }).reset_index()
            df_jaehrlich.columns = ['Jahr', 'Zinsen (‚Ç¨)', 'Tilgung (‚Ç¨)', 'Restschuld (‚Ç¨)']

            st.dataframe(
                df_jaehrlich.style.format({
                    'Zinsen (‚Ç¨)': lambda x: format_euro(x),
                    'Tilgung (‚Ç¨)': lambda x: format_euro(x),
                    'Restschuld (‚Ç¨)': lambda x: format_euro(x)
                }),
                use_container_width=True,
                height=400
            )
        else:
            df_monatlich = df.head(24)[['Monat', 'Rate', 'Zinsen', 'Tilgung', 'Restschuld']]
            df_monatlich.columns = ['Monat', 'Rate (‚Ç¨)', 'Zinsen (‚Ç¨)', 'Tilgung (‚Ç¨)', 'Restschuld (‚Ç¨)']

            st.dataframe(
                df_monatlich.style.format({
                    'Rate (‚Ç¨)': lambda x: format_euro(x),
                    'Zinsen (‚Ç¨)': lambda x: format_euro(x),
                    'Tilgung (‚Ç¨)': lambda x: format_euro(x),
                    'Restschuld (‚Ç¨)': lambda x: format_euro(x)
                }),
                use_container_width=True,
                height=400
            )


def kaeufer_dokumente_zugriff(projekte):
    """Zugriff auf Dokumente von Verk√§ufer/Makler/Notar"""
    st.markdown("### üìÅ Dokumente einsehen")
    st.info("Hier finden Sie Dokumente, die Ihnen vom Verk√§ufer, Makler oder Notar bereitgestellt wurden.")

    user_id = st.session_state.current_user.user_id

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            doc_tabs = st.tabs(["üìÑ Verk√§ufer", "üìë Makler", "‚öñÔ∏è Notar"])

            # Verk√§ufer-Dokumente
            with doc_tabs[0]:
                verk_docs = []
                for doc in st.session_state.verkaeufer_dokumente.values():
                    if hasattr(doc, 'projekt_id') and doc.projekt_id == projekt.projekt_id:
                        if hasattr(doc, 'freigegeben_fuer_kaeufer') and doc.freigegeben_fuer_kaeufer:
                            verk_docs.append(doc)

                if verk_docs:
                    for doc in verk_docs:
                        col1, col2 = st.columns([4, 1])
                        with col1:
                            st.write(f"üìÑ {doc.filename if hasattr(doc, 'filename') else doc.name}")
                        with col2:
                            if hasattr(doc, 'pdf_data') and doc.pdf_data:
                                st.download_button("üì•", doc.pdf_data, file_name=doc.filename, key=f"verk_{doc.doc_id}")
                else:
                    st.info("Noch keine Dokumente vom Verk√§ufer freigegeben.")

            # Makler-Dokumente (Expos√© etc.)
            with doc_tabs[1]:
                expose = st.session_state.expose_data.get(projekt.projekt_id)
                if expose:
                    st.success("‚úÖ Expos√© verf√ºgbar")
                    # Link zum Expos√©
                    if projekt.expose_pdf:
                        st.download_button(
                            "üì• Expos√© herunterladen",
                            projekt.expose_pdf,
                            file_name=f"Expose_{projekt.name}.pdf",
                            mime="application/pdf",
                            key=f"makler_expose_{projekt.projekt_id}"
                        )
                else:
                    st.info("Noch keine Dokumente vom Makler.")

            # Notar-Dokumente
            with doc_tabs[2]:
                # Checklisten
                notar_docs = st.session_state.notar_checklists.get(projekt.projekt_id, {})
                if notar_docs:
                    st.write("**Notarielle Checklisten:**")
                    for name, check in notar_docs.items():
                        st.write(f"üìã {name}")
                else:
                    st.info("Noch keine Dokumente vom Notar.")

def kaeufer_wirtschaftsdaten_upload():
    """Upload-Bereich f√ºr Wirtschaftsdaten"""
    st.markdown("### üì§ Wirtschaftsdaten hochladen")
    st.info("Laden Sie hier Ihre Bonit√§tsunterlagen f√ºr die Finanzierung hoch. Die Dokumente werden automatisch per OCR analysiert und kategorisiert.")

    with st.form("wirtschaftsdaten_upload"):
        uploaded_files = st.file_uploader(
            "Dokumente ausw√§hlen (PDF, JPG, PNG)",
            type=['pdf', 'jpg', 'png'],
            accept_multiple_files=True
        )

        doc_type = st.selectbox(
            "Dokumenten-Typ (optional - wird automatisch erkannt)",
            [
                "Automatisch erkennen",
                DocumentType.BWA.value,
                DocumentType.STEUERBESCHEID.value,
                DocumentType.GEHALTSABRECHNUNG.value,
                DocumentType.VERMOEGENSNACHWEIS.value,
                DocumentType.SONSTIGE.value
            ]
        )

        submit = st.form_submit_button("üì§ Hochladen & Analysieren")

        if submit and uploaded_files:
            progress_bar = st.progress(0)
            status_text = st.empty()

            for i, file in enumerate(uploaded_files):
                status_text.text(f"Verarbeite {file.name}...")
                progress_bar.progress((i + 1) / len(uploaded_files))

                file_data = file.read()

                # OCR-Simulation
                ocr_text, kategorie = simulate_ocr(file_data, file.name)

                # Dokument speichern
                doc_id = f"wirt_{st.session_state.current_user.user_id}_{len(st.session_state.wirtschaftsdaten)}"

                doc = WirtschaftsdatenDokument(
                    doc_id=doc_id,
                    kaeufer_id=st.session_state.current_user.user_id,
                    doc_type=doc_type if doc_type != "Automatisch erkennen" else kategorie,
                    filename=file.name,
                    upload_date=datetime.now(),
                    pdf_data=file_data,
                    kategorie=kategorie,
                    ocr_text=ocr_text
                )

                st.session_state.wirtschaftsdaten[doc_id] = doc

            # Timeline aktualisieren
            for projekt_id in st.session_state.current_user.projekt_ids:
                projekt = st.session_state.projekte.get(projekt_id)
                if projekt:
                    for event_id in projekt.timeline_events:
                        event = st.session_state.timeline_events.get(event_id)
                        if event and event.titel == "Wirtschaftsdaten hochladen" and not event.completed:
                            event.completed = True
                            event.completed_at = datetime.now()
                    update_projekt_status(projekt_id)

            st.success(f"‚úÖ {len(uploaded_files)} Dokument(e) erfolgreich hochgeladen und analysiert!")
            st.rerun()

    st.markdown("---")
    st.markdown("### üìã Hochgeladene Dokumente")

    user_docs = [d for d in st.session_state.wirtschaftsdaten.values()
                 if d.kaeufer_id == st.session_state.current_user.user_id]

    if user_docs:
        # Nach Kategorie gruppieren
        kategorien = {}
        for doc in user_docs:
            if doc.kategorie not in kategorien:
                kategorien[doc.kategorie] = []
            kategorien[doc.kategorie].append(doc)

        for kategorie, docs in kategorien.items():
            with st.expander(f"üìÅ {kategorie} ({len(docs)} Dokument(e))", expanded=True):
                for doc in docs:
                    col1, col2, col3, col4 = st.columns([3, 2, 1, 1])
                    with col1:
                        st.write(f"üìÑ **{doc.filename}**")
                    with col2:
                        st.caption(f"Hochgeladen: {doc.upload_date.strftime('%d.%m.%Y')}")
                    with col3:
                        if st.button("üëÅÔ∏è", key=f"view_{doc.doc_id}", help="OCR-Text anzeigen"):
                            st.session_state[f"show_ocr_{doc.doc_id}"] = not st.session_state.get(f"show_ocr_{doc.doc_id}", False)
                    with col4:
                        st.download_button(
                            "üì•",
                            doc.pdf_data,
                            file_name=doc.filename,
                            key=f"dl_{doc.doc_id}"
                        )

                    if st.session_state.get(f"show_ocr_{doc.doc_id}", False):
                        st.text_area("OCR-Ergebnis", doc.ocr_text, height=150, disabled=True, key=f"ocr_text_{doc.doc_id}")

                    st.markdown("---")
    else:
        st.info("Noch keine Dokumente hochgeladen.")


def kaeufer_finanzierungsrechner():
    """Umfassender Finanzierungsrechner f√ºr K√§ufer mit Modellverwaltung"""
    import pandas as pd
    import json
    import uuid

    st.markdown("### üßÆ Kreditrechner")

    # Initialisiere finanzierungsmodelle falls nicht vorhanden
    if 'finanzierungsmodelle' not in st.session_state:
        st.session_state.finanzierungsmodelle = {}

    # Tabs f√ºr verschiedene Funktionen
    rechner_tabs = st.tabs([
        "üìä Neue Berechnung",
        "üíæ Gespeicherte Modelle",
        "‚öñÔ∏è Modelle vergleichen",
        "üì• Angebot importieren"
    ])

    with rechner_tabs[0]:
        _finanzierung_neue_berechnung()

    with rechner_tabs[1]:
        _finanzierung_gespeicherte_modelle()

    with rechner_tabs[2]:
        _finanzierung_modelle_vergleichen()

    with rechner_tabs[3]:
        _finanzierung_angebot_importieren()


def _finanzierung_neue_berechnung():
    """Neue Finanzierungsberechnung erstellen"""
    import pandas as pd
    import json
    import uuid

    st.info("""
    Berechnen Sie hier Ihre pers√∂nliche Finanzierung. Geben Sie Ihre Wunschkonditionen ein
    und sehen Sie den kompletten Tilgungsverlauf mit monatlicher Zins- und Tilgungsaufstellung.
    """)

    # Pr√ºfen ob Finanzierungsbedarf aus Kostenberechnung √ºbernommen wurde
    has_berechnung = 'berechneter_finanzierungsbedarf' in st.session_state

    # Box f√ºr Daten√ºbernahme aus Kaufnebenkosten
    st.markdown("#### üìã Finanzierungsbedarf aus Kaufnebenkosten")

    if has_berechnung:
        finanzierungsbedarf = st.session_state.get('berechneter_finanzierungsbedarf', 0)
        st.success(f"""
        **‚úÖ Daten aus Kaufnebenkosten-Berechnung verf√ºgbar:**
        - Kaufpreis: {st.session_state.get('berechneter_kaufpreis', 0):,.2f} ‚Ç¨
        - Nebenkosten: {st.session_state.get('berechnete_nebenkosten', 0):,.2f} ‚Ç¨
        - **Finanzierungsbedarf: {finanzierungsbedarf:,.2f} ‚Ç¨**
        """)

        # Button zum Aktualisieren
        if st.button("üîÑ Daten aus Kaufnebenkosten neu laden", key="reload_kosten"):
            st.info("Wechseln Sie zum Tab 'üí∞ Kaufnebenkosten', passen Sie die Daten an und kehren Sie hierher zur√ºck.")

        # Default-Wert aus Berechnung, falls nicht manuell √ºberschrieben
        default_betrag = finanzierungsbedarf
    else:
        st.warning("""
        ‚ö†Ô∏è **Keine Kaufnebenkosten-Berechnung vorhanden.**

        Um den korrekten Finanzierungsbedarf (Kaufpreis + alle Nebenkosten) zu ermitteln,
        sollten Sie zuerst die Kaufnebenkosten berechnen.
        """)

        col_btn1, col_btn2 = st.columns(2)
        with col_btn1:
            st.markdown("""
            **Empfohlen:** Berechnen Sie zuerst die Kaufnebenkosten im Tab "üí∞ Kaufnebenkosten".
            Dort werden Notar-, Grundbuch-, Maklerkosten und Grunderwerbsteuer berechnet.
            """)

        with col_btn2:
            # Schnellberechnung direkt hier
            with st.expander("‚ö° Schnellberechnung des Finanzierungsbedarfs"):
                schnell_kaufpreis = st.number_input(
                    "Kaufpreis (‚Ç¨)",
                    min_value=0.0,
                    value=300000.0,
                    step=5000.0,
                    key="schnell_kaufpreis"
                )
                schnell_nebenkosten_prozent = st.slider(
                    "Gesch√§tzte Nebenkosten (%)",
                    min_value=5.0,
                    max_value=15.0,
                    value=10.0,
                    step=0.5,
                    key="schnell_nk_prozent",
                    help="Typisch: 10-12% (inkl. Notar, Grundbuch, Makler, Grunderwerbsteuer)"
                )

                schnell_nebenkosten = schnell_kaufpreis * schnell_nebenkosten_prozent / 100
                schnell_gesamt = schnell_kaufpreis + schnell_nebenkosten

                st.metric("Gesch√§tzter Finanzierungsbedarf", f"{schnell_gesamt:,.2f} ‚Ç¨")

                if st.button("üìä Diese Werte √ºbernehmen", type="primary", key="uebernehme_schnell"):
                    st.session_state['berechneter_kaufpreis'] = schnell_kaufpreis
                    st.session_state['berechnete_nebenkosten'] = schnell_nebenkosten
                    st.session_state['berechneter_finanzierungsbedarf'] = schnell_gesamt
                    st.success("‚úÖ Werte wurden √ºbernommen!")
                    st.rerun()

        default_betrag = 300000.0

    st.markdown("---")

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("#### üíµ Finanzierungsdaten")

        # Option f√ºr manuelle Eingabe
        betrag_quelle = st.radio(
            "Finanzierungsbetrag:",
            ["Aus Berechnung √ºbernehmen", "Manuell eingeben"] if has_berechnung else ["Manuell eingeben"],
            horizontal=True,
            key="betrag_quelle"
        )

        if betrag_quelle == "Aus Berechnung √ºbernehmen" and has_berechnung:
            finanzierungsbetrag = st.session_state['berechneter_finanzierungsbedarf']
            st.metric("Zu finanzierender Betrag", f"{finanzierungsbetrag:,.2f} ‚Ç¨")

            # Optional: Anpassung des Betrags
            with st.expander("‚ûï Zus√§tzliche Kosten hinzuf√ºgen"):
                zusatz = st.number_input(
                    "Zus√§tzliche Kosten (z.B. Renovierung, Umzug) (‚Ç¨)",
                    min_value=0.0,
                    max_value=1000000.0,
                    value=0.0,
                    step=1000.0,
                    key="zusatz_kosten"
                )
                if zusatz > 0:
                    finanzierungsbetrag += zusatz
                    st.info(f"Angepasster Finanzierungsbedarf: **{finanzierungsbetrag:,.2f} ‚Ç¨**")
        else:
            finanzierungsbetrag = st.number_input(
                "Zu finanzierender Betrag (‚Ç¨)",
                min_value=10000.0,
                max_value=10000000.0,
                value=default_betrag,
                step=5000.0,
                key="rechner_betrag_manuell"
            )

        eigenkapital = st.number_input(
            "Eigenkapital (‚Ç¨)",
            min_value=0.0,
            max_value=finanzierungsbetrag,
            value=0.0,
            step=1000.0,
            key="rechner_ek"
        )

        darlehensbetrag = finanzierungsbetrag - eigenkapital
        st.metric("Darlehensbetrag", f"{format_euro(darlehensbetrag)} ‚Ç¨")

    with col2:
        st.markdown("#### üìä Konditionen")

        zinssatz = st.number_input(
            "Sollzinssatz (% p.a.)",
            min_value=0.1,
            max_value=15.0,
            value=3.5,
            step=0.1,
            key="rechner_zins"
        )

        # Tilgung: entweder Prozent oder Betrag
        tilgung_typ = st.radio(
            "Tilgung angeben als:",
            ["Prozent", "Monatlicher Betrag"],
            horizontal=True,
            key="rechner_tilg_typ"
        )

        if tilgung_typ == "Prozent":
            tilgungssatz = st.number_input(
                "Anf√§nglicher Tilgungssatz (% p.a.)",
                min_value=0.5,
                max_value=10.0,
                value=2.0,
                step=0.1,
                key="rechner_tilg"
            )
            monatliche_rate = darlehensbetrag * (zinssatz + tilgungssatz) / 100 / 12
        else:
            monatliche_rate = st.number_input(
                "Monatliche Rate (‚Ç¨)",
                min_value=100.0,
                max_value=50000.0,
                value=1500.0,
                step=50.0,
                key="rechner_rate"
            )
            # Tilgungssatz berechnen
            monatszins_anteil = darlehensbetrag * (zinssatz / 100 / 12)
            tilgung_anteil = monatliche_rate - monatszins_anteil
            tilgungssatz = (tilgung_anteil * 12 / darlehensbetrag) * 100 if darlehensbetrag > 0 else 0

    st.markdown("---")

    # Erweiterte Optionen
    with st.expander("‚öôÔ∏è Erweiterte Optionen"):
        col3, col4 = st.columns(2)

        with col3:
            sollzinsbindung = st.number_input(
                "Sollzinsbindung (Jahre)",
                min_value=1,
                max_value=30,
                value=10,
                key="rechner_bindung"
            )

            vollltilger = st.checkbox(
                "Volltilger-Darlehen (vollst√§ndige Tilgung in Laufzeit)",
                key="rechner_volltilger"
            )

        with col4:
            # Sondertilgung
            st.markdown("**Sondertilgung:**")
            sondertilgung_typ = st.radio(
                "Art der Sondertilgung",
                ["Keine", "Prozent p.a.", "Fester Betrag"],
                horizontal=True,
                key="rechner_st_typ"
            )

            sondertilgung_betrag = 0.0
            if sondertilgung_typ == "Prozent p.a.":
                sondertilgung_prozent = st.number_input(
                    "Sondertilgung (% p.a.)",
                    min_value=0.0,
                    max_value=10.0,
                    value=5.0,
                    step=0.5,
                    key="rechner_st_proz"
                )
                sondertilgung_betrag = darlehensbetrag * sondertilgung_prozent / 100
            elif sondertilgung_typ == "Fester Betrag":
                sondertilgung_betrag = st.number_input(
                    "Sondertilgung pro Jahr (‚Ç¨)",
                    min_value=0.0,
                    max_value=100000.0,
                    value=10000.0,
                    step=1000.0,
                    key="rechner_st_betrag"
                )

            sondertilgung_zeitpunkt = st.radio(
                "Sondertilgung",
                ["J√§hrlich", "Monatlich"],
                horizontal=True,
                key="rechner_st_zeit"
            ) if sondertilgung_betrag > 0 else "J√§hrlich"

    # Berechnung durchf√ºhren
    if st.button("üìä Finanzierung berechnen", type="primary", use_container_width=True):
        if darlehensbetrag <= 0:
            st.error("Bitte geben Sie einen Darlehensbetrag gr√∂√üer 0 ein.")
            return

        # Vollltilger-Berechnung
        if vollltilger:
            laufzeit_monate = sollzinsbindung * 12
            monatszins = zinssatz / 100 / 12
            # Annuit√§tenformel f√ºr Volltilger
            if monatszins > 0:
                monatliche_rate = darlehensbetrag * (monatszins * (1 + monatszins)**laufzeit_monate) / ((1 + monatszins)**laufzeit_monate - 1)
            else:
                monatliche_rate = darlehensbetrag / laufzeit_monate
        else:
            laufzeit_monate = 360  # Max 30 Jahre

        # Tilgungsplan berechnen
        monatszins = zinssatz / 100 / 12
        sondertilg_monatlich = sondertilgung_betrag / 12 if sondertilgung_zeitpunkt == "Monatlich" else 0

        tilgungsplan = []
        restschuld = darlehensbetrag
        gesamt_zinsen = 0
        gesamt_tilgung = 0

        for monat in range(1, laufzeit_monate + 1):
            if restschuld <= 0:
                break

            zinsen = restschuld * monatszins
            tilgung = monatliche_rate - zinsen

            # Sondertilgung
            if sondertilgung_typ != "Keine":
                if sondertilgung_zeitpunkt == "J√§hrlich" and monat % 12 == 0:
                    tilgung += sondertilgung_betrag
                elif sondertilgung_zeitpunkt == "Monatlich":
                    tilgung += sondertilg_monatlich

            if tilgung > restschuld:
                tilgung = restschuld
                rate_effektiv = zinsen + tilgung
            else:
                rate_effektiv = monatliche_rate + (sondertilg_monatlich if sondertilgung_zeitpunkt == "Monatlich" else 0)

            restschuld -= tilgung
            gesamt_zinsen += zinsen
            gesamt_tilgung += tilgung

            tilgungsplan.append({
                'Monat': monat,
                'Jahr': (monat - 1) // 12 + 1,
                'Rate': rate_effektiv,
                'Zinsen': zinsen,
                'Tilgung': tilgung,
                'Restschuld': max(0, restschuld)
            })

            if restschuld <= 0:
                break

        if tilgungsplan:
            df = pd.DataFrame(tilgungsplan)

            letzte_restschuld = tilgungsplan[-1]['Restschuld']
            laufzeit_effektiv = len(tilgungsplan)
            gesamtkosten = gesamt_zinsen + darlehensbetrag

            # *** Berechnungsergebnisse im Session State speichern ***
            st.session_state.rechner_ergebnis = {
                'tilgungsplan': tilgungsplan,
                'darlehensbetrag': darlehensbetrag,
                'zinssatz': zinssatz,
                'tilgungssatz': tilgungssatz,
                'monatliche_rate': monatliche_rate,
                'sollzinsbindung': sollzinsbindung,
                'gesamt_zinsen': gesamt_zinsen,
                'gesamtkosten': gesamtkosten,
                'laufzeit_effektiv': laufzeit_effektiv,
                'letzte_restschuld': letzte_restschuld,
                'vollltilger': vollltilger,
                'sondertilgung_betrag': sondertilgung_betrag,
                'kaufpreis_wert': st.session_state.get('berechneter_kaufpreis', 0),
                'nebenkosten_wert': st.session_state.get('berechnete_nebenkosten', 0),
                'eigenkapital': st.session_state.get('berechnetes_eigenkapital', 0),
                'finanzierungsbetrag': st.session_state.get('berechneter_finanzierungsbetrag', darlehensbetrag),
                'df': df
            }

            # Zusammenfassung
            st.markdown("---")
            st.markdown("### üìà Ergebnis")

            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Monatliche Rate", f"{format_euro(monatliche_rate)} ‚Ç¨")
            with col2:
                st.metric("Gesamtzinsen", f"{format_euro(gesamt_zinsen)} ‚Ç¨")
            with col3:
                st.metric("Restschuld", f"{format_euro(letzte_restschuld)} ‚Ç¨")
            with col4:
                st.metric("Laufzeit", f"{laufzeit_effektiv // 12} J. {laufzeit_effektiv % 12} M.")

            # Zus√§tzliche Infos
            gesamtkosten = gesamt_zinsen + darlehensbetrag
            st.info(f"üí∞ **Gesamtkosten des Kredits:** {format_euro(gesamtkosten)} ‚Ç¨ (Darlehensbetrag + Zinsen)")

            st.info(f"üí∞ **Gesamtkosten des Kredits:** {gesamtkosten:,.2f} ‚Ç¨ (Darlehensbetrag + Zinsen)")

            if sollzinsbindung * 12 < laufzeit_effektiv and not vollltilger:
                restschuld_bei_bindung = df[df['Monat'] == sollzinsbindung * 12]['Restschuld'].values
                if len(restschuld_bei_bindung) > 0:
                    st.warning(f"‚ö†Ô∏è **Restschuld nach {sollzinsbindung} Jahren Sollzinsbindung:** {format_euro(restschuld_bei_bindung[0])} ‚Ç¨")

            # Tilgungsplan anzeigen
            st.markdown("---")
            st.markdown("### üìã Tilgungsplan")

            anzeige = st.radio(
                "Anzeige",
                ["üìÖ J√§hrlich", "üìÜ Monatlich (alle)", "üìä Erste 24 Monate"],
                horizontal=True,
                key="rechner_anzeige"
            )

            if anzeige == "üìÖ J√§hrlich":
                df_jaehrlich = df.groupby('Jahr').agg({
                    'Zinsen': 'sum',
                    'Tilgung': 'sum',
                    'Restschuld': 'last'
                }).reset_index()
                df_jaehrlich.columns = ['Jahr', 'Zinsen (‚Ç¨)', 'Tilgung (‚Ç¨)', 'Restschuld (‚Ç¨)']

                st.dataframe(
                    df_jaehrlich.style.format({
                        'Zinsen (‚Ç¨)': lambda x: format_euro(x),
                        'Tilgung (‚Ç¨)': lambda x: format_euro(x),
                        'Restschuld (‚Ç¨)': lambda x: format_euro(x)
                    }),
                    use_container_width=True,
                    height=400
                )

            elif anzeige == "üìÜ Monatlich (alle)":
                df_display = df[['Monat', 'Rate', 'Zinsen', 'Tilgung', 'Restschuld']].copy()
                df_display.columns = ['Monat', 'Rate (‚Ç¨)', 'Zinsen (‚Ç¨)', 'Tilgung (‚Ç¨)', 'Restschuld (‚Ç¨)']

                st.dataframe(
                    df_display.style.format({
                        'Rate (‚Ç¨)': lambda x: format_euro(x),
                        'Zinsen (‚Ç¨)': lambda x: format_euro(x),
                        'Tilgung (‚Ç¨)': lambda x: format_euro(x),
                        'Restschuld (‚Ç¨)': lambda x: format_euro(x)
                    }),
                    use_container_width=True,
                    height=400
                )

            else:  # Erste 24 Monate
                df_24 = df.head(24)[['Monat', 'Rate', 'Zinsen', 'Tilgung', 'Restschuld']].copy()
                df_24.columns = ['Monat', 'Rate (‚Ç¨)', 'Zinsen (‚Ç¨)', 'Tilgung (‚Ç¨)', 'Restschuld (‚Ç¨)']

                st.dataframe(
                    df_24.style.format({
                        'Rate (‚Ç¨)': lambda x: format_euro(x),
                        'Zinsen (‚Ç¨)': lambda x: format_euro(x),
                        'Tilgung (‚Ç¨)': lambda x: format_euro(x),
                        'Restschuld (‚Ç¨)': lambda x: format_euro(x)
                    }),
                    use_container_width=True,
                    height=400
                )

            # Hinweis auf Speichern
            st.markdown("---")
            st.success("‚úÖ Berechnung abgeschlossen! Scrollen Sie nach unten, um das Modell zu speichern.")

    # --- SPEICHERN ALS MODELL (au√üerhalb des Button-Blocks) ---
    # Dieser Block wird angezeigt, wenn Berechnungsergebnisse im Session State sind
    if 'rechner_ergebnis' in st.session_state and st.session_state.rechner_ergebnis:
        ergebnis = st.session_state.rechner_ergebnis

        st.markdown("---")
        st.markdown("### üíæ Berechnung speichern")

        col_save1, col_save2 = st.columns([2, 1])

        with col_save1:
            modell_name = st.text_input(
                "Name f√ºr dieses Finanzierungsmodell",
                value=f"Modell {datetime.now().strftime('%d.%m.%Y %H:%M')}",
                key="modell_name_input"
            )
            modell_notizen = st.text_area(
                "Notizen (optional)",
                placeholder="z.B. Bank XY, Sonderkonditionen...",
                key="modell_notizen_input"
            )

        with col_save2:
            st.markdown("**Zusammenfassung:**")
            st.write(f"Darlehensbetrag: {ergebnis['darlehensbetrag']:,.2f} ‚Ç¨")
            st.write(f"Zinssatz: {ergebnis['zinssatz']}%")
            st.write(f"Tilgung: {ergebnis['tilgungssatz']:.2f}%")
            st.write(f"Rate: {ergebnis['monatliche_rate']:,.2f} ‚Ç¨")

        if st.button("üíæ Als Modell speichern", type="primary", key="speichere_modell"):
            # Daten aus Session State holen
            tilgungsplan = ergebnis['tilgungsplan']
            darlehensbetrag = ergebnis['darlehensbetrag']
            zinssatz = ergebnis['zinssatz']
            tilgungssatz = ergebnis['tilgungssatz']
            monatliche_rate = ergebnis['monatliche_rate']
            sollzinsbindung = ergebnis['sollzinsbindung']
            gesamt_zinsen = ergebnis['gesamt_zinsen']
            gesamtkosten = ergebnis['gesamtkosten']
            laufzeit_effektiv = ergebnis['laufzeit_effektiv']
            sondertilgung_betrag = ergebnis['sondertilgung_betrag']
            kaufpreis_wert = ergebnis['kaufpreis_wert']
            nebenkosten_wert = ergebnis['nebenkosten_wert']
            eigenkapital = ergebnis['eigenkapital']
            finanzierungsbetrag = ergebnis['finanzierungsbetrag']

            # Neues Modell erstellen
            modell_id = str(uuid.uuid4())[:8]

            # Restschuld nach Zinsbindung berechnen
            restschuld_bindung = 0.0
            if sollzinsbindung * 12 <= len(tilgungsplan):
                restschuld_bindung = tilgungsplan[sollzinsbindung * 12 - 1]['Restschuld']
            elif tilgungsplan:
                restschuld_bindung = tilgungsplan[-1]['Restschuld']

            neues_modell = Finanzierungsmodell(
                modell_id=modell_id,
                projekt_id=st.session_state.get('aktuelles_projekt_id', ''),
                kaeufer_id=st.session_state.current_user.user_id if st.session_state.current_user else '',
                name=modell_name,
                kaufpreis=kaufpreis_wert,
                nebenkosten=nebenkosten_wert,
                finanzierungsbedarf=finanzierungsbetrag,
                eigenkapital=eigenkapital,
                darlehensbetrag=darlehensbetrag,
                zinssatz=zinssatz,
                tilgungssatz=tilgungssatz,
                monatliche_rate=monatliche_rate,
                sollzinsbindung=sollzinsbindung,
                sondertilgung_prozent=sondertilgung_betrag / darlehensbetrag * 100 if darlehensbetrag > 0 else 0,
                restschuld_nach_zinsbindung=restschuld_bindung,
                gesamtlaufzeit_jahre=laufzeit_effektiv / 12,
                gesamtzinsen=gesamt_zinsen,
                gesamtkosten=gesamtkosten,
                tilgungsplan_json=json.dumps(tilgungsplan),
                notizen=modell_notizen,
                quelle=FinanzierungsmodellQuelle.EIGENE_BERECHNUNG.value
            )

            st.session_state.finanzierungsmodelle[modell_id] = neues_modell

            # Speichere die ID f√ºr die Angebots-Anfrage Option
            st.session_state['letztes_gespeichertes_modell_id'] = modell_id

            st.success(f"‚úÖ Modell '{modell_name}' wurde gespeichert!")
            st.info("Sie finden das Modell im Tab 'üíæ Gespeicherte Modelle'.")
            st.rerun()

    # Option: Angebot anfordern nach Speichern
    if 'letztes_gespeichertes_modell_id' in st.session_state:
        modell_id = st.session_state.letztes_gespeichertes_modell_id
        if modell_id in st.session_state.finanzierungsmodelle:
            st.markdown("---")
            st.markdown("**üí° M√∂chten Sie direkt ein Angebot bei Finanzierern anfordern?**")
            col_btn1, col_btn2 = st.columns([1, 3])
            with col_btn1:
                if st.button("üì® Ja, Angebot anfordern", key=f"direct_anfrage_{modell_id}", type="primary"):
                    st.session_state[f'show_fin_dialog_{modell_id}'] = True
                    del st.session_state['letztes_gespeichertes_modell_id']
                    st.rerun()
            with col_btn2:
                if st.button("‚ùå Nein, sp√§ter", key=f"skip_anfrage_{modell_id}"):
                    del st.session_state['letztes_gespeichertes_modell_id']
                    st.rerun()

    # Dialog f√ºr direkte Anfrage nach Speichern anzeigen
    if 'finanzierungsmodelle' in st.session_state:
        for mid in list(st.session_state.finanzierungsmodelle.keys()):
            if st.session_state.get(f'show_fin_dialog_{mid}', False):
                modell = st.session_state.finanzierungsmodelle.get(mid)
                if modell:
                    _render_finanzierer_auswahl_dialog(modell, f"neue_berechnung_{mid}")


def _modell_an_finanzierer_senden(modell_id: str, finanzierer_ids: List[str], an_alle: bool = False):
    """
    √úbertr√§gt ein Finanzierungsmodell in den Bereich 'Finanzierung anfragen' und sendet es an Finanzierer.

    Args:
        modell_id: ID des Finanzierungsmodells
        finanzierer_ids: Liste der ausgew√§hlten Finanzierer-IDs
        an_alle: Wenn True, an alle verf√ºgbaren Finanzierer senden
    """
    import uuid

    if modell_id not in st.session_state.finanzierungsmodelle:
        return None

    modell = st.session_state.finanzierungsmodelle[modell_id]
    user_id = st.session_state.current_user.user_id

    # Initialisiere Session State falls n√∂tig
    if 'finanzierungsanfragen' not in st.session_state:
        st.session_state.finanzierungsanfragen = {}
    if 'finanzierungsanfragen_an_finanzierer' not in st.session_state:
        st.session_state.finanzierungsanfragen_an_finanzierer = {}

    # Erstelle Hauptanfrage
    anfrage_id = f"fa_{modell_id}_{uuid.uuid4().hex[:6]}"

    anfrage = FinanzierungsAnfrage(
        anfrage_id=anfrage_id,
        projekt_id=modell.projekt_id,
        kaeufer_id=user_id,
        kaufpreis=modell.kaufpreis,
        eigenkapital=modell.eigenkapital,
        finanzierungsbetrag=modell.finanzierungsbedarf,
        wunsch_zinssatz=modell.zinssatz,
        wunsch_tilgung=modell.tilgungssatz,
        wunsch_laufzeit=modell.sollzinsbindung,
        sondertilgung_gewuenscht=modell.sondertilgung_prozent > 0,
        dokumente_freigegeben=True,
        notizen=modell.notizen,
        modell_id=modell_id,
        finanzierer_ids=finanzierer_ids if not an_alle else [],
        an_alle_finanzierer=an_alle,
        anfrage_status="Gesendet"
    )

    st.session_state.finanzierungsanfragen[anfrage_id] = anfrage

    # Update Modell-Status
    modell.status = FinanzierungsmodellStatus.ANGEFORDERT.value
    modell.geaendert_am = datetime.now()

    # Ermittle Finanzierer f√ºr das Projekt
    projekt = st.session_state.projekte.get(modell.projekt_id)

    # Sammle alle Finanzierer (aus Projekt und eingeladene)
    alle_finanzierer = []
    if projekt and projekt.finanzierer_ids:
        alle_finanzierer.extend(projekt.finanzierer_ids)

    # Eingeladene Finanzierer hinzuf√ºgen
    if 'finanzierer_einladungen' in st.session_state:
        for einl in st.session_state.finanzierer_einladungen.values():
            if einl.projekt_id == modell.projekt_id and einl.finanzierer_user_id:
                if einl.finanzierer_user_id not in alle_finanzierer:
                    alle_finanzierer.append(einl.finanzierer_user_id)

    # Bestimme Empf√§nger
    if an_alle:
        empfaenger = alle_finanzierer
    else:
        empfaenger = finanzierer_ids

    # Erstelle einzelne Anfragen an Finanzierer
    for fin_id in empfaenger:
        einzeln_id = f"faf_{anfrage_id}_{fin_id[:8]}"
        einzelanfrage = FinanzierungsanfrageAnFinanzierer(
            anfrage_einzeln_id=einzeln_id,
            hauptanfrage_id=anfrage_id,
            modell_id=modell_id,
            finanzierer_id=fin_id,
            kaeufer_id=user_id,
            projekt_id=modell.projekt_id
        )
        st.session_state.finanzierungsanfragen_an_finanzierer[einzeln_id] = einzelanfrage

        # Benachrichtigung an Finanzierer
        fin_user = st.session_state.users.get(fin_id)
        fin_name = fin_user.name if fin_user else "Finanzierer"
        projekt_name = projekt.name if projekt else "Unbekanntes Projekt"

        create_notification(
            fin_id,
            "Neue Finanzierungsanfrage",
            f"Ein K√§ufer hat Ihnen eine detaillierte Finanzierungsanfrage f√ºr '{projekt_name}' gesendet. Darlehensbetrag: {modell.darlehensbetrag:,.2f} ‚Ç¨",
            NotificationType.INFO.value
        )

    return anfrage_id


def _render_finanzierer_auswahl_dialog(modell: 'Finanzierungsmodell', dialog_key: str):
    """Rendert einen Dialog zur Auswahl der Finanzierer f√ºr eine Anfrage"""

    user_id = st.session_state.current_user.user_id
    projekt = st.session_state.projekte.get(modell.projekt_id) if modell.projekt_id else None

    st.markdown("---")
    st.markdown("#### üì® Angebot bei Finanzierern anfordern")

    st.info(f"""
    **Modell:** {modell.name}
    **Darlehensbetrag:** {modell.darlehensbetrag:,.2f} ‚Ç¨
    **Monatliche Rate:** {modell.monatliche_rate:,.2f} ‚Ç¨
    """)

    # Sammle verf√ºgbare Finanzierer
    verfuegbare_finanzierer = []

    # Finanzierer aus dem Projekt
    if projekt and projekt.finanzierer_ids:
        for fin_id in projekt.finanzierer_ids:
            fin_user = st.session_state.users.get(fin_id)
            if fin_user:
                verfuegbare_finanzierer.append({
                    'id': fin_id,
                    'name': fin_user.name,
                    'firma': getattr(fin_user, 'firma', 'Finanzierer'),
                    'quelle': 'Projekt'
                })

    # Eingeladene Finanzierer
    if 'finanzierer_einladungen' in st.session_state:
        for einl in st.session_state.finanzierer_einladungen.values():
            if modell.projekt_id and einl.projekt_id == modell.projekt_id:
                if einl.finanzierer_user_id:
                    # Bereits registriert
                    fin_user = st.session_state.users.get(einl.finanzierer_user_id)
                    if fin_user and einl.finanzierer_user_id not in [f['id'] for f in verfuegbare_finanzierer]:
                        verfuegbare_finanzierer.append({
                            'id': einl.finanzierer_user_id,
                            'name': fin_user.name,
                            'firma': einl.firmenname or 'Finanzierer',
                            'quelle': 'Einladung'
                        })
                else:
                    # Noch nicht registriert
                    verfuegbare_finanzierer.append({
                        'id': f"pending_{einl.einladung_id}",
                        'name': einl.finanzierer_name or einl.finanzierer_email,
                        'firma': einl.firmenname or 'Ausstehend',
                        'quelle': 'Einladung (ausstehend)'
                    })

    if not verfuegbare_finanzierer:
        st.warning("""
        ‚ö†Ô∏è **Keine Finanzierer verf√ºgbar**

        Laden Sie zuerst Finanzierer ein oder wechseln Sie zum Tab "üè¶ Finanzierung anfragen"
        um einen Finanzierer zum Projekt hinzuzuf√ºgen.
        """)
        return

    # Auswahl-Option
    auswahl_modus = st.radio(
        "Anfrage senden an:",
        ["Ausgew√§hlte Finanzierer", "Alle Finanzierer"],
        key=f"fin_auswahl_modus_{dialog_key}"
    )

    ausgewaehlte_ids = []

    if auswahl_modus == "Ausgew√§hlte Finanzierer":
        st.markdown("**Finanzierer ausw√§hlen:**")
        for fin in verfuegbare_finanzierer:
            if not fin['id'].startswith('pending_'):
                selected = st.checkbox(
                    f"{fin['name']} ({fin['firma']})",
                    key=f"fin_select_{dialog_key}_{fin['id']}"
                )
                if selected:
                    ausgewaehlte_ids.append(fin['id'])
    else:
        st.success(f"Anfrage wird an **{len([f for f in verfuegbare_finanzierer if not f['id'].startswith('pending_')])} Finanzierer** gesendet.")
        ausgewaehlte_ids = [f['id'] for f in verfuegbare_finanzierer if not f['id'].startswith('pending_')]

    # Senden-Button
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üì® Anfrage jetzt senden", type="primary", key=f"send_anfrage_{dialog_key}"):
            if auswahl_modus == "Alle Finanzierer":
                anfrage_id = _modell_an_finanzierer_senden(modell.modell_id, [], an_alle=True)
            else:
                if not ausgewaehlte_ids:
                    st.error("Bitte w√§hlen Sie mindestens einen Finanzierer aus.")
                    return
                anfrage_id = _modell_an_finanzierer_senden(modell.modell_id, ausgewaehlte_ids, an_alle=False)

            if anfrage_id:
                st.success(f"‚úÖ Finanzierungsanfrage wurde an {len(ausgewaehlte_ids) if auswahl_modus != 'Alle Finanzierer' else 'alle'} Finanzierer gesendet!")
                st.info("Sie k√∂nnen den Status unter 'üè¶ Finanzierung anfragen' verfolgen.")
                # Dialog schlie√üen
                del st.session_state[f'show_fin_dialog_{modell.modell_id}']
                st.rerun()

    with col2:
        if st.button("‚ùå Abbrechen", key=f"cancel_anfrage_{dialog_key}"):
            if f'show_fin_dialog_{modell.modell_id}' in st.session_state:
                del st.session_state[f'show_fin_dialog_{modell.modell_id}']
            st.rerun()


def _finanzierung_gespeicherte_modelle():
    """Gespeicherte Finanzierungsmodelle anzeigen und verwalten"""
    import json

    st.markdown("#### üíæ Ihre gespeicherten Finanzierungsmodelle")

    # Filter nach aktuellem User
    user_id = st.session_state.current_user.user_id if st.session_state.current_user else ''
    user_modelle = {k: v for k, v in st.session_state.finanzierungsmodelle.items()
                    if v.kaeufer_id == user_id}

    if not user_modelle:
        st.info("""
        Sie haben noch keine Finanzierungsmodelle gespeichert.

        Erstellen Sie eine neue Berechnung im Tab "üìä Neue Berechnung" und speichern Sie diese.
        """)
        return

    st.success(f"**{len(user_modelle)} Modelle** gespeichert")

    # Sortierung
    sortierung = st.selectbox(
        "Sortieren nach:",
        ["Neueste zuerst", "√Ñlteste zuerst", "Niedrigste Rate", "H√∂chste Rate", "Favoriten"],
        key="modelle_sortierung"
    )

    modelle_liste = list(user_modelle.values())

    if sortierung == "Neueste zuerst":
        modelle_liste.sort(key=lambda x: x.erstellt_am, reverse=True)
    elif sortierung == "√Ñlteste zuerst":
        modelle_liste.sort(key=lambda x: x.erstellt_am)
    elif sortierung == "Niedrigste Rate":
        modelle_liste.sort(key=lambda x: x.monatliche_rate)
    elif sortierung == "H√∂chste Rate":
        modelle_liste.sort(key=lambda x: x.monatliche_rate, reverse=True)
    elif sortierung == "Favoriten":
        modelle_liste.sort(key=lambda x: (not x.ist_favorit, x.erstellt_am), reverse=True)

    # Modelle anzeigen
    for modell in modelle_liste:
        status_icon = "‚≠ê" if modell.ist_favorit else "üìã"
        quelle_icon = "üè¶" if "Finanzierer" in modell.quelle else "üßÆ"

        with st.expander(f"{status_icon} {modell.name} | {modell.monatliche_rate:,.2f} ‚Ç¨/Monat | {quelle_icon} {modell.quelle}", expanded=False):
            col1, col2, col3 = st.columns(3)

            with col1:
                st.markdown("**Finanzierung:**")
                st.write(f"Darlehensbetrag: {modell.darlehensbetrag:,.2f} ‚Ç¨")
                st.write(f"Eigenkapital: {modell.eigenkapital:,.2f} ‚Ç¨")
                st.write(f"Finanzierungsbedarf: {modell.finanzierungsbedarf:,.2f} ‚Ç¨")

            with col2:
                st.markdown("**Konditionen:**")
                st.write(f"Zinssatz: {modell.zinssatz:.2f}%")
                st.write(f"Tilgung: {modell.tilgungssatz:.2f}%")
                st.write(f"Sollzinsbindung: {modell.sollzinsbindung} Jahre")

            with col3:
                st.markdown("**Ergebnis:**")
                st.write(f"Monatliche Rate: {modell.monatliche_rate:,.2f} ‚Ç¨")
                st.write(f"Gesamtzinsen: {modell.gesamtzinsen:,.2f} ‚Ç¨")
                st.write(f"Restschuld ({modell.sollzinsbindung}J): {modell.restschuld_nach_zinsbindung:,.2f} ‚Ç¨")

            if modell.notizen:
                st.markdown(f"**Notizen:** {modell.notizen}")

            st.caption(f"Erstellt: {modell.erstellt_am.strftime('%d.%m.%Y %H:%M')} | Status: {modell.status}")

            # Aktionen
            st.markdown("---")
            col_a1, col_a2, col_a3, col_a4, col_a5 = st.columns(5)

            with col_a1:
                if st.button("‚≠ê Favorit", key=f"fav_{modell.modell_id}"):
                    modell.ist_favorit = not modell.ist_favorit
                    st.rerun()

            with col_a2:
                if st.button("‚úèÔ∏è Bearbeiten", key=f"edit_{modell.modell_id}"):
                    st.session_state[f'editing_modell_{modell.modell_id}'] = True
                    st.rerun()

            with col_a3:
                if st.button("üìã Kopieren", key=f"copy_{modell.modell_id}"):
                    import uuid
                    neues_id = str(uuid.uuid4())[:8]
                    kopie = Finanzierungsmodell(
                        modell_id=neues_id,
                        projekt_id=modell.projekt_id,
                        kaeufer_id=modell.kaeufer_id,
                        name=f"{modell.name} (Kopie)",
                        kaufpreis=modell.kaufpreis,
                        nebenkosten=modell.nebenkosten,
                        finanzierungsbedarf=modell.finanzierungsbedarf,
                        eigenkapital=modell.eigenkapital,
                        darlehensbetrag=modell.darlehensbetrag,
                        zinssatz=modell.zinssatz,
                        tilgungssatz=modell.tilgungssatz,
                        monatliche_rate=modell.monatliche_rate,
                        sollzinsbindung=modell.sollzinsbindung,
                        sondertilgung_prozent=modell.sondertilgung_prozent,
                        restschuld_nach_zinsbindung=modell.restschuld_nach_zinsbindung,
                        gesamtlaufzeit_jahre=modell.gesamtlaufzeit_jahre,
                        gesamtzinsen=modell.gesamtzinsen,
                        gesamtkosten=modell.gesamtkosten,
                        tilgungsplan_json=modell.tilgungsplan_json,
                        notizen=modell.notizen,
                        quelle=modell.quelle
                    )
                    st.session_state.finanzierungsmodelle[neues_id] = kopie
                    st.success("Modell wurde kopiert!")
                    st.rerun()

            with col_a4:
                if st.button("üì® Angebot anfordern", key=f"anfrage_{modell.modell_id}", type="primary"):
                    st.session_state[f'show_fin_dialog_{modell.modell_id}'] = True
                    st.rerun()

            with col_a5:
                if st.button("üóëÔ∏è L√∂schen", key=f"del_{modell.modell_id}"):
                    del st.session_state.finanzierungsmodelle[modell.modell_id]
                    st.success("Modell wurde gel√∂scht!")
                    st.rerun()

            # Dialog f√ºr Finanzierer-Auswahl anzeigen
            if st.session_state.get(f'show_fin_dialog_{modell.modell_id}', False):
                _render_finanzierer_auswahl_dialog(modell, f"gespeichert_{modell.modell_id}")

            # Editor anzeigen wenn aktiviert
            if st.session_state.get(f'editing_modell_{modell.modell_id}', False):
                st.markdown("---")
                st.markdown("#### ‚úèÔ∏è Modell bearbeiten")

                edit_col1, edit_col2 = st.columns(2)

                with edit_col1:
                    new_name = st.text_input("Name", value=modell.name, key=f"edit_name_{modell.modell_id}")
                    new_zinssatz = st.number_input("Zinssatz (%)", value=modell.zinssatz, step=0.1, key=f"edit_zins_{modell.modell_id}")
                    new_tilgung = st.number_input("Tilgung (%)", value=modell.tilgungssatz, step=0.1, key=f"edit_tilg_{modell.modell_id}")

                with edit_col2:
                    new_notizen = st.text_area("Notizen", value=modell.notizen, key=f"edit_notiz_{modell.modell_id}")
                    new_status = st.selectbox(
                        "Status",
                        [s.value for s in FinanzierungsmodellStatus],
                        index=[s.value for s in FinanzierungsmodellStatus].index(modell.status),
                        key=f"edit_status_{modell.modell_id}"
                    )

                col_save, col_cancel = st.columns(2)
                with col_save:
                    if st.button("üíæ √Ñnderungen speichern", key=f"save_edit_{modell.modell_id}"):
                        modell.name = new_name
                        modell.zinssatz = new_zinssatz
                        modell.tilgungssatz = new_tilgung
                        modell.notizen = new_notizen
                        modell.status = new_status
                        modell.geaendert_am = datetime.now()

                        # Rate neu berechnen
                        modell.monatliche_rate = modell.darlehensbetrag * (new_zinssatz + new_tilgung) / 100 / 12

                        del st.session_state[f'editing_modell_{modell.modell_id}']
                        st.success("√Ñnderungen gespeichert!")
                        st.rerun()

                with col_cancel:
                    if st.button("‚ùå Abbrechen", key=f"cancel_edit_{modell.modell_id}"):
                        del st.session_state[f'editing_modell_{modell.modell_id}']
                        st.rerun()


def _finanzierung_modelle_vergleichen():
    """Mehrere Finanzierungsmodelle miteinander vergleichen"""
    import pandas as pd

    st.markdown("#### ‚öñÔ∏è Finanzierungsmodelle vergleichen")

    user_id = st.session_state.current_user.user_id if st.session_state.current_user else ''
    user_modelle = {k: v for k, v in st.session_state.finanzierungsmodelle.items()
                    if v.kaeufer_id == user_id}

    if len(user_modelle) < 2:
        st.info("""
        Speichern Sie mindestens 2 Finanzierungsmodelle, um diese vergleichen zu k√∂nnen.

        Erstellen Sie verschiedene Berechnungen mit unterschiedlichen Konditionen
        (z.B. verschiedene Zinss√§tze, Tilgungsraten) und speichern Sie diese.
        """)
        return

    # Modelle zur Auswahl
    modell_namen = {k: f"{v.name} ({v.monatliche_rate:,.2f} ‚Ç¨/Monat)" for k, v in user_modelle.items()}

    ausgewaehlte_ids = st.multiselect(
        "W√§hlen Sie Modelle zum Vergleich (2-4):",
        list(modell_namen.keys()),
        format_func=lambda x: modell_namen[x],
        max_selections=4,
        key="vergleich_auswahl"
    )

    if len(ausgewaehlte_ids) < 2:
        st.warning("Bitte w√§hlen Sie mindestens 2 Modelle zum Vergleich aus.")
        return

    ausgewaehlte_modelle = [user_modelle[mid] for mid in ausgewaehlte_ids]

    # Vergleichstabelle erstellen
    st.markdown("---")
    st.markdown("### üìä Vergleichs√ºbersicht")

    vergleich_data = {
        "Eigenschaft": [
            "üìã Name",
            "üí∞ Darlehensbetrag",
            "üíµ Eigenkapital",
            "üìà Zinssatz",
            "üìâ Tilgungssatz",
            "üóìÔ∏è Sollzinsbindung",
            "üí≥ Monatliche Rate",
            "üìä Gesamtzinsen",
            "üè¶ Restschuld n. Bindung",
            "‚è±Ô∏è Gesamtlaufzeit",
            "üíé Gesamtkosten",
            "üìù Quelle"
        ]
    }

    for modell in ausgewaehlte_modelle:
        vergleich_data[modell.name[:20]] = [
            modell.name,
            f"{modell.darlehensbetrag:,.2f} ‚Ç¨",
            f"{modell.eigenkapital:,.2f} ‚Ç¨",
            f"{modell.zinssatz:.2f}%",
            f"{modell.tilgungssatz:.2f}%",
            f"{modell.sollzinsbindung} Jahre",
            f"{modell.monatliche_rate:,.2f} ‚Ç¨",
            f"{modell.gesamtzinsen:,.2f} ‚Ç¨",
            f"{modell.restschuld_nach_zinsbindung:,.2f} ‚Ç¨",
            f"{modell.gesamtlaufzeit_jahre:.1f} Jahre",
            f"{modell.gesamtkosten:,.2f} ‚Ç¨",
            modell.quelle
        ]

    df_vergleich = pd.DataFrame(vergleich_data)
    st.dataframe(df_vergleich, use_container_width=True, hide_index=True)

    # Empfehlung
    st.markdown("---")
    st.markdown("### üí° Analyse")

    # Beste Optionen finden
    niedrigste_rate = min(ausgewaehlte_modelle, key=lambda x: x.monatliche_rate)
    niedrigste_zinsen = min(ausgewaehlte_modelle, key=lambda x: x.gesamtzinsen)
    niedrigste_restschuld = min(ausgewaehlte_modelle, key=lambda x: x.restschuld_nach_zinsbindung)

    col1, col2, col3 = st.columns(3)

    with col1:
        st.success(f"""
        **üí≥ Niedrigste Rate:**
        {niedrigste_rate.name}

        {niedrigste_rate.monatliche_rate:,.2f} ‚Ç¨/Monat
        """)

    with col2:
        st.success(f"""
        **üìä Niedrigste Gesamtzinsen:**
        {niedrigste_zinsen.name}

        {niedrigste_zinsen.gesamtzinsen:,.2f} ‚Ç¨
        """)

    with col3:
        st.success(f"""
        **üè¶ Niedrigste Restschuld:**
        {niedrigste_restschuld.name}

        {niedrigste_restschuld.restschuld_nach_zinsbindung:,.2f} ‚Ç¨
        """)

    # Differenzen anzeigen
    if len(ausgewaehlte_modelle) == 2:
        m1, m2 = ausgewaehlte_modelle
        st.markdown("---")
        st.markdown("### üìà Differenzen")

        diff_rate = m2.monatliche_rate - m1.monatliche_rate
        diff_zinsen = m2.gesamtzinsen - m1.gesamtzinsen
        diff_restschuld = m2.restschuld_nach_zinsbindung - m1.restschuld_nach_zinsbindung

        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric(
                "Rate Differenz",
                f"{abs(diff_rate):,.2f} ‚Ç¨",
                delta=f"{diff_rate:+,.2f} ‚Ç¨ ({m2.name[:15]})"
            )

        with col2:
            st.metric(
                "Zinsen Differenz",
                f"{abs(diff_zinsen):,.2f} ‚Ç¨",
                delta=f"{diff_zinsen:+,.2f} ‚Ç¨ ({m2.name[:15]})"
            )

        with col3:
            st.metric(
                "Restschuld Differenz",
                f"{abs(diff_restschuld):,.2f} ‚Ç¨",
                delta=f"{diff_restschuld:+,.2f} ‚Ç¨ ({m2.name[:15]})"
            )

    # ===== ANGEBOT ANFORDERN =====
    st.markdown("---")
    st.markdown("### üì® Angebot bei Finanzierern anfordern")

    st.info("W√§hlen Sie ein Modell aus, f√ºr das Sie ein konkretes Angebot von Finanzierern erhalten m√∂chten.")

    # Modell f√ºr Anfrage ausw√§hlen
    anfrage_modell_id = st.selectbox(
        "Modell f√ºr Finanzierungsanfrage:",
        ausgewaehlte_ids,
        format_func=lambda x: modell_namen[x],
        key="vergleich_anfrage_modell"
    )

    if anfrage_modell_id:
        modell = user_modelle[anfrage_modell_id]

        col1, col2 = st.columns([2, 1])
        with col1:
            if st.button("üì® Angebot f√ºr dieses Modell anfordern", type="primary", key="vergleich_anfrage_btn"):
                st.session_state[f'show_fin_dialog_{anfrage_modell_id}'] = True
                st.rerun()

        # Dialog anzeigen
        if st.session_state.get(f'show_fin_dialog_{anfrage_modell_id}', False):
            _render_finanzierer_auswahl_dialog(modell, f"vergleich_{anfrage_modell_id}")


def _finanzierung_angebot_importieren():
    """Finanzierer-Angebot importieren (PDF, CSV, Excel)"""
    import json
    import uuid

    st.markdown("#### üì• Finanzierer-Angebot importieren")

    st.info("""
    Importieren Sie ein Angebot von Ihrem Finanzierer.
    Unterst√ºtzte Formate: **PDF**, **CSV**, **Excel**

    Das importierte Angebot wird als neues Finanzierungsmodell gespeichert
    und kann mit Ihren eigenen Berechnungen verglichen werden.
    """)

    # Upload
    uploaded_file = st.file_uploader(
        "Angebot hochladen",
        type=['pdf', 'csv', 'xlsx', 'xls'],
        key="import_angebot"
    )

    if uploaded_file:
        file_type = uploaded_file.name.split('.')[-1].lower()

        st.success(f"‚úÖ Datei '{uploaded_file.name}' hochgeladen ({file_type.upper()})")

        # Manuelle Eingabe der Konditionen (da PDF-Parsing komplex ist)
        st.markdown("---")
        st.markdown("### üìù Angebotsdaten eingeben")
        st.caption("√úbertragen Sie die Konditionen aus dem Angebot:")

        col1, col2 = st.columns(2)

        with col1:
            import_name = st.text_input(
                "Name des Angebots",
                value=f"Angebot {uploaded_file.name}",
                key="import_name"
            )
            import_finanzierer = st.text_input(
                "Name des Finanzierers/Bank",
                key="import_finanzierer"
            )
            import_darlehensbetrag = st.number_input(
                "Darlehensbetrag (‚Ç¨)",
                min_value=0.0,
                value=300000.0,
                step=5000.0,
                key="import_darlehen"
            )
            import_zinssatz = st.number_input(
                "Sollzinssatz (%)",
                min_value=0.0,
                max_value=15.0,
                value=3.5,
                step=0.1,
                key="import_zins"
            )

        with col2:
            import_tilgung = st.number_input(
                "Anf√§ngliche Tilgung (%)",
                min_value=0.0,
                max_value=10.0,
                value=2.0,
                step=0.1,
                key="import_tilgung"
            )
            import_rate = st.number_input(
                "Monatliche Rate (‚Ç¨)",
                min_value=0.0,
                value=import_darlehensbetrag * (import_zinssatz + import_tilgung) / 100 / 12,
                step=50.0,
                key="import_rate"
            )
            import_bindung = st.number_input(
                "Sollzinsbindung (Jahre)",
                min_value=1,
                max_value=30,
                value=10,
                key="import_bindung"
            )
            import_effektivzins = st.number_input(
                "Effektivzins (%) - falls angegeben",
                min_value=0.0,
                max_value=15.0,
                value=0.0,
                step=0.1,
                key="import_effektiv"
            )

        import_notizen = st.text_area(
            "Besondere Bedingungen / Notizen",
            placeholder="z.B. Sondertilgungsrecht, Bereitstellungszinsen, Bearbeitungsgeb√ºhren...",
            key="import_notizen"
        )

        if st.button("üíæ Angebot als Modell speichern", type="primary", key="speichere_import"):
            modell_id = str(uuid.uuid4())[:8]

            # Quelle basierend auf Dateityp
            if file_type == 'pdf':
                quelle = FinanzierungsmodellQuelle.IMPORT_PDF.value
            elif file_type == 'csv':
                quelle = FinanzierungsmodellQuelle.IMPORT_CSV.value
            else:
                quelle = FinanzierungsmodellQuelle.IMPORT_EXCEL.value

            # Restschuld berechnen (vereinfacht)
            monatszins = import_zinssatz / 100 / 12
            restschuld = import_darlehensbetrag
            for _ in range(import_bindung * 12):
                zinsen = restschuld * monatszins
                tilgung = import_rate - zinsen
                if tilgung > 0:
                    restschuld -= tilgung
                if restschuld <= 0:
                    break

            neues_modell = Finanzierungsmodell(
                modell_id=modell_id,
                projekt_id=st.session_state.get('aktuelles_projekt_id', ''),
                kaeufer_id=st.session_state.current_user.user_id if st.session_state.current_user else '',
                name=import_name,
                kaufpreis=st.session_state.get('berechneter_kaufpreis', 0),
                nebenkosten=st.session_state.get('berechnete_nebenkosten', 0),
                finanzierungsbedarf=import_darlehensbetrag + st.session_state.get('berechnete_nebenkosten', 0),
                eigenkapital=0,
                darlehensbetrag=import_darlehensbetrag,
                zinssatz=import_zinssatz,
                tilgungssatz=import_tilgung,
                monatliche_rate=import_rate,
                sollzinsbindung=import_bindung,
                effektivzins=import_effektivzins,
                restschuld_nach_zinsbindung=max(0, restschuld),
                notizen=import_notizen,
                quelle=quelle,
                finanzierer_name=import_finanzierer,
                angebot_pdf_data=uploaded_file.read() if file_type == 'pdf' else None,
                status=FinanzierungsmodellStatus.ANGEBOT_ERHALTEN.value
            )

            st.session_state.finanzierungsmodelle[modell_id] = neues_modell
            st.success(f"‚úÖ Angebot '{import_name}' wurde als Modell gespeichert!")
            st.info("Sie k√∂nnen es jetzt im Tab 'üíæ Gespeicherte Modelle' einsehen und vergleichen.")

    else:
        # Alternative: Manuelle Eingabe ohne Datei
        st.markdown("---")
        st.markdown("**Oder:** Geben Sie die Konditionen manuell ein:")

        if st.checkbox("Manuelle Eingabe ohne Datei-Upload", key="manual_import"):
            col1, col2 = st.columns(2)

            with col1:
                manual_name = st.text_input("Name des Angebots", key="manual_name")
                manual_finanzierer = st.text_input("Bank/Finanzierer", key="manual_finanzierer")
                manual_darlehen = st.number_input("Darlehensbetrag (‚Ç¨)", min_value=0.0, value=300000.0, key="manual_darlehen")
                manual_zins = st.number_input("Sollzinssatz (%)", min_value=0.0, value=3.5, step=0.1, key="manual_zins")

            with col2:
                manual_tilgung = st.number_input("Tilgung (%)", min_value=0.0, value=2.0, step=0.1, key="manual_tilgung")
                manual_rate = st.number_input("Monatliche Rate (‚Ç¨)", min_value=0.0, value=1375.0, key="manual_rate")
                manual_bindung = st.number_input("Sollzinsbindung (Jahre)", min_value=1, value=10, key="manual_bindung")

            manual_notizen = st.text_area("Notizen", key="manual_notizen")

            if st.button("üíæ Manuelles Angebot speichern", key="save_manual"):
                if not manual_name:
                    st.error("Bitte geben Sie einen Namen ein.")
                    return

                modell_id = str(uuid.uuid4())[:8]

                neues_modell = Finanzierungsmodell(
                    modell_id=modell_id,
                    projekt_id=st.session_state.get('aktuelles_projekt_id', ''),
                    kaeufer_id=st.session_state.current_user.user_id if st.session_state.current_user else '',
                    name=manual_name,
                    kaufpreis=0,
                    nebenkosten=0,
                    finanzierungsbedarf=manual_darlehen,
                    eigenkapital=0,
                    darlehensbetrag=manual_darlehen,
                    zinssatz=manual_zins,
                    tilgungssatz=manual_tilgung,
                    monatliche_rate=manual_rate,
                    sollzinsbindung=manual_bindung,
                    notizen=manual_notizen,
                    quelle=FinanzierungsmodellQuelle.FINANZIERER_ANGEBOT.value,
                    finanzierer_name=manual_finanzierer,
                    status=FinanzierungsmodellStatus.ANGEBOT_ERHALTEN.value
                )

                st.session_state.finanzierungsmodelle[modell_id] = neues_modell
                st.success(f"‚úÖ Angebot '{manual_name}' gespeichert!")


def kaeufer_kaufnebenkosten_view(projekte):
    """Kaufnebenkosten-Rechner f√ºr K√§ufer - Notar, Grundbuch, Makler, Grunderwerbsteuer"""
    st.markdown("### üí∂ Kaufnebenkosten berechnen")

    st.info("""
    Berechnen Sie hier alle Kaufnebenkosten f√ºr Ihre Immobilie.
    Die Berechnung erfolgt nach aktuellen GNotKG-S√§tzen (Stand 2024).
    Bei Finanzierungsbedarf werden auch die Kosten f√ºr die Grundschuldbestellung berechnet.
    """)

    # Grunderwerbsteuer-S√§tze nach Bundesland
    GRUNDERWERBSTEUER_SAETZE = {
        "Baden-W√ºrttemberg": 5.0,
        "Bayern": 3.5,
        "Berlin": 6.0,
        "Brandenburg": 6.5,
        "Bremen": 5.0,
        "Hamburg": 5.5,
        "Hessen": 6.0,
        "Mecklenburg-Vorpommern": 6.0,
        "Niedersachsen": 5.0,
        "Nordrhein-Westfalen": 6.5,
        "Rheinland-Pfalz": 5.0,
        "Saarland": 6.5,
        "Sachsen": 5.5,
        "Sachsen-Anhalt": 5.0,
        "Schleswig-Holstein": 6.5,
        "Th√ºringen": 5.0,
    }

    # Projekt ausw√§hlen wenn mehrere vorhanden
    if len(projekte) > 1:
        projekt_namen = {p.projekt_id: p.name for p in projekte}
        ausgewaehltes_id = st.selectbox(
            "Projekt ausw√§hlen",
            list(projekt_namen.keys()),
            format_func=lambda x: projekt_namen[x],
            key="kosten_projekt_auswahl"
        )
        projekt = next((p for p in projekte if p.projekt_id == ausgewaehltes_id), projekte[0])
    elif projekte:
        projekt = projekte[0]
    else:
        st.warning("Kein Projekt vorhanden.")
        return

    st.markdown(f"#### üè† {projekt.name}")
    if projekt.adresse:
        st.caption(f"üìç {projekt.adresse}")

    # Hinweis zur Kaufpreis-Eingabe
    st.warning("""
    ‚ö†Ô∏è **Wichtig:** Geben Sie hier den **endg√ºltigen Kaufpreis** ein, der im Kaufvertrag vereinbart wird.
    Dieser Preis ist die Grundlage f√ºr alle Nebenkosten-Berechnungen und den Finanzierungsbedarf.
    """)

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("##### üíµ Grunddaten")

        # Option: Kaufpreis aus Projekt √ºbernehmen oder manuell eingeben
        projekt_kaufpreis = float(projekt.kaufpreis) if projekt.kaufpreis > 0 else 0.0

        if projekt_kaufpreis > 0:
            kaufpreis_quelle = st.radio(
                "Kaufpreis:",
                ["Aus Projekt √ºbernehmen", "Anderen Kaufpreis eingeben"],
                horizontal=True,
                key=f"kaufpreis_quelle_{projekt.projekt_id}"
            )

            if kaufpreis_quelle == "Aus Projekt √ºbernehmen":
                kaufpreis = projekt_kaufpreis
                st.metric("Kaufpreis aus Projekt", f"{kaufpreis:,.2f} ‚Ç¨")
                st.caption("Dieser Kaufpreis wurde im Projekt hinterlegt.")
            else:
                kaufpreis = st.number_input(
                    "Endg√ºltiger Kaufpreis (‚Ç¨)",
                    min_value=0.0,
                    value=projekt_kaufpreis,
                    step=5000.0,
                    key=f"kosten_kaufpreis_manuell_{projekt.projekt_id}",
                    help="Geben Sie hier den verhandelten Kaufpreis ein"
                )
        else:
            st.info("üí° Im Projekt ist noch kein Kaufpreis hinterlegt.")
            kaufpreis = st.number_input(
                "Endg√ºltiger Kaufpreis (‚Ç¨)",
                min_value=0.0,
                value=300000.0,
                step=5000.0,
                key=f"kosten_kaufpreis_{projekt.projekt_id}",
                help="Geben Sie hier den verhandelten Kaufpreis ein"
            )

        # Bundesland f√ºr Grunderwerbsteuer
        bundesland = st.selectbox(
            "Bundesland der Immobilie",
            list(GRUNDERWERBSTEUER_SAETZE.keys()),
            index=list(GRUNDERWERBSTEUER_SAETZE.keys()).index("Nordrhein-Westfalen"),
            key=f"kosten_bundesland_{projekt.projekt_id}"
        )
        grunderwerbsteuer_prozent = GRUNDERWERBSTEUER_SAETZE[bundesland]
        st.caption(f"Grunderwerbsteuersatz: {grunderwerbsteuer_prozent}%")

        # Maklergeb√ºhren
        st.markdown("##### üè¢ Maklergeb√ºhren")

        # Pr√ºfe ob Makler dem Projekt zugeordnet ist
        makler_provision = 3.57  # Standard
        if projekt.makler_id and 'makler_profile' in st.session_state:
            makler_profil = st.session_state.makler_profile.get(projekt.makler_id)
            if makler_profil and hasattr(makler_profil, 'provision_prozent') and makler_profil.provision_prozent:
                makler_provision = makler_profil.provision_prozent
                st.caption(f"Provision des zugeordneten Maklers: {makler_provision}%")

        makler_provision_input = st.number_input(
            "Maklerprovision K√§uferanteil (%)",
            min_value=0.0,
            max_value=7.14,
            value=makler_provision,
            step=0.01,
            key=f"kosten_makler_{projekt.projekt_id}",
            help="√úblich sind 3,57% (inkl. MwSt.) oder 50% der Gesamtprovision"
        )

        makler_inkl_mwst = st.checkbox(
            "Provision inkl. MwSt.",
            value=True,
            key=f"kosten_makler_mwst_{projekt.projekt_id}"
        )

    with col2:
        st.markdown("##### üè¶ Finanzierung")

        benoetigt_finanzierung = st.checkbox(
            "Finanzierung ben√∂tigt (Grundschuld)",
            value=True,
            key=f"kosten_finanzierung_{projekt.projekt_id}"
        )

        grundschulden = []
        if benoetigt_finanzierung:
            anzahl_grundschulden = st.number_input(
                "Anzahl Grundschulden",
                min_value=1,
                max_value=5,
                value=1,
                key=f"kosten_anzahl_gs_{projekt.projekt_id}",
                help="Meist 1, bei mehreren Banken ggf. mehr"
            )

            for i in range(int(anzahl_grundschulden)):
                gs_betrag = st.number_input(
                    f"Grundschuldbetrag {i+1} (‚Ç¨)",
                    min_value=0.0,
                    value=float(kaufpreis) if i == 0 else 0.0,
                    step=5000.0,
                    key=f"kosten_gs_{projekt.projekt_id}_{i}"
                )
                if gs_betrag > 0:
                    grundschulden.append(gs_betrag)

    # Berechnung durchf√ºhren
    st.markdown("---")
    st.markdown("### üìä Kosten√ºbersicht")

    # Einzelne Berechnungen
    notar = berechne_notarkosten_kaufvertrag(kaufpreis)
    grundbuch = berechne_grundbuchkosten_kaufvertrag(kaufpreis)
    makler = berechne_maklerkosten(kaufpreis, makler_provision_input, makler_inkl_mwst)
    grunderwerbsteuer = kaufpreis * (grunderwerbsteuer_prozent / 100)

    # Grundschuldkosten wenn Finanzierung
    grundschuld_kosten = None
    if grundschulden:
        gs_gesamt = sum(grundschulden)
        grundschuld_kosten = berechne_grundschuldkosten(gs_gesamt, len(grundschulden))

    # √úbersicht in Columns
    col1, col2, col3 = st.columns(3)

    with col1:
        st.markdown("##### üìú Notarkosten")
        st.metric("Gesamt", f"{notar['gesamt']:,.2f} ‚Ç¨")
        with st.expander("Details"):
            st.write(f"Beurkundung (2,0): {notar['beurkundung']:,.2f} ‚Ç¨")
            st.write(f"Vollzug (0,5): {notar['vollzug']:,.2f} ‚Ç¨")
            st.write(f"Betreuung (0,5): {notar['betreuung']:,.2f} ‚Ç¨")
            st.write(f"Auslagen: {notar['auslagen']:,.2f} ‚Ç¨")
            st.write(f"MwSt. (19%): {notar['mwst']:,.2f} ‚Ç¨")

    with col2:
        st.markdown("##### üìñ Grundbuchkosten")
        st.metric("Gesamt", f"{grundbuch['gesamt']:,.2f} ‚Ç¨")
        with st.expander("Details"):
            st.write(f"Eigentumsumschreibung (1,0): {grundbuch['eigentumsumschreibung']:,.2f} ‚Ç¨")
            st.write(f"Auflassungsvormerkung (0,5): {grundbuch['auflassungsvormerkung']:,.2f} ‚Ç¨")

    with col3:
        st.markdown("##### üè¢ Maklerkosten")
        st.metric("Gesamt", f"{makler['gesamt']:,.2f} ‚Ç¨")
        with st.expander("Details"):
            st.write(f"Provision: {makler['provision_prozent']:.2f}%")
            if makler_inkl_mwst:
                st.write(f"Netto: {makler['netto']:,.2f} ‚Ç¨")
                st.write(f"MwSt.: {makler['mwst']:,.2f} ‚Ç¨")

    # Grunderwerbsteuer und Grundschuld in zweiter Reihe
    col1, col2, col3 = st.columns(3)

    with col1:
        st.markdown("##### üèõÔ∏è Grunderwerbsteuer")
        st.metric("Gesamt", f"{grunderwerbsteuer:,.2f} ‚Ç¨")
        st.caption(f"{grunderwerbsteuer_prozent}% in {bundesland}")

    with col2:
        if grundschuld_kosten:
            st.markdown("##### üè¶ Grundschuldkosten")
            gs_total = grundschuld_kosten['notar_gesamt'] + grundschuld_kosten['grundbuch_gesamt']
            st.metric("Gesamt", f"{gs_total:,.2f} ‚Ç¨")
            with st.expander("Details"):
                st.write(f"**Notar:**")
                st.write(f"  Beurkundung (1,0): {grundschuld_kosten['notar_beurkundung']:,.2f} ‚Ç¨")
                st.write(f"  Vollzug (0,5): {grundschuld_kosten['notar_vollzug']:,.2f} ‚Ç¨")
                st.write(f"  MwSt.: {grundschuld_kosten['notar_mwst']:,.2f} ‚Ç¨")
                st.write(f"**Grundbuch:**")
                st.write(f"  Eintragung (1,0): {grundschuld_kosten['grundbuch_eintragung']:,.2f} ‚Ç¨")

    # Gesamtsumme
    st.markdown("---")
    st.markdown("### üí∞ Gesamtkosten")

    # Berechne Gesamtkosten
    gesamtkosten = berechne_gesamtkosten_kaeufer(
        kaufpreis=kaufpreis,
        makler_provision_prozent=makler_provision_input,
        grundschulden=grundschulden if grundschulden else [],
        grunderwerbsteuer_prozent=grunderwerbsteuer_prozent
    )

    col1, col2, col3 = st.columns(3)

    with col1:
        st.metric(
            "Kaufpreis",
            f"{kaufpreis:,.2f} ‚Ç¨"
        )

    with col2:
        st.metric(
            "Nebenkosten",
            f"{gesamtkosten['nebenkosten_gesamt']:,.2f} ‚Ç¨",
            delta=f"{(gesamtkosten['nebenkosten_gesamt']/kaufpreis*100):.1f}% vom Kaufpreis"
        )

    with col3:
        st.metric(
            "Gesamtinvestition",
            f"{gesamtkosten['gesamtkosten']:,.2f} ‚Ç¨"
        )

    # Detailaufstellung
    with st.expander("üìã Detaillierte Aufstellung", expanded=True):
        aufstellung = [
            ("Kaufpreis", kaufpreis),
            ("Notarkosten (Kaufvertrag)", notar['gesamt']),
            ("Grundbuchkosten (Kaufvertrag)", grundbuch['gesamt']),
            ("Maklerkosten", makler['gesamt']),
            ("Grunderwerbsteuer", grunderwerbsteuer),
        ]

        if grundschuld_kosten:
            aufstellung.append(("Notar Grundschuldbestellung", grundschuld_kosten['notar_gesamt']))
            aufstellung.append(("Grundbuch Grundschuldbestellung", grundschuld_kosten['grundbuch_gesamt']))

        for bezeichnung, betrag in aufstellung:
            col1, col2 = st.columns([3, 1])
            col1.write(bezeichnung)
            col2.write(f"{betrag:,.2f} ‚Ç¨")

        st.markdown("---")
        col1, col2 = st.columns([3, 1])
        col1.markdown("**Gesamt zu zahlen**")
        col2.markdown(f"**{gesamtkosten['gesamtkosten']:,.2f} ‚Ç¨**")

    # Finanzierungsbedarf in Session State speichern f√ºr Kreditrechner
    st.session_state['berechneter_finanzierungsbedarf'] = gesamtkosten['gesamtkosten']
    st.session_state['berechneter_kaufpreis'] = kaufpreis
    st.session_state['berechnete_nebenkosten'] = gesamtkosten['nebenkosten_gesamt']

    # Hinweis zur √úbernahme in Kreditrechner
    st.markdown("---")
    st.success(f"""
    ‚úÖ **Finanzierungsbedarf: {gesamtkosten['gesamtkosten']:,.2f} ‚Ç¨**

    Dieser Betrag wurde automatisch f√ºr den Kreditrechner √ºbernommen.
    Wechseln Sie zum Tab **'üßÆ Kreditrechner'** um Ihre Finanzierung zu berechnen.
    """)

    # Info-Box
    st.info("""
    **Hinweis:** Diese Berechnung dient nur zur Orientierung. Die tats√§chlichen Kosten k√∂nnen
    abweichen und werden vom Notar verbindlich berechnet. Weitere m√∂gliche Kosten wie
    Sch√§tzgeb√ºhren der Bank, Bereitstellungszinsen oder Umzugskosten sind nicht enthalten.
    """)


def kaeufer_nachrichten():
    """Nachrichten f√ºr K√§ufer"""
    st.subheader("üí¨ Nachrichten")

    user_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids]

    if not projekte:
        st.info("Noch keine Projekte vorhanden.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            # Kommentare anzeigen (nur die f√ºr K√§ufer sichtbar sind)
            projekt_comments = [c for c in st.session_state.comments.values()
                              if c.projekt_id == projekt.projekt_id and "K√§ufer" in c.sichtbar_fuer]
            projekt_comments.sort(key=lambda c: c.created_at, reverse=True)

            if projekt_comments:
                for comment in projekt_comments:
                    user = st.session_state.users.get(comment.user_id)
                    user_name = user.name if user else "Unbekannt"

                    st.markdown(f"""
                    <div style='background:#f0f0f0; padding:10px; border-radius:5px; margin:10px 0;'>
                        <strong>{user_name}</strong> <small>({comment.created_at.strftime('%d.%m.%Y %H:%M')})</small><br>
                        {comment.nachricht}
                    </div>
                    """, unsafe_allow_html=True)
            else:
                st.info("Noch keine Nachrichten.")

def kaeufer_dokumente_view():
    """Dokumenten-√úbersicht f√ºr K√§ufer"""
    st.subheader("üìÑ Akzeptierte Dokumente")

    user = st.session_state.current_user
    if user.document_acceptances:
        for acc in user.document_acceptances:
            st.write(f"‚úÖ {acc.document_type} (Version {acc.document_version}) - akzeptiert am {acc.accepted_at.strftime('%d.%m.%Y %H:%M')}")
    else:
        st.info("Noch keine Dokumente akzeptiert.")

# ============================================================================
# VERK√ÑUFER-BEREICH
# ============================================================================

def verkaeufer_dashboard():
    """Dashboard f√ºr Verk√§ufer"""
    st.title("üè° Verk√§ufer-Dashboard")

    if not st.session_state.current_user.onboarding_complete:
        onboarding_flow()
        return

    # Pflicht-Akzeptanz von Rechtsdokumenten pr√ºfen
    user_id = st.session_state.current_user.user_id
    if not render_rechtsdokumente_akzeptanz_pflicht(user_id, UserRole.VERKAEUFER.value):
        # User muss erst Dokumente akzeptieren
        return

    # Aktentasche in der Sidebar
    render_aktentasche_sidebar(user_id)

    # Benachrichtigungs-Badge in der Sidebar
    render_benachrichtigungs_badge(user_id)

    # Teilen-Dialog anzeigen falls aktiv
    render_aktentasche_teilen_dialog(user_id)

    # Download-Dialog anzeigen falls aktiv
    render_aktentasche_download(user_id)

    # Suchleiste
    search_term = render_dashboard_search("verkaeufer")
    if search_term:
        st.session_state['verkaeufer_search'] = search_term
    else:
        st.session_state['verkaeufer_search'] = ''

    tabs = st.tabs(["üè† Mein Portal", "üìä Timeline", "üìã Projekte", "üìà Preisfindung", "üîç Makler finden", "ü™™ Ausweis", "üìÑ Dokumente hochladen", "üìã Dokumentenanforderungen", "üí¨ Nachrichten", "üí∂ Eigene Kosten", "üîÑ Vertragsvergleich", "üìÖ Termine"])

    with tabs[0]:
        # Mandanten-Portal √úbersicht
        render_mandanten_portal(user_id, UserRole.VERKAEUFER.value)

    with tabs[1]:
        verkaeufer_timeline_view()

    with tabs[2]:
        verkaeufer_projekte_view()

    with tabs[3]:
        verkaeufer_preisfindung_view()

    with tabs[4]:
        verkaeufer_makler_finden()

    with tabs[5]:
        # Personalausweis-Upload mit OCR
        st.subheader("ü™™ Ausweisdaten erfassen")
        render_ausweis_upload(st.session_state.current_user.user_id, UserRole.VERKAEUFER.value)

    with tabs[6]:
        verkaeufer_dokumente_view()

    with tabs[7]:
        render_document_requests_view(st.session_state.current_user.user_id, UserRole.VERKAEUFER.value)

    with tabs[8]:
        verkaeufer_nachrichten()

    with tabs[9]:
        verkaeufer_eigene_kosten_view()

    with tabs[10]:
        # Vertragsvergleich - Side-by-Side Diff
        st.subheader("üîÑ Vertragsversionen vergleichen")
        verkaeufer_projekte = [p for p in st.session_state.projekte.values()
                              if user_id in p.verkaeufer_ids]
        if verkaeufer_projekte:
            projekt_auswahl = {p.projekt_id: p.name for p in verkaeufer_projekte}
            selected_projekt_id = st.selectbox(
                "Projekt ausw√§hlen",
                list(projekt_auswahl.keys()),
                format_func=lambda x: projekt_auswahl[x],
                key="verkaeufer_vertragsvergleich_projekt"
            )
            if selected_projekt_id:
                render_vertragsvergleich_tab(selected_projekt_id, user_id, UserRole.VERKAEUFER.value)
        else:
            st.info("Sie sind noch keinem Projekt zugewiesen.")

    with tabs[11]:
        # Termin-√úbersicht f√ºr Verk√§ufer mit Kalender
        st.subheader("üìÖ Meine Termine")
        user_id = st.session_state.current_user.user_id

        # Kalender-Ansicht
        termin_ansicht = st.tabs(["üìÖ Kalender", "üìã Nach Projekt"])

        with termin_ansicht[0]:
            render_termin_kalender(user_id, UserRole.VERKAEUFER.value)

        with termin_ansicht[1]:
            projekte = [p for p in st.session_state.projekte.values() if user_id in p.verkaeufer_ids]
            if projekte:
                for projekt in projekte:
                    with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
                        render_termin_verwaltung(projekt, UserRole.VERKAEUFER.value)
            else:
                st.info("Noch keine Projekte vorhanden.")


def verkaeufer_preisfindung_view():
    """Preisfindung und Marktanalyse f√ºr Verk√§ufer - mit oder ohne Makler"""
    st.subheader("üìà Preisfindung & Marktanalyse")

    user_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if user_id in p.verkaeufer_ids]

    if not projekte:
        st.warning("Sie sind noch keinem Projekt als Verk√§ufer zugeordnet.")
        return

    # Projekt ausw√§hlen wenn mehrere
    if len(projekte) > 1:
        projekt_namen = {p.projekt_id: f"{p.name} - {p.adresse or 'Keine Adresse'}" for p in projekte}
        ausgewaehltes_id = st.selectbox(
            "Projekt ausw√§hlen",
            list(projekt_namen.keys()),
            format_func=lambda x: projekt_namen[x],
            key="vk_preisfindung_projekt_select"
        )
        projekt = next((p for p in projekte if p.projekt_id == ausgewaehltes_id), projekte[0])
    else:
        projekt = projekte[0]

    st.markdown(f"### üè† {projekt.name}")
    if projekt.adresse:
        st.caption(f"üìç {projekt.adresse}")

    # Pr√ºfen ob Makler vorhanden
    hat_makler = projekt.makler_id is not None and projekt.makler_id != ""

    # Expose-Daten holen (falls vorhanden)
    expose = None
    if projekt.expose_data_id and projekt.expose_data_id in st.session_state.expose_data:
        expose = st.session_state.expose_data[projekt.expose_data_id]

    # Wenn Makler vorhanden UND Expose-Daten mit Vergleichsobjekten
    if hat_makler and expose and expose.vergleichsobjekte:
        makler = st.session_state.users.get(projekt.makler_id)
        if makler:
            st.success(f"‚úÖ **Makler zugewiesen:** {makler.name}")
        st.info("Die Marktanalyse wird vom Makler durchgef√ºhrt. Hier sehen Sie die erfassten Vergleichsobjekte.")
        _verkaeufer_zeige_makler_marktanalyse(projekt, expose)

    elif hat_makler:
        # Makler vorhanden aber noch keine Vergleichsobjekte
        makler = st.session_state.users.get(projekt.makler_id)
        if makler:
            st.info(f"üë§ Betreuender Makler: **{makler.name}**")

        st.warning("""
        üì≠ **Noch keine Vergleichsobjekte erfasst**

        Der Makler hat noch keine Vergleichsobjekte zur Marktanalyse hinzugef√ºgt.
        Sobald diese erfasst sind, werden sie hier angezeigt.
        """)

        # Option: Selbst Vergleichsobjekte erfassen (tempor√§r)
        if st.checkbox("üí° Selbst Vergleichsobjekte erfassen (zur eigenen Orientierung)", key="vk_selbst_vgl"):
            _verkaeufer_eigene_marktanalyse(projekt)

    else:
        # Kein Makler - Verk√§ufer kann selbst Vergleichsobjekte eingeben
        st.info("""
        **üìä Preisfindung ohne Makler**

        Da kein Makler f√ºr dieses Projekt zugewiesen ist, k√∂nnen Sie selbst eine Marktanalyse
        durchf√ºhren. Erfassen Sie Vergleichsobjekte aus Ihrer Umgebung, um einen marktgerechten
        Verkaufspreis f√ºr Ihre Immobilie zu ermitteln.
        """)
        _verkaeufer_eigene_marktanalyse(projekt)


def _verkaeufer_zeige_makler_marktanalyse(projekt, expose):
    """Zeigt die vom Makler erfasste Marktanalyse an (readonly)"""

    # ===== AUTOMATISCHE MARKTANALYSE (readonly) =====
    # Zeige dem Verk√§ufer die automatische Analyse, wenn vorhanden
    if 'marktanalyse_ergebnisse' in st.session_state and projekt.projekt_id in st.session_state.marktanalyse_ergebnisse:
        user_id = st.session_state.current_user.user_id
        render_automatische_marktanalyse(projekt, user_id, kann_bearbeiten=False)
        st.markdown("---")

    # Objektdaten anzeigen
    st.markdown("---")
    st.markdown("#### üèòÔ∏è Ihre Immobilie")

    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Kaufpreis", f"{expose.kaufpreis:,.0f} ‚Ç¨" if expose.kaufpreis else "Noch offen")
    with col2:
        st.metric("Wohnfl√§che", f"{expose.wohnflaeche} m¬≤" if expose.wohnflaeche else "N/A")
    with col3:
        st.metric("Zimmer", expose.anzahl_zimmer if expose.anzahl_zimmer else "N/A")
    with col4:
        if expose.kaufpreis and expose.wohnflaeche and expose.wohnflaeche > 0:
            qm_preis = expose.kaufpreis / expose.wohnflaeche
            st.metric("Preis/m¬≤", f"{qm_preis:,.0f} ‚Ç¨")
        else:
            st.metric("Preis/m¬≤", "N/A")

    # Vergleichsobjekte anzeigen
    st.markdown("---")
    st.markdown("#### üìä Vergleichsobjekte aus dem Markt")

    if not expose.vergleichsobjekte:
        st.info("""
        üì≠ **Noch keine Vergleichsobjekte erfasst.**

        Der Makler hat noch keine Vergleichsobjekte zur Marktanalyse hinzugef√ºgt.
        Diese helfen bei der Einsch√§tzung des marktgerechten Preises f√ºr Ihre Immobilie.
        """)
        return

    st.success(f"‚úÖ **{len(expose.vergleichsobjekte)} Vergleichsobjekt(e)** vom Makler erfasst")

    # Vergleichsobjekte als Tabelle/Liste anzeigen
    for i, vgl in enumerate(expose.vergleichsobjekte):
        with st.container():
            col1, col2, col3, col4 = st.columns([3, 2, 2, 2])

            with col1:
                titel = vgl.get('titel', 'Vergleichsobjekt')
                url = vgl.get('url', '')
                if url:
                    st.markdown(f"**[{titel}]({url})**")
                else:
                    st.markdown(f"**{titel}**")
                if vgl.get('quelle'):
                    st.caption(f"Quelle: {vgl.get('quelle')}")

            with col2:
                preis = vgl.get('preis', 0)
                st.write(f"üí∞ **{preis:,.0f} ‚Ç¨**")

            with col3:
                flaeche = vgl.get('flaeche', 0)
                zimmer = vgl.get('zimmer', 0)
                st.write(f"üìê {flaeche:.0f} m¬≤ | üö™ {zimmer} Zi.")

            with col4:
                if preis > 0 and flaeche > 0:
                    qm = preis / flaeche
                    st.write(f"**{qm:,.0f} ‚Ç¨/m¬≤**")

            if vgl.get('notiz'):
                st.caption(f"üìù {vgl.get('notiz')}")

            st.markdown("---")

    # Marktanalyse-Zusammenfassung
    st.markdown("#### üìà Marktanalyse-Zusammenfassung")

    preise = [v.get('preis', 0) for v in expose.vergleichsobjekte if v.get('preis', 0) > 0]
    flaechen = [v.get('flaeche', 0) for v in expose.vergleichsobjekte if v.get('flaeche', 0) > 0]
    qm_preise = [v.get('preis') / v.get('flaeche') for v in expose.vergleichsobjekte
                 if v.get('preis', 0) > 0 and v.get('flaeche', 0) > 0]

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        if preise:
            st.metric("√ò Angebotspreis", f"{sum(preise)/len(preise):,.0f} ‚Ç¨")
            st.caption(f"Spanne: {min(preise):,.0f} - {max(preise):,.0f} ‚Ç¨")
        else:
            st.metric("√ò Angebotspreis", "N/A")

    with col2:
        if flaechen:
            st.metric("√ò Wohnfl√§che", f"{sum(flaechen)/len(flaechen):.0f} m¬≤")
        else:
            st.metric("√ò Wohnfl√§che", "N/A")

    with col3:
        if qm_preise:
            avg_qm = sum(qm_preise) / len(qm_preise)
            st.metric("√ò Marktpreis/m¬≤", f"{avg_qm:,.0f} ‚Ç¨")
            st.caption(f"Spanne: {min(qm_preise):,.0f} - {max(qm_preise):,.0f} ‚Ç¨")
        else:
            st.metric("√ò Marktpreis/m¬≤", "N/A")

    with col4:
        st.metric("Vergleichsobjekte", len(expose.vergleichsobjekte))

    # Vergleich mit eigenem Objekt
    if expose.kaufpreis > 0 and expose.wohnflaeche > 0 and qm_preise:
        st.markdown("---")
        st.markdown("#### üéØ Positionierung Ihrer Immobilie")

        eigener_qm_preis = expose.kaufpreis / expose.wohnflaeche
        avg_qm = sum(qm_preise) / len(qm_preise)
        differenz = eigener_qm_preis - avg_qm
        differenz_prozent = (differenz / avg_qm) * 100 if avg_qm > 0 else 0

        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric("Ihr Preis/m¬≤", f"{eigener_qm_preis:,.0f} ‚Ç¨")

        with col2:
            st.metric("Marktdurchschnitt/m¬≤", f"{avg_qm:,.0f} ‚Ç¨")

        with col3:
            if differenz > 0:
                st.metric("Positionierung", f"+{differenz:,.0f} ‚Ç¨/m¬≤", delta=f"+{differenz_prozent:.1f}%")
            else:
                st.metric("Positionierung", f"{differenz:,.0f} ‚Ç¨/m¬≤", delta=f"{differenz_prozent:.1f}%")

        # Einsch√§tzung
        st.markdown("---")
        st.markdown("#### üí° Einsch√§tzung")

        if abs(differenz_prozent) <= 5:
            st.success("""
            ‚úÖ **Marktgerechter Preis**

            Der Angebotspreis Ihrer Immobilie liegt im markt√ºblichen Bereich (¬±5% vom Durchschnitt).
            Dies erh√∂ht die Chancen auf eine erfolgreiche Vermarktung.
            """)
        elif differenz_prozent > 5:
            st.warning(f"""
            ‚ö†Ô∏è **Preis √ºber Marktdurchschnitt** (+{differenz_prozent:.1f}%)

            Der Angebotspreis liegt √ºber dem Marktdurchschnitt der Vergleichsobjekte.
            Dies kann gerechtfertigt sein durch:
            - Bessere Ausstattung
            - Bevorzugte Lage
            - Neuerer Bauzustand / Renovierung
            - Besondere Merkmale (Balkon, Garten, etc.)

            Besprechen Sie die Preisgestaltung mit Ihrem Makler.
            """)
        else:
            st.info(f"""
            üí∞ **Preis unter Marktdurchschnitt** ({differenz_prozent:.1f}%)

            Der Angebotspreis liegt unter dem Marktdurchschnitt.
            Dies kann zu schnellerem Verkauf f√ºhren, aber m√∂glicherweise besteht
            Spielraum f√ºr eine Preisanpassung nach oben.

            Besprechen Sie dies mit Ihrem Makler.
            """)

    else:
        st.info("üí° Sobald ein Kaufpreis festgelegt ist, wird hier ein Vergleich mit dem Markt angezeigt.")


def _verkaeufer_eigene_marktanalyse(projekt):
    """Verk√§ufer erfasst selbst Vergleichsobjekte zur Preisfindung"""

    user_id = st.session_state.current_user.user_id

    # ===== AUTOMATISCHE MARKTANALYSE =====
    render_automatische_marktanalyse(projekt, user_id, kann_bearbeiten=True)

    st.markdown("---")

    # ===== MANUELLE VERGLEICHSOBJEKTE =====
    st.markdown("### ‚úçÔ∏è Eigene Vergleichsobjekte erfassen")
    st.info("Sie k√∂nnen zus√§tzlich eigene Vergleichsobjekte manuell erfassen, um die automatische Analyse zu erg√§nzen.")

    # Session State f√ºr Vergleichsobjekte initialisieren
    vgl_key = f"verkaeufer_vergleichsobjekte_{projekt.projekt_id}"
    if vgl_key not in st.session_state:
        st.session_state[vgl_key] = []

    # Eigene Immobilie - Basisdaten
    st.markdown("---")
    st.markdown("### üè† Ihre Immobilie")

    col1, col2, col3 = st.columns(3)
    with col1:
        eigene_flaeche = st.number_input(
            "Wohnfl√§che (m¬≤)",
            min_value=0.0,
            value=float(projekt.wohnflaeche) if hasattr(projekt, 'wohnflaeche') and projekt.wohnflaeche else 100.0,
            step=5.0,
            key=f"vk_eigene_flaeche_{projekt.projekt_id}"
        )
    with col2:
        eigene_zimmer = st.number_input(
            "Anzahl Zimmer",
            min_value=1,
            value=4,
            key=f"vk_eigene_zimmer_{projekt.projekt_id}"
        )
    with col3:
        eigenes_baujahr = st.number_input(
            "Baujahr",
            min_value=1800,
            max_value=2025,
            value=1990,
            key=f"vk_eigenes_baujahr_{projekt.projekt_id}"
        )

    col1, col2 = st.columns(2)
    with col1:
        eigener_zustand = st.selectbox(
            "Zustand",
            ["Neuwertig", "Sehr gut", "Gut", "Renovierungsbed√ºrftig", "Sanierungsbed√ºrftig"],
            index=2,
            key=f"vk_eigener_zustand_{projekt.projekt_id}"
        )
    with col2:
        eigene_ausstattung = st.selectbox(
            "Ausstattung",
            ["Luxus", "Gehoben", "Normal", "Einfach"],
            index=2,
            key=f"vk_eigene_ausstattung_{projekt.projekt_id}"
        )

    st.markdown("---")

    # Vergleichsobjekte
    st.markdown("### üìä Vergleichsobjekte erfassen")
    st.caption("Erfassen Sie mindestens 3 √§hnliche Objekte aus Ihrer Umgebung f√ºr eine aussagekr√§ftige Analyse.")
    st.markdown("""
    **Tipp:** Suchen Sie auf Immobilienportalen wie ImmobilienScout24, Immonet oder
    Immowelt nach vergleichbaren Objekten in Ihrer N√§he.
    """)

    # Bestehende Vergleichsobjekte anzeigen
    vergleichsobjekte = st.session_state[vgl_key]

    if vergleichsobjekte:
        st.success(f"‚úÖ **{len(vergleichsobjekte)} Vergleichsobjekt(e)** erfasst")

        for i, vgl in enumerate(vergleichsobjekte):
            with st.expander(f"üèòÔ∏è {vgl.get('adresse', f'Vergleichsobjekt {i+1}')} - {vgl.get('preis', 0):,.2f} ‚Ç¨", expanded=False):
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.write(f"**Preis:** {vgl.get('preis', 0):,.2f} ‚Ç¨")
                    st.write(f"**Fl√§che:** {vgl.get('flaeche', 0):,.0f} m¬≤")
                with col2:
                    st.write(f"**Zimmer:** {vgl.get('zimmer', '-')}")
                    st.write(f"**Baujahr:** {vgl.get('baujahr', '-')}")
                with col3:
                    if vgl.get('flaeche', 0) > 0:
                        preis_qm = vgl.get('preis', 0) / vgl.get('flaeche', 1)
                        st.write(f"**Preis/m¬≤:** {preis_qm:,.2f} ‚Ç¨")
                    st.write(f"**Zustand:** {vgl.get('zustand', '-')}")

                if vgl.get('quelle'):
                    st.caption(f"Quelle: {vgl.get('quelle')}")

                if st.button("üóëÔ∏è Entfernen", key=f"vk_del_vgl_{projekt.projekt_id}_{i}"):
                    st.session_state[vgl_key].pop(i)
                    st.rerun()

    # Neues Vergleichsobjekt hinzuf√ºgen
    with st.expander("‚ûï Neues Vergleichsobjekt hinzuf√ºgen", expanded=len(vergleichsobjekte) == 0):
        st.markdown("**Daten des Vergleichsobjekts:**")

        col1, col2 = st.columns(2)
        with col1:
            neu_adresse = st.text_input(
                "Adresse / Bezeichnung",
                placeholder="z.B. Musterstra√üe 10, 50667 K√∂ln",
                key=f"vk_neu_vgl_adresse_{projekt.projekt_id}"
            )
            neu_preis = st.number_input(
                "Angebotspreis (‚Ç¨)",
                min_value=0.0,
                value=0.0,
                step=5000.0,
                key=f"vk_neu_vgl_preis_{projekt.projekt_id}"
            )
            neu_flaeche = st.number_input(
                "Wohnfl√§che (m¬≤)",
                min_value=0.0,
                value=0.0,
                step=5.0,
                key=f"vk_neu_vgl_flaeche_{projekt.projekt_id}"
            )

        with col2:
            neu_zimmer = st.number_input(
                "Anzahl Zimmer",
                min_value=1,
                value=3,
                key=f"vk_neu_vgl_zimmer_{projekt.projekt_id}"
            )
            neu_baujahr = st.number_input(
                "Baujahr",
                min_value=1800,
                max_value=2025,
                value=1990,
                key=f"vk_neu_vgl_baujahr_{projekt.projekt_id}"
            )
            neu_zustand = st.selectbox(
                "Zustand",
                ["Neuwertig", "Sehr gut", "Gut", "Renovierungsbed√ºrftig", "Sanierungsbed√ºrftig"],
                index=2,
                key=f"vk_neu_vgl_zustand_{projekt.projekt_id}"
            )

        neu_quelle = st.text_input(
            "Quelle (optional)",
            placeholder="z.B. immobilienscout24.de, immonet.de",
            key=f"vk_neu_vgl_quelle_{projekt.projekt_id}"
        )

        if st.button("‚úÖ Vergleichsobjekt hinzuf√ºgen", type="primary", key=f"vk_add_vgl_{projekt.projekt_id}"):
            if neu_preis <= 0 or neu_flaeche <= 0:
                st.error("Bitte geben Sie Preis und Fl√§che ein.")
            else:
                neues_vgl = {
                    'adresse': neu_adresse or f"Objekt {len(vergleichsobjekte) + 1}",
                    'preis': neu_preis,
                    'flaeche': neu_flaeche,
                    'zimmer': neu_zimmer,
                    'baujahr': neu_baujahr,
                    'zustand': neu_zustand,
                    'quelle': neu_quelle
                }
                st.session_state[vgl_key].append(neues_vgl)
                st.success(f"‚úÖ '{neues_vgl['adresse']}' wurde hinzugef√ºgt!")
                st.rerun()

    # Marktanalyse berechnen
    st.markdown("---")
    st.markdown("### üí∞ Preisermittlung")

    if len(vergleichsobjekte) >= 2:
        preise = [v.get('preis', 0) for v in vergleichsobjekte if v.get('preis', 0) > 0]
        flaechen = [v.get('flaeche', 0) for v in vergleichsobjekte if v.get('flaeche', 0) > 0]

        if preise and flaechen:
            # Durchschnittswerte berechnen
            avg_preis = sum(preise) / len(preise)
            min_preis = min(preise)
            max_preis = max(preise)

            preis_pro_qm = [p/f for p, f in zip(preise, flaechen) if f > 0]
            avg_preis_qm = sum(preis_pro_qm) / len(preis_pro_qm)
            min_preis_qm = min(preis_pro_qm)
            max_preis_qm = max(preis_pro_qm)

            st.markdown(f"**Analyse basierend auf {len(vergleichsobjekte)} Vergleichsobjekten:**")

            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("√ò Preis/m¬≤", f"{avg_preis_qm:,.2f} ‚Ç¨")
            with col2:
                st.metric("Min. Preis/m¬≤", f"{min_preis_qm:,.2f} ‚Ç¨")
            with col3:
                st.metric("Max. Preis/m¬≤", f"{max_preis_qm:,.2f} ‚Ç¨")

            # Preisempfehlung f√ºr eigene Immobilie berechnen
            st.markdown("---")
            st.markdown("### üéØ Preisempfehlung f√ºr Ihre Immobilie")

            # Zustandsfaktoren
            zustand_faktoren = {
                "Neuwertig": 1.15,
                "Sehr gut": 1.05,
                "Gut": 1.0,
                "Renovierungsbed√ºrftig": 0.85,
                "Sanierungsbed√ºrftig": 0.70
            }

            ausstattung_faktoren = {
                "Luxus": 1.20,
                "Gehoben": 1.10,
                "Normal": 1.0,
                "Einfach": 0.90
            }

            zustand_faktor = zustand_faktoren.get(eigener_zustand, 1.0)
            ausstattung_faktor = ausstattung_faktoren.get(eigene_ausstattung, 1.0)

            # Basispreis berechnen
            basis_preis = eigene_flaeche * avg_preis_qm
            angepasster_preis = basis_preis * zustand_faktor * ausstattung_faktor

            # Preisspanne
            min_empfehlung = eigene_flaeche * min_preis_qm * zustand_faktor * ausstattung_faktor
            max_empfehlung = eigene_flaeche * max_preis_qm * zustand_faktor * ausstattung_faktor

            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric(
                    "Untere Preisspanne",
                    f"{min_empfehlung:,.2f} ‚Ç¨",
                    delta=f"{min_empfehlung/eigene_flaeche:,.2f} ‚Ç¨/m¬≤"
                )
            with col2:
                st.metric(
                    "üéØ Empfohlener Preis",
                    f"{angepasster_preis:,.2f} ‚Ç¨",
                    delta=f"{angepasster_preis/eigene_flaeche:,.2f} ‚Ç¨/m¬≤"
                )
            with col3:
                st.metric(
                    "Obere Preisspanne",
                    f"{max_empfehlung:,.2f} ‚Ç¨",
                    delta=f"{max_empfehlung/eigene_flaeche:,.2f} ‚Ç¨/m¬≤"
                )

            # Erkl√§rung
            st.markdown("---")
            with st.expander("‚ÑπÔ∏è So wurde der Preis berechnet"):
                st.markdown(f"""
                **Berechnung:**
                - √ò Preis/m¬≤ aus Vergleichsobjekten: **{avg_preis_qm:,.2f} ‚Ç¨**
                - Ihre Wohnfl√§che: **{eigene_flaeche:,.0f} m¬≤**
                - Basispreis: {eigene_flaeche:,.0f} m¬≤ √ó {avg_preis_qm:,.2f} ‚Ç¨/m¬≤ = **{basis_preis:,.2f} ‚Ç¨**

                **Anpassungsfaktoren:**
                - Zustand "{eigener_zustand}": Faktor **{zustand_faktor:.2f}**
                - Ausstattung "{eigene_ausstattung}": Faktor **{ausstattung_faktor:.2f}**

                **Empfohlener Verkaufspreis:**
                {basis_preis:,.2f} ‚Ç¨ √ó {zustand_faktor:.2f} √ó {ausstattung_faktor:.2f} = **{angepasster_preis:,.2f} ‚Ç¨**
                """)

            # Preis √ºbernehmen
            st.markdown("---")
            col1, col2 = st.columns(2)
            with col1:
                gewaehlter_preis = st.number_input(
                    "Verkaufspreis festlegen (‚Ç¨)",
                    min_value=0.0,
                    value=round(angepasster_preis, -3),  # auf Tausender runden
                    step=5000.0,
                    key=f"vk_gewahlter_preis_{projekt.projekt_id}"
                )
            with col2:
                if st.button("üíæ Als Angebotspreis √ºbernehmen", type="primary", key=f"vk_uebernehme_preis_{projekt.projekt_id}"):
                    projekt.kaufpreis = gewaehlter_preis
                    st.session_state.projekte[projekt.projekt_id] = projekt
                    st.success(f"‚úÖ Angebotspreis {gewaehlter_preis:,.2f} ‚Ç¨ wurde gespeichert!")

    else:
        st.warning(f"""
        ‚ö†Ô∏è **Mindestens 3 Vergleichsobjekte empfohlen**

        Sie haben erst {len(vergleichsobjekte)} Vergleichsobjekt(e) erfasst.
        F√ºr eine aussagekr√§ftige Preisermittlung sollten Sie mindestens 3 √§hnliche Objekte
        aus Ihrer Umgebung hinzuf√ºgen.
        """)


def verkaeufer_eigene_kosten_view():
    """Kostenberechnung f√ºr Verk√§ufer - L√∂schungskosten f√ºr Grundbuchrechte"""
    st.subheader("üí∂ Eigene Kosten")

    st.info("""
    Als Verk√§ufer m√ºssen Sie ggf. bestehende Rechte im Grundbuch l√∂schen lassen,
    bevor die Immobilie lastenfrei √ºbertragen werden kann.
    Hier k√∂nnen Sie die voraussichtlichen Kosten f√ºr L√∂schungen berechnen.
    """)

    user_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if user_id in p.verkaeufer_ids]

    if not projekte:
        st.warning("Sie haben noch keine Projekte als Verk√§ufer.")
        return

    # Projekt ausw√§hlen wenn mehrere vorhanden
    if len(projekte) > 1:
        projekt_namen = {p.projekt_id: p.name for p in projekte}
        ausgewaehltes_id = st.selectbox(
            "Projekt ausw√§hlen",
            list(projekt_namen.keys()),
            format_func=lambda x: projekt_namen[x],
            key="vk_kosten_projekt_auswahl"
        )
        projekt = next((p for p in projekte if p.projekt_id == ausgewaehltes_id), projekte[0])
    else:
        projekt = projekte[0]

    st.markdown(f"#### üè† {projekt.name}")
    if projekt.adresse:
        st.caption(f"üìç {projekt.adresse}")
    if projekt.kaufpreis > 0:
        st.caption(f"üí∞ Kaufpreis: {projekt.kaufpreis:,.2f} ‚Ç¨")

    st.markdown("---")
    st.markdown("### üóëÔ∏è Zu l√∂schende Grundbuchrechte")

    st.markdown("""
    Geben Sie hier alle Rechte ein, die im Grundbuch gel√∂scht werden m√ºssen
    (z.B. bestehende Grundschulden, Hypotheken, Wohnrechte, etc.):
    """)

    # Anzahl zu l√∂schender Rechte
    anzahl_rechte = st.number_input(
        "Anzahl zu l√∂schender Rechte",
        min_value=0,
        max_value=10,
        value=1,
        key=f"vk_anzahl_rechte_{projekt.projekt_id}"
    )

    loeschungen = []
    gesamt_loeschungskosten = 0.0

    if anzahl_rechte > 0:
        for i in range(int(anzahl_rechte)):
            with st.expander(f"üìã Recht {i+1}", expanded=True):
                col1, col2 = st.columns(2)

                with col1:
                    recht_typ = st.selectbox(
                        "Art des Rechts",
                        ["Grundschuld", "Hypothek", "Wohnrecht", "Nie√übrauch", "Sonstiges"],
                        key=f"vk_recht_typ_{projekt.projekt_id}_{i}"
                    )

                with col2:
                    recht_betrag = st.number_input(
                        "Betrag / Wert (‚Ç¨)",
                        min_value=0.0,
                        value=0.0,
                        step=1000.0,
                        key=f"vk_recht_betrag_{projekt.projekt_id}_{i}",
                        help="Bei Grundschulden/Hypotheken: Nominalbetrag; Bei Wohnrechten: Jahreswert x Faktor"
                    )

                recht_glaeubiger = st.text_input(
                    "Gl√§ubiger / Rechtsinhaber (optional)",
                    key=f"vk_recht_glaeubiger_{projekt.projekt_id}_{i}",
                    placeholder="z.B. Sparkasse K√∂ln-Bonn"
                )

                if recht_betrag > 0:
                    # Berechne L√∂schungskosten
                    kosten = berechne_loeschungskosten(recht_betrag, 1)
                    loeschungen.append({
                        'typ': recht_typ,
                        'betrag': recht_betrag,
                        'glaeubiger': recht_glaeubiger,
                        'notar': kosten['notar_gesamt'],
                        'grundbuch': kosten['grundbuch_gesamt'],
                        'gesamt': kosten['gesamt']
                    })
                    gesamt_loeschungskosten += kosten['gesamt']

    # Ergebnisanzeige
    if loeschungen:
        st.markdown("---")
        st.markdown("### üìä Kosten√ºbersicht")

        # Tabelle der L√∂schungen
        col1, col2, col3, col4 = st.columns([2, 1, 1, 1])
        col1.markdown("**Recht**")
        col2.markdown("**Betrag**")
        col3.markdown("**Notar**")
        col4.markdown("**Grundbuch**")

        for loesch in loeschungen:
            col1, col2, col3, col4 = st.columns([2, 1, 1, 1])
            glaeubiger_info = f" ({loesch['glaeubiger']})" if loesch['glaeubiger'] else ""
            col1.write(f"{loesch['typ']}{glaeubiger_info}")
            col2.write(f"{loesch['betrag']:,.2f} ‚Ç¨")
            col3.write(f"{loesch['notar']:,.2f} ‚Ç¨")
            col4.write(f"{loesch['grundbuch']:,.2f} ‚Ç¨")

        st.markdown("---")

        # Summen
        notar_summe = sum(l['notar'] for l in loeschungen)
        grundbuch_summe = sum(l['grundbuch'] for l in loeschungen)

        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric("Notarkosten gesamt", f"{notar_summe:,.2f} ‚Ç¨")
            st.caption("0,5 Geb√ºhr f√ºr L√∂schungsbewilligung + MwSt.")

        with col2:
            st.metric("Grundbuchkosten gesamt", f"{grundbuch_summe:,.2f} ‚Ç¨")
            st.caption("0,5 Geb√ºhr f√ºr L√∂schung")

        with col3:
            st.metric("Gesamtkosten L√∂schung", f"{gesamt_loeschungskosten:,.2f} ‚Ç¨", delta_color="inverse")

        # Details anzeigen
        with st.expander("üìã Berechnungsdetails"):
            st.markdown("""
            **Kostenberechnung nach GNotKG:**

            - **Notar L√∂schungsbewilligung:** 0,5 Geb√ºhr nach Nennbetrag + MwSt. (19%)
            - **Grundbuch L√∂schung:** 0,5 Geb√ºhr nach Nennbetrag

            *Die L√∂schungsbewilligung wird vom Gl√§ubiger (z.B. Bank) erteilt,
            die L√∂schung im Grundbuch erfolgt nach Vorlage beim Grundbuchamt.*
            """)

        # Zus√§tzliche Hinweise
        st.warning("""
        **Wichtige Hinweise:**
        - Die L√∂schungsbewilligung muss vom Gl√§ubiger (z.B. Bank) erteilt werden
        - Bei Grundschulden: Abl√∂sung des Darlehens erforderlich
        - Die Kosten werden meist mit dem Kaufpreis verrechnet (Tilgung aus dem Kaufpreis)
        - Der Notar kann die L√∂schung nur beantragen, wenn alle Unterlagen vorliegen
        """)

    else:
        st.success("‚úÖ Keine Rechte zur L√∂schung angegeben - keine zus√§tzlichen Kosten als Verk√§ufer.")

    # Maklerkosten-Info wenn Makler zugeordnet
    if projekt.makler_id and 'makler_profile' in st.session_state:
        st.markdown("---")
        st.markdown("### üè¢ Maklerkosten")

        makler_profil = st.session_state.makler_profile.get(projekt.makler_id)
        if makler_profil and hasattr(makler_profil, 'provision_prozent') and makler_profil.provision_prozent:
            # Verk√§uferanteil = Gesamtprovision - K√§uferanteil (typisch 50/50)
            verkaeufer_provision = makler_profil.provision_prozent  # Annahme: gleicher Satz f√ºr Verk√§ufer
            makler_kosten = berechne_maklerkosten(projekt.kaufpreis, verkaeufer_provision, True)

            st.metric(
                "Ihre Maklerprovision",
                f"{makler_kosten['gesamt']:,.2f} ‚Ç¨",
                delta=f"{verkaeufer_provision:.2f}% inkl. MwSt."
            )
            st.caption("Die Maklerprovision wird mit dem Kaufpreis verrechnet.")


def verkaeufer_makler_finden():
    """Makler-Suche f√ºr Verk√§ufer - zeigt vom Notar empfohlene Makler"""
    st.subheader("üîç Makler finden")
    st.info("""
    Hier finden Sie vom Notar gepr√ºfte und empfohlene Makler.
    Diese Makler wurden sorgf√§ltig ausgew√§hlt und sind spezialisiert auf Ihre Region.
    """)

    # Alle freigegebenen Makler-Empfehlungen holen
    freigegebene_makler = [e for e in st.session_state.makler_empfehlungen.values()
                          if e.status == MaklerEmpfehlungStatus.FREIGEGEBEN.value]

    if not freigegebene_makler:
        st.warning("Derzeit sind keine empfohlenen Makler verf√ºgbar. Bitte wenden Sie sich an den Notar.")
        return

    # Filter-Optionen
    st.markdown("### üéØ Filter")
    col1, col2 = st.columns(2)

    with col1:
        # Regionen sammeln
        alle_regionen = set()
        for m in freigegebene_makler:
            alle_regionen.update(m.regionen)
        region_filter = st.multiselect("Region", sorted(alle_regionen), default=[])

    with col2:
        # Spezialisierungen sammeln
        alle_spezialisierungen = set()
        for m in freigegebene_makler:
            alle_spezialisierungen.update(m.spezialisierung)
        spez_filter = st.multiselect("Spezialisierung", sorted(alle_spezialisierungen), default=[])

    # Filter anwenden
    gefilterte_makler = freigegebene_makler
    if region_filter:
        gefilterte_makler = [m for m in gefilterte_makler
                           if any(r in m.regionen for r in region_filter)]
    if spez_filter:
        gefilterte_makler = [m for m in gefilterte_makler
                           if any(s in m.spezialisierung for s in spez_filter)]

    st.markdown("---")
    st.markdown(f"### üë• Empfohlene Makler ({len(gefilterte_makler)})")

    if not gefilterte_makler:
        st.info("Keine Makler entsprechen Ihren Filterkriterien.")
        return

    for makler in gefilterte_makler:
        with st.container():
            # Makler-Karte
            col1, col2 = st.columns([2, 1])

            with col1:
                st.markdown(f"## {makler.firmenname or makler.makler_name}")

                # Logo wenn vorhanden
                if makler.logo:
                    try:
                        st.image(makler.logo, width=150)
                    except:
                        pass

                # Kurzvita
                if makler.kurzvita:
                    st.markdown(f"*{makler.kurzvita}*")

                # Spezialisierung und Regionen
                if makler.spezialisierung:
                    st.markdown(f"**Spezialisierung:** {', '.join(makler.spezialisierung)}")
                if makler.regionen:
                    st.markdown(f"**T√§tig in:** {', '.join(makler.regionen)}")

            with col2:
                # Kontaktdaten
                st.markdown("**üìû Kontakt**")
                if makler.telefon:
                    st.write(f"Tel: {makler.telefon}")
                if makler.makler_email:
                    st.write(f"‚úâÔ∏è {makler.makler_email}")
                if makler.website:
                    st.markdown(f"üåê [{makler.website}](https://{makler.website})")
                if makler.adresse:
                    st.write(f"üìç {makler.adresse}")

            # Konditionen
            with st.expander("üí∞ Konditionen & Details"):
                col1, col2 = st.columns(2)
                with col1:
                    st.markdown("**Provision:**")
                    if makler.provision_verkaeufer_prozent > 0:
                        st.write(f"- Verk√§ufer: {makler.provision_verkaeufer_prozent}% inkl. MwSt.")
                    else:
                        st.write("- Verk√§ufer: Auf Anfrage")
                    if makler.provision_kaeufer_prozent > 0:
                        st.write(f"- K√§ufer: {makler.provision_kaeufer_prozent}% inkl. MwSt.")
                    else:
                        st.write("- K√§ufer: Auf Anfrage")

                with col2:
                    st.markdown("**Rechtliche Dokumente:**")
                    if makler.agb_text:
                        with st.expander("üìÑ AGB"):
                            st.text_area("", makler.agb_text, height=200, disabled=True, key=f"agb_{makler.empfehlung_id}")
                    if makler.widerrufsbelehrung_text:
                        with st.expander("üìÑ Widerrufsbelehrung"):
                            st.text_area("", makler.widerrufsbelehrung_text, height=200, disabled=True, key=f"widerruf_{makler.empfehlung_id}")

            # Kontakt-Button
            st.markdown("---")
            col1, col2, col3 = st.columns([2, 2, 1])
            with col1:
                if st.button(f"üìß Makler kontaktieren", key=f"contact_{makler.empfehlung_id}", type="primary"):
                    st.session_state[f"show_contact_form_{makler.empfehlung_id}"] = True

            # Kontaktformular anzeigen
            if st.session_state.get(f"show_contact_form_{makler.empfehlung_id}", False):
                st.markdown("#### üìù Kontaktanfrage senden")
                with st.form(f"contact_form_{makler.empfehlung_id}"):
                    user = st.session_state.current_user

                    st.write(f"**An:** {makler.firmenname or makler.makler_name}")

                    # Vorausgef√ºllte Daten
                    name = st.text_input("Ihr Name", value=user.name if user else "")
                    email = st.text_input("Ihre E-Mail", value=user.email if user else "")
                    telefon = st.text_input("Ihre Telefonnummer (optional)")

                    nachricht = st.text_area("Ihre Nachricht", value=f"""Sehr geehrte Damen und Herren,

ich interessiere mich f√ºr Ihre Maklerdienstleistungen und m√∂chte meine Immobilie verkaufen.

Bitte kontaktieren Sie mich f√ºr ein unverbindliches Beratungsgespr√§ch.

Mit freundlichen Gr√º√üen,
{user.name if user else ''}""", height=200)

                    submit = st.form_submit_button("üì§ Anfrage senden")

                    if submit:
                        # Simulierte E-Mail-Benachrichtigung
                        st.success(f"""
                        ‚úÖ Ihre Anfrage wurde gesendet!

                        **Simulierte E-Mail an:** {makler.makler_email}

                        Der Makler wird sich in K√ºrze bei Ihnen melden.
                        """)

                        # Benachrichtigung an Notar
                        create_notification(
                            "notar1",  # Demo-Notar
                            "Neue Makleranfrage",
                            f"Verk√§ufer {user.name if user else 'Unbekannt'} hat Makler {makler.firmenname or makler.makler_name} kontaktiert.",
                            NotificationType.INFO.value
                        )

                        del st.session_state[f"show_contact_form_{makler.empfehlung_id}"]
                        st.rerun()

            st.markdown("---")


def verkaeufer_timeline_view():
    """Timeline f√ºr Verk√§ufer"""
    st.subheader("üìä Projekt-Fortschritt")

    user_id = st.session_state.current_user.user_id
    search_term = st.session_state.get('verkaeufer_search', '')

    alle_projekte = [p for p in st.session_state.projekte.values() if user_id in p.verkaeufer_ids]
    projekte = filter_projekte_by_search(alle_projekte, search_term)

    display_search_results_info(len(alle_projekte), len(projekte), search_term)

    if not projekte:
        st.info("Keine Projekte gefunden." if search_term else "Noch keine Projekte vorhanden.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            render_timeline(projekt.projekt_id, UserRole.VERKAEUFER.value)

def verkaeufer_projekte_view():
    """Projekt-Ansicht f√ºr Verk√§ufer"""
    st.subheader("üìã Meine Projekte")

    user_id = st.session_state.current_user.user_id
    search_term = st.session_state.get('verkaeufer_search', '')

    alle_projekte = [p for p in st.session_state.projekte.values() if user_id in p.verkaeufer_ids]
    projekte = filter_projekte_by_search(alle_projekte, search_term)

    display_search_results_info(len(alle_projekte), len(projekte), search_term)

    if not projekte:
        st.info("Keine Projekte gefunden." if search_term else "Noch keine Projekte vorhanden.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            st.markdown(f"**Beschreibung:** {projekt.beschreibung}")
            st.markdown(f"**Objektart:** {projekt.property_type}")
            if projekt.adresse:
                st.markdown(f"**Adresse:** {projekt.adresse}")
            if projekt.kaufpreis > 0:
                st.markdown(f"**Kaufpreis:** {format_euro(projekt.kaufpreis)} ‚Ç¨")
            st.markdown(f"**Status:** {projekt.status}")

            # === PREISVERHANDLUNG ===
            if kann_preisverhandlung_fuehren(projekt, user_id, "Verk√§ufer"):
                st.markdown("---")
                st.markdown("### üí∞ Preisverhandlung")

                # Zeige aktuellen Verhandlungsstand
                angebote = get_preisangebote_fuer_projekt(projekt.projekt_id)
                letztes_offenes = get_letztes_offenes_angebot(projekt.projekt_id)

                if letztes_offenes:
                    von_user = st.session_state.users.get(letztes_offenes.von_user_id)
                    von_name = von_user.name if von_user else "Unbekannt"

                    if letztes_offenes.von_user_id == user_id:
                        # Eigenes offenes Angebot
                        st.info(f"‚è≥ Ihr Angebot √ºber **{format_euro(letztes_offenes.betrag)} ‚Ç¨** wartet auf Antwort des K√§ufers.")
                        if letztes_offenes.nachricht:
                            st.caption(f"Ihre Nachricht: {letztes_offenes.nachricht}")

                        if st.button("üîô Angebot zur√ºckziehen", key=f"vk_zurueck_{letztes_offenes.angebot_id}"):
                            letztes_offenes.status = PreisangebotStatus.ZURUECKGEZOGEN.value
                            st.success("Angebot zur√ºckgezogen.")
                            st.rerun()
                    else:
                        # Offenes Angebot vom K√§ufer
                        st.success(f"üì¨ **{von_name}** bietet **{format_euro(letztes_offenes.betrag)} ‚Ç¨**")
                        if letztes_offenes.nachricht:
                            st.caption(f"Nachricht: {letztes_offenes.nachricht}")

                        col1, col2, col3 = st.columns(3)
                        with col1:
                            if st.button("‚úÖ Annehmen", key=f"vk_annehmen_{letztes_offenes.angebot_id}"):
                                respond_to_preisangebot(letztes_offenes.angebot_id, PreisangebotStatus.ANGENOMMEN.value)
                                st.success("Angebot angenommen!")
                                st.rerun()
                        with col2:
                            if st.button("‚ùå Ablehnen", key=f"vk_ablehnen_{letztes_offenes.angebot_id}"):
                                respond_to_preisangebot(letztes_offenes.angebot_id, PreisangebotStatus.ABGELEHNT.value)
                                st.warning("Angebot abgelehnt.")
                                st.rerun()
                        with col3:
                            if st.button("üí¨ Gegenangebot", key=f"vk_gegen_{letztes_offenes.angebot_id}"):
                                st.session_state[f"vk_zeige_gegenangebot_{projekt.projekt_id}"] = True

                        if st.session_state.get(f"vk_zeige_gegenangebot_{projekt.projekt_id}"):
                            gegen_betrag = st.number_input(
                                "Ihr Gegenangebot (‚Ç¨)",
                                min_value=0.0,
                                value=float(letztes_offenes.betrag),
                                step=1000.0,
                                key=f"vk_gegen_betrag_{projekt.projekt_id}"
                            )
                            gegen_nachricht = st.text_input("Nachricht (optional)", key=f"vk_gegen_msg_{projekt.projekt_id}")
                            if st.button("üì§ Gegenangebot senden", key=f"vk_sende_gegen_{projekt.projekt_id}"):
                                respond_to_preisangebot(
                                    letztes_offenes.angebot_id,
                                    PreisangebotStatus.GEGENANGEBOT.value,
                                    gegen_nachricht,
                                    gegen_betrag
                                )
                                st.session_state[f"vk_zeige_gegenangebot_{projekt.projekt_id}"] = False
                                st.success("Gegenangebot gesendet!")
                                st.rerun()
                else:
                    # Kein offenes Angebot - Verk√§ufer kann auch initiieren
                    st.markdown("**Neues Preisangebot an K√§ufer senden:**")
                    angebot_betrag = st.number_input(
                        "Ihr Preisvorschlag (‚Ç¨)",
                        min_value=0.0,
                        value=float(projekt.kaufpreis) if projekt.kaufpreis > 0 else 0.0,
                        step=1000.0,
                        key=f"vk_neues_angebot_{projekt.projekt_id}"
                    )
                    angebot_nachricht = st.text_input("Nachricht an K√§ufer (optional)", key=f"vk_msg_{projekt.projekt_id}")

                    if st.button("üì§ Preisvorschlag senden", key=f"vk_sende_{projekt.projekt_id}"):
                        create_preisangebot(
                            projekt_id=projekt.projekt_id,
                            von_user_id=user_id,
                            von_rolle="Verk√§ufer",
                            betrag=angebot_betrag,
                            nachricht=angebot_nachricht
                        )
                        st.success(f"Preisvorschlag √ºber {format_euro(angebot_betrag)} ‚Ç¨ gesendet!")
                        st.rerun()

                # Zeige Verhandlungsverlauf
                if angebote:
                    with st.expander("üìú Verhandlungsverlauf", expanded=False):
                        for angebot in angebote:
                            von_user = st.session_state.users.get(angebot.von_user_id)
                            von_name = von_user.name if von_user else "Unbekannt"
                            status_icon = {
                                PreisangebotStatus.OFFEN.value: "‚è≥",
                                PreisangebotStatus.ANGENOMMEN.value: "‚úÖ",
                                PreisangebotStatus.ABGELEHNT.value: "‚ùå",
                                PreisangebotStatus.GEGENANGEBOT.value: "üí¨",
                                PreisangebotStatus.ZURUECKGEZOGEN.value: "üîô"
                            }.get(angebot.status, "‚ùì")

                            st.markdown(f"""
                            {status_icon} **{format_euro(angebot.betrag)} ‚Ç¨** von {von_name} ({angebot.von_rolle})
                            - Status: {angebot.status}
                            - Datum: {angebot.erstellt_am.strftime('%d.%m.%Y %H:%M')}
                            {"- Nachricht: " + angebot.nachricht if angebot.nachricht else ""}
                            """)
            elif projekt.makler_id:
                # Makler vorhanden aber Verhandlung nicht erlaubt
                st.markdown("---")
                st.info("üí° Preisverhandlungen sind f√ºr dieses Projekt nicht aktiviert. Bei Interesse wenden Sie sich an den Makler.")

            # Anzeige hochgeladener Dokumente f√ºr dieses Projekt
            projekt_docs = [d for d in st.session_state.verkaeufer_dokumente.values()
                           if d.verkaeufer_id == user_id and d.projekt_id == projekt.projekt_id]

            st.markdown("---")
            st.markdown("**üìÇ Meine hochgeladenen Dokumente:**")
            if projekt_docs:
                st.write(f"‚úÖ {len(projekt_docs)} Dokument(e) hochgeladen")
            else:
                st.info("Noch keine Dokumente hochgeladen. Gehen Sie zum Tab 'Dokumente hochladen'.")

def verkaeufer_dokumente_view():
    """Dokumenten-Upload f√ºr Verk√§ufer"""
    st.subheader("üìÑ Dokumente hochladen")

    st.info("""
    Als Verk√§ufer stellen Sie die meisten Dokumente f√ºr den Verkaufsprozess bereit.
    Diese Dokumente werden von Makler, Notar und Finanzierer ben√∂tigt.
    """)

    user_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if user_id in p.verkaeufer_ids]

    if not projekte:
        st.warning("Sie sind keinem Projekt zugeordnet.")
        return

    # Projekt ausw√§hlen
    projekt_options = {f"{p.name} ({p.property_type})": p.projekt_id for p in projekte}
    selected_projekt_label = st.selectbox("F√ºr welches Projekt m√∂chten Sie Dokumente hochladen?", list(projekt_options.keys()))
    selected_projekt_id = projekt_options[selected_projekt_label]
    selected_projekt = st.session_state.projekte[selected_projekt_id]

    st.markdown("---")

    # Bereits hochgeladene Dokumente anzeigen
    projekt_docs = [d for d in st.session_state.verkaeufer_dokumente.values()
                   if d.verkaeufer_id == user_id and d.projekt_id == selected_projekt_id]

    if projekt_docs:
        st.markdown("### üìÇ Bereits hochgeladene Dokumente")

        # Nach Typ gruppieren
        docs_by_type = {}
        for doc in projekt_docs:
            if doc.dokument_typ not in docs_by_type:
                docs_by_type[doc.dokument_typ] = []
            docs_by_type[doc.dokument_typ].append(doc)

        for doc_typ, docs in docs_by_type.items():
            with st.expander(f"üìã {doc_typ} ({len(docs)} Dokument(e))", expanded=False):
                for doc in docs:
                    col1, col2, col3 = st.columns([3, 2, 1])

                    with col1:
                        st.write(f"üìÑ **{doc.dateiname}**")
                        if doc.beschreibung:
                            st.caption(doc.beschreibung)

                    with col2:
                        st.caption(f"Hochgeladen: {doc.upload_datum.strftime('%d.%m.%Y')}")
                        st.caption(f"Status: {doc.status}")

                        # Freigaben anzeigen
                        freigaben = []
                        if doc.freigegeben_fuer_makler:
                            freigaben.append("Makler")
                        if doc.freigegeben_fuer_notar:
                            freigaben.append("Notar")
                        if doc.freigegeben_fuer_finanzierer:
                            freigaben.append("Finanzierer")
                        if doc.freigegeben_fuer_kaeufer:
                            freigaben.append("K√§ufer")

                        if freigaben:
                            st.caption(f"‚úÖ Freigegeben f√ºr: {', '.join(freigaben)}")
                        else:
                            st.caption("‚ö†Ô∏è Noch nicht freigegeben")

                    with col3:
                        if st.button("üóëÔ∏è", key=f"delete_doc_{doc.dokument_id}"):
                            del st.session_state.verkaeufer_dokumente[doc.dokument_id]
                            st.success("Dokument gel√∂scht!")
                            st.rerun()

                    st.markdown("---")

        st.markdown("---")

    # Neues Dokument hochladen
    st.markdown("### ‚ûï Neues Dokument hochladen")

    with st.form("dokument_upload"):
        # Dokumenttyp ausw√§hlen (abh√§ngig von Objektart)
        st.markdown("**Dokumenttyp ausw√§hlen:**")

        # Empfohlene Dokumente basierend auf Objektart
        empfohlene_docs = []
        if selected_projekt.property_type == PropertyType.WOHNUNG.value:
            empfohlene_docs = [
                Verk√§uferDokumentTyp.GRUNDBUCHAUSZUG.value,
                Verk√§uferDokumentTyp.TEILUNGSERKLARUNG.value,
                Verk√§uferDokumentTyp.WEG_PROTOKOLLE.value,
                Verk√§uferDokumentTyp.ENERGIEAUSWEIS.value,
                Verk√§uferDokumentTyp.WIRTSCHAFTSPLAN.value,
                Verk√§uferDokumentTyp.HAUSVERWALTUNG_BESCHEINIGUNG.value,
            ]
        elif selected_projekt.property_type == PropertyType.HAUS.value:
            empfohlene_docs = [
                Verk√§uferDokumentTyp.GRUNDBUCHAUSZUG.value,
                Verk√§uferDokumentTyp.ENERGIEAUSWEIS.value,
                Verk√§uferDokumentTyp.GRUNDRISS.value,
                Verk√§uferDokumentTyp.LAGEPLAN.value,
                Verk√§uferDokumentTyp.BAUGENEHMIGUNG.value,
                Verk√§uferDokumentTyp.WOHNFLACHENBERECHNUNG.value,
            ]
        elif selected_projekt.property_type == PropertyType.LAND.value:
            empfohlene_docs = [
                Verk√§uferDokumentTyp.GRUNDBUCHAUSZUG.value,
                Verk√§uferDokumentTyp.FLURKARTE.value,
                Verk√§uferDokumentTyp.LAGEPLAN.value,
                Verk√§uferDokumentTyp.BAUGENEHMIGUNG.value,
            ]
        else:  # MFH
            empfohlene_docs = [
                Verk√§uferDokumentTyp.GRUNDBUCHAUSZUG.value,
                Verk√§uferDokumentTyp.ENERGIEAUSWEIS.value,
                Verk√§uferDokumentTyp.MIETVERTR√ÑGE.value,
                Verk√§uferDokumentTyp.NEBENKOSTENABRECHNUNG.value,
                Verk√§uferDokumentTyp.WIRTSCHAFTSPLAN.value,
            ]

        # Alle Dokumenttypen als Optionen
        alle_doc_typen = [t.value for t in Verk√§uferDokumentTyp]

        # Empfohlene Dokumente hervorheben
        st.info(f"üìå Empfohlene Dokumente f√ºr {selected_projekt.property_type}: " + ", ".join(empfohlene_docs))

        dokument_typ = st.selectbox("Dokumenttyp*", options=alle_doc_typen)
        beschreibung = st.text_area("Beschreibung (optional)", placeholder="z.B. Aktuell vom 01.12.2024")
        gueltig_bis = st.date_input("G√ºltig bis (optional)", value=None)

        st.markdown("**Freigaben:**")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            freigabe_makler = st.checkbox("F√ºr Makler", value=True)
        with col2:
            freigabe_notar = st.checkbox("F√ºr Notar", value=True)
        with col3:
            freigabe_finanzierer = st.checkbox("F√ºr Finanzierer", value=False)
        with col4:
            freigabe_kaeufer = st.checkbox("F√ºr K√§ufer", value=False)

        datei = st.file_uploader("Datei hochladen*", type=["pdf", "jpg", "jpeg", "png"])

        submit = st.form_submit_button("üì§ Dokument hochladen", type="primary")

        if submit and datei and dokument_typ:
            # Dokument speichern
            dokument_id = f"vdoc_{len(st.session_state.verkaeufer_dokumente)}"
            datei_bytes = datei.read()

            neues_dokument = Verk√§uferDokument(
                dokument_id=dokument_id,
                verkaeufer_id=user_id,
                projekt_id=selected_projekt_id,
                dokument_typ=dokument_typ,
                dateiname=datei.name,
                dateigr√∂√üe=len(datei_bytes),
                pdf_data=datei_bytes,
                beschreibung=beschreibung,
                gueltig_bis=gueltig_bis,
                freigegeben_fuer_makler=freigabe_makler,
                freigegeben_fuer_notar=freigabe_notar,
                freigegeben_fuer_finanzierer=freigabe_finanzierer,
                freigegeben_fuer_kaeufer=freigabe_kaeufer
            )

            st.session_state.verkaeufer_dokumente[dokument_id] = neues_dokument

            # Benachrichtigungen an alle freigegebenen Parteien
            if freigabe_makler and selected_projekt.makler_id:
                create_notification(
                    selected_projekt.makler_id,
                    "Neues Verk√§ufer-Dokument",
                    f"{st.session_state.current_user.name} hat '{dokument_typ}' hochgeladen.",
                    NotificationType.INFO.value
                )
            if freigabe_notar and selected_projekt.notar_id:
                create_notification(
                    selected_projekt.notar_id,
                    "Neues Verk√§ufer-Dokument",
                    f"{st.session_state.current_user.name} hat '{dokument_typ}' hochgeladen.",
                    NotificationType.INFO.value
                )

            st.success(f"‚úÖ Dokument '{datei.name}' erfolgreich hochgeladen!")
            st.rerun()
        elif submit:
            st.error("Bitte f√ºllen Sie alle Pflichtfelder aus und laden Sie eine Datei hoch!")

def verkaeufer_nachrichten():
    """Nachrichten f√ºr Verk√§ufer"""
    st.subheader("üí¨ Nachrichten")

    user_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if user_id in p.verkaeufer_ids]

    if not projekte:
        st.info("Noch keine Projekte vorhanden.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            projekt_comments = [c for c in st.session_state.comments.values()
                              if c.projekt_id == projekt.projekt_id and "Verk√§ufer" in c.sichtbar_fuer]
            projekt_comments.sort(key=lambda c: c.created_at, reverse=True)

            if projekt_comments:
                for comment in projekt_comments:
                    user = st.session_state.users.get(comment.user_id)
                    user_name = user.name if user else "Unbekannt"

                    st.markdown(f"""
                    <div style='background:#f0f0f0; padding:10px; border-radius:5px; margin:10px 0;'>
                        <strong>{user_name}</strong> <small>({comment.created_at.strftime('%d.%m.%Y %H:%M')})</small><br>
                        {comment.nachricht}
                    </div>
                    """, unsafe_allow_html=True)
            else:
                st.info("Noch keine Nachrichten.")

# ============================================================================
# FINANZIERER-BEREICH
# ============================================================================

def finanzierer_dashboard():
    """Dashboard f√ºr Finanzierer"""
    st.title("üíº Finanzierer-Dashboard")

    # Aktentasche in der Sidebar
    user_id = st.session_state.current_user.user_id
    render_aktentasche_sidebar(user_id)

    # Benachrichtigungs-Badge in der Sidebar
    render_benachrichtigungs_badge(user_id)

    # Teilen-Dialog anzeigen falls aktiv
    render_aktentasche_teilen_dialog(user_id)

    # Download-Dialog anzeigen falls aktiv
    render_aktentasche_download(user_id)

    # Suchleiste
    search_term = render_dashboard_search("finanzierer")
    if search_term:
        st.session_state['finanzierer_search'] = search_term
    else:
        st.session_state['finanzierer_search'] = ''

    tabs = st.tabs([
        "üìä Timeline",
        "üìã Wirtschaftsdaten K√§ufer",
        "üí∞ Finanzierungsangebote erstellen",
        "üìú Meine Angebote",
        "üìÖ Termine"
    ])

    with tabs[0]:
        finanzierer_timeline_view()

    with tabs[1]:
        finanzierer_wirtschaftsdaten_view()

    with tabs[2]:
        finanzierer_angebote_erstellen()

    with tabs[3]:
        finanzierer_angebote_liste()

    with tabs[4]:
        # Termin-√úbersicht f√ºr Finanzierer mit Kalender
        st.subheader("üìÖ Meine Termine")
        user_id = st.session_state.current_user.user_id

        # Kalender-Ansicht
        termin_ansicht = st.tabs(["üìÖ Kalender", "üìã Nach Projekt"])

        with termin_ansicht[0]:
            render_termin_kalender(user_id, UserRole.FINANZIERER.value)

        with termin_ansicht[1]:
            projekte = [p for p in st.session_state.projekte.values() if user_id in p.finanzierer_ids]
            if projekte:
                for projekt in projekte:
                    with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
                        render_termin_verwaltung(projekt, UserRole.FINANZIERER.value)
            else:
                st.info("Noch keine Projekte vorhanden.")

def finanzierer_timeline_view():
    """Timeline f√ºr Finanzierer"""
    st.subheader("üìä Projekt-Fortschritt")

    finanzierer_id = st.session_state.current_user.user_id
    search_term = st.session_state.get('finanzierer_search', '')

    alle_projekte = [p for p in st.session_state.projekte.values() if finanzierer_id in p.finanzierer_ids]
    projekte = filter_projekte_by_search(alle_projekte, search_term)

    display_search_results_info(len(alle_projekte), len(projekte), search_term)

    if not projekte:
        st.info("Keine Projekte gefunden." if search_term else "Noch keine Projekte zugewiesen.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            render_timeline(projekt.projekt_id, UserRole.FINANZIERER.value)

def finanzierer_wirtschaftsdaten_view():
    """Einsicht in Wirtschaftsdaten der K√§ufer"""
    st.subheader("üìä Wirtschaftsdaten K√§ufer")

    finanzierer_id = st.session_state.current_user.user_id
    relevante_projekte = [p for p in st.session_state.projekte.values()
                         if finanzierer_id in p.finanzierer_ids]

    if not relevante_projekte:
        st.info("Noch keine Projekte zugewiesen.")
        return

    for projekt in relevante_projekte:
        st.markdown(f"### üèòÔ∏è {projekt.name}")

        kaeufer_docs = {}
        for doc in st.session_state.wirtschaftsdaten.values():
            if doc.kaeufer_id in projekt.kaeufer_ids:
                if doc.kaeufer_id not in kaeufer_docs:
                    kaeufer_docs[doc.kaeufer_id] = []
                kaeufer_docs[doc.kaeufer_id].append(doc)

        if not kaeufer_docs:
            st.info("Noch keine Wirtschaftsdaten von K√§ufern hochgeladen.")
            continue

        for kaeufer_id, docs in kaeufer_docs.items():
            kaeufer = st.session_state.users.get(kaeufer_id)
            kaeufer_name = kaeufer.name if kaeufer else "Unbekannt"

            with st.expander(f"üë§ {kaeufer_name} ({len(docs)} Dokument(e))", expanded=True):
                kategorien = {}
                for doc in docs:
                    if doc.kategorie not in kategorien:
                        kategorien[doc.kategorie] = []
                    kategorien[doc.kategorie].append(doc)

                for kategorie, kategorie_docs in kategorien.items():
                    st.markdown(f"**üìÅ {kategorie}** ({len(kategorie_docs)} Dokument(e))")

                    for doc in kategorie_docs:
                        col1, col2, col3 = st.columns([3, 2, 1])
                        with col1:
                            st.write(f"üìÑ {doc.filename}")
                        with col2:
                            st.caption(f"Hochgeladen: {doc.upload_date.strftime('%d.%m.%Y %H:%M')}")
                            if st.button("üëÅÔ∏è OCR", key=f"fin_ocr_{doc.doc_id}"):
                                st.session_state[f"show_fin_ocr_{doc.doc_id}"] = not st.session_state.get(f"show_fin_ocr_{doc.doc_id}", False)
                        with col3:
                            st.download_button(
                                "üì•",
                                doc.pdf_data,
                                file_name=doc.filename,
                                key=f"fin_dl_{doc.doc_id}"
                            )

                        if st.session_state.get(f"show_fin_ocr_{doc.doc_id}", False):
                            st.text_area("OCR-Text", doc.ocr_text, height=100, disabled=True, key=f"fin_ocr_text_{doc.doc_id}")

                        st.markdown("---")

        st.markdown("---")

def finanzierer_angebote_erstellen():
    """Formular zum Erstellen von Finanzierungsangeboten - Erweitert"""
    st.subheader("üí∞ Neues Finanzierungsangebot erstellen")

    finanzierer_id = st.session_state.current_user.user_id
    relevante_projekte = [p for p in st.session_state.projekte.values()
                         if finanzierer_id in p.finanzierer_ids]

    if not relevante_projekte:
        st.warning("Sie sind noch keinem Projekt zugeordnet.")
        return

    with st.form("neues_angebot"):
        projekt_options = {p.name: p.projekt_id for p in relevante_projekte}
        selected_projekt_name = st.selectbox("Projekt", list(projekt_options.keys()))
        projekt_id = projekt_options[selected_projekt_name]

        # Produktname
        produktname = st.text_input(
            "Produktname (optional)",
            placeholder="z.B. Baufinanzierung Flex, Immobilienkredit Premium",
            help="Ein eindeutiger Name f√ºr dieses Angebot"
        )

        st.markdown("### üìã Konditionen")

        col1, col2, col3 = st.columns(3)
        with col1:
            darlehensbetrag = st.number_input("Darlehensbetrag (‚Ç¨)", min_value=0.0, value=300000.0, step=1000.0)
            zinssatz = st.number_input("Sollzinssatz (%)", min_value=0.0, max_value=20.0, value=3.5, step=0.1)
            tilgungssatz = st.number_input("Tilgungssatz (%)", min_value=0.0, max_value=10.0, value=2.0, step=0.1)

        with col2:
            sollzinsbindung = st.number_input("Sollzinsbindung (Jahre)", min_value=1, max_value=40, value=10)
            gesamtlaufzeit = st.number_input("Gesamtlaufzeit (Jahre)", min_value=1, max_value=40, value=30)
            effektivzins = st.number_input("Effektivzins (%)", min_value=0.0, max_value=20.0, value=3.65, step=0.01)

        with col3:
            monatliche_rate = st.number_input("Monatliche Rate (‚Ç¨)", min_value=0.0, value=1375.0, step=10.0)
            sondertilgung_prozent = st.number_input("Sondertilgung (% p.a.)", min_value=0.0, max_value=10.0, value=5.0, step=0.5)
            bereitstellungszinsen_frei = st.number_input("Bereitst.-frei (Monate)", min_value=0, max_value=24, value=6)

        st.markdown("### ‚è∞ G√ºltigkeit & Optionen")

        col4, col5 = st.columns(2)
        with col4:
            befristung_aktiv = st.checkbox("Angebot befristen", value=False)
            if befristung_aktiv:
                gueltig_bis_date = st.date_input(
                    "G√ºltig bis",
                    value=date.today() + timedelta(days=14),
                    min_value=date.today()
                )
                gueltig_bis = datetime.combine(gueltig_bis_date, datetime.max.time())
            else:
                gueltig_bis = None

        with col5:
            auto_delete = st.checkbox(
                "Automatisch l√∂schen nach Ablauf",
                value=False,
                disabled=not befristung_aktiv,
                help="Angebot wird nach Ablauf automatisch entfernt"
            )

        besondere_bedingungen = st.text_area(
            "Besondere Bedingungen",
            placeholder="z.B. Bereitstellungszinsen 0,25% p.m. nach bereitstellungsfreier Zeit, Mindest-Eigenkapital 10%",
            height=100
        )

        pdf_upload = st.file_uploader("Angebot als PDF anh√§ngen (optional)", type=['pdf'])

        col1, col2 = st.columns(2)
        with col1:
            als_entwurf = st.form_submit_button("üíæ Als Entwurf speichern")
        with col2:
            an_kaeufer = st.form_submit_button("üìß An K√§ufer senden", type="primary")

        if als_entwurf or an_kaeufer:
            # Angebotsnummer ermitteln (f√ºr mehrere Angebote pro Projekt)
            bestehende_angebote = [o for o in st.session_state.financing_offers.values()
                                  if o.projekt_id == projekt_id and o.finanzierer_id == finanzierer_id]
            angebot_nummer = len(bestehende_angebote) + 1

            offer_id = f"offer_{len(st.session_state.financing_offers)}_{datetime.now().strftime('%Y%m%d%H%M%S')}"
            status = FinanzierungsStatus.ENTWURF.value if als_entwurf else FinanzierungsStatus.GESENDET.value

            offer = FinancingOffer(
                offer_id=offer_id,
                finanzierer_id=finanzierer_id,
                projekt_id=projekt_id,
                darlehensbetrag=darlehensbetrag,
                zinssatz=zinssatz,
                sollzinsbindung=sollzinsbindung,
                tilgungssatz=tilgungssatz,
                gesamtlaufzeit=gesamtlaufzeit,
                monatliche_rate=monatliche_rate,
                besondere_bedingungen=besondere_bedingungen,
                status=status,
                pdf_data=pdf_upload.read() if pdf_upload else None,
                gueltig_bis=gueltig_bis,
                auto_delete=auto_delete,
                sondertilgung_prozent=sondertilgung_prozent,
                bereitstellungszinsen_frei_monate=bereitstellungszinsen_frei,
                effektivzins=effektivzins,
                produktname=produktname,
                angebot_nummer=angebot_nummer
            )

            st.session_state.financing_offers[offer_id] = offer

            if an_kaeufer:
                # Timeline aktualisieren
                projekt = st.session_state.projekte.get(projekt_id)
                if projekt:
                    for event_id in projekt.timeline_events:
                        event = st.session_state.timeline_events.get(event_id)
                        if event and event.titel == "Finanzierungsanfrage" and not event.completed:
                            event.completed = True
                            event.completed_at = datetime.now()
                    update_projekt_status(projekt_id)

                    # Benachrichtigungen
                    for kaeufer_id in projekt.kaeufer_ids:
                        create_notification(kaeufer_id, "Neues Finanzierungsangebot", f"Sie haben ein neues Finanzierungsangebot f√ºr {projekt.name}", NotificationType.INFO.value)

            if als_entwurf:
                st.success("‚úÖ Angebot als Entwurf gespeichert!")
            else:
                st.success(f"‚úÖ Angebot #{angebot_nummer} wurde an K√§ufer gesendet!")

            st.rerun()

def finanzierer_angebote_liste():
    """Liste aller Angebote des Finanzierers - Erweitert mit Bearbeiten/L√∂schen"""
    st.subheader("üìú Meine Finanzierungsangebote")

    finanzierer_id = st.session_state.current_user.user_id
    meine_angebote = [o for o in st.session_state.financing_offers.values()
                     if o.finanzierer_id == finanzierer_id]

    if not meine_angebote:
        st.info("Noch keine Angebote erstellt.")
        return

    # Pr√ºfe auf abgelaufene Angebote und l√∂sche auto-delete Angebote
    angebote_zu_loeschen = []
    for offer in meine_angebote:
        if offer.gueltig_bis and datetime.now() > offer.gueltig_bis:
            if offer.auto_delete and offer.status != FinanzierungsStatus.ANGENOMMEN.value:
                angebote_zu_loeschen.append(offer.offer_id)
            elif offer.status == FinanzierungsStatus.GESENDET.value:
                offer.status = FinanzierungsStatus.ABGELAUFEN.value
                st.session_state.financing_offers[offer.offer_id] = offer

    for offer_id in angebote_zu_loeschen:
        del st.session_state.financing_offers[offer_id]
        meine_angebote = [o for o in meine_angebote if o.offer_id != offer_id]

    if not meine_angebote:
        st.info("Noch keine Angebote erstellt.")
        return

    # Tabs f√ºr Status
    status_tabs = st.tabs(["üìß Gesendet", "üíæ Entw√ºrfe", "‚úÖ Angenommen", "üóëÔ∏è Zur√ºckgezogen/Abgelaufen"])

    # Gesendet
    with status_tabs[0]:
        gesendet = [o for o in meine_angebote if o.status == FinanzierungsStatus.GESENDET.value]
        if not gesendet:
            st.info("Keine gesendeten Angebote.")
        else:
            for offer in gesendet:
                render_finanzierer_angebot_card(offer, editable=True)

    # Entw√ºrfe
    with status_tabs[1]:
        entwuerfe = [o for o in meine_angebote if o.status == FinanzierungsStatus.ENTWURF.value]
        if not entwuerfe:
            st.info("Keine Entw√ºrfe.")
        else:
            for offer in entwuerfe:
                render_finanzierer_angebot_card(offer, editable=True, is_draft=True)

    # Angenommen
    with status_tabs[2]:
        angenommen = [o for o in meine_angebote if o.status == FinanzierungsStatus.ANGENOMMEN.value]
        if not angenommen:
            st.info("Noch keine angenommenen Angebote.")
        else:
            for offer in angenommen:
                render_finanzierer_angebot_card(offer, editable=False)

    # Zur√ºckgezogen/Abgelaufen
    with status_tabs[3]:
        inaktiv = [o for o in meine_angebote if o.status in [
            FinanzierungsStatus.ZURUECKGEZOGEN.value,
            FinanzierungsStatus.ABGELAUFEN.value
        ]]
        if not inaktiv:
            st.info("Keine zur√ºckgezogenen oder abgelaufenen Angebote.")
        else:
            for offer in inaktiv:
                render_finanzierer_angebot_card(offer, editable=False, show_reactivate=True)


def render_finanzierer_angebot_card(offer, editable=True, is_draft=False, show_reactivate=False):
    """Rendert eine Angebotskarte f√ºr Finanzierer mit Aktionen"""
    projekt = st.session_state.projekte.get(offer.projekt_id)
    projekt_name = projekt.name if projekt else "Unbekannt"

    # Titel mit Produktname
    titel = offer.produktname if offer.produktname else f"Angebot #{offer.angebot_nummer}"

    # Status-Icon
    status_icons = {
        FinanzierungsStatus.GESENDET.value: "üìß",
        FinanzierungsStatus.ENTWURF.value: "üíæ",
        FinanzierungsStatus.ANGENOMMEN.value: "‚úÖ",
        FinanzierungsStatus.ZURUECKGEZOGEN.value: "üóëÔ∏è",
        FinanzierungsStatus.ABGELAUFEN.value: "‚è∞"
    }
    icon = status_icons.get(offer.status, "üí∞")

    # G√ºltigkeit pr√ºfen
    ablauf_info = ""
    if offer.gueltig_bis and offer.status == FinanzierungsStatus.GESENDET.value:
        verbleibend = (offer.gueltig_bis - datetime.now()).days
        if verbleibend <= 0:
            ablauf_info = " ‚õî ABGELAUFEN"
        elif verbleibend <= 3:
            ablauf_info = f" ‚ö†Ô∏è {verbleibend}T"

    with st.expander(f"{icon} {projekt_name} - {titel} | {format_euro(offer.darlehensbetrag, 0)} ‚Ç¨ | {offer.zinssatz}%{ablauf_info}"):
        # Konditionen
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Darlehensbetrag", f"{format_euro(offer.darlehensbetrag)} ‚Ç¨")
            st.metric("Zinssatz (nom.)", f"{offer.zinssatz:.2f} %")
            if offer.effektivzins > 0:
                st.metric("Effektivzins", f"{offer.effektivzins:.2f} %")
        with col2:
            st.metric("Monatliche Rate", f"{format_euro(offer.monatliche_rate)} ‚Ç¨")
            st.metric("Tilgungssatz", f"{offer.tilgungssatz:.2f} %")
            st.metric("Laufzeit", f"{offer.gesamtlaufzeit} Jahre")
        with col3:
            st.write(f"**Status:** {offer.status}")
            st.write(f"**Erstellt:** {offer.created_at.strftime('%d.%m.%Y')}")
            if offer.gueltig_bis:
                st.write(f"**G√ºltig bis:** {offer.gueltig_bis.strftime('%d.%m.%Y')}")
            if offer.sondertilgung_prozent > 0:
                st.write(f"**Sondertilgung:** {offer.sondertilgung_prozent}% p.a.")
            if offer.accepted_at:
                st.success(f"Angenommen: {offer.accepted_at.strftime('%d.%m.%Y')}")

        if offer.besondere_bedingungen:
            st.info(f"**Bedingungen:** {offer.besondere_bedingungen}")

        # Aktionen
        st.markdown("---")

        if is_draft:
            col_a, col_b, col_c = st.columns(3)
            with col_a:
                if st.button("üìß An K√§ufer senden", key=f"send_{offer.offer_id}", type="primary"):
                    offer.status = FinanzierungsStatus.GESENDET.value
                    st.session_state.financing_offers[offer.offer_id] = offer

                    # Benachrichtigungen
                    if projekt:
                        for kaeufer_id in projekt.kaeufer_ids:
                            create_notification(kaeufer_id, "Neues Finanzierungsangebot",
                                              f"Sie haben ein neues Finanzierungsangebot f√ºr {projekt.name}",
                                              NotificationType.INFO.value)
                    st.success("‚úÖ Angebot wurde gesendet!")
                    st.rerun()

            with col_c:
                if st.button("üóëÔ∏è L√∂schen", key=f"del_{offer.offer_id}"):
                    del st.session_state.financing_offers[offer.offer_id]
                    st.success("Angebot gel√∂scht.")
                    st.rerun()

        elif editable and offer.status == FinanzierungsStatus.GESENDET.value:
            col_a, col_b = st.columns(2)
            with col_a:
                if st.button("‚Ü©Ô∏è Zur√ºckziehen", key=f"revoke_{offer.offer_id}"):
                    offer.status = FinanzierungsStatus.ZURUECKGEZOGEN.value
                    st.session_state.financing_offers[offer.offer_id] = offer

                    # Benachrichtigung
                    if projekt:
                        for kaeufer_id in projekt.kaeufer_ids:
                            create_notification(kaeufer_id, "Angebot zur√ºckgezogen",
                                              f"Das Finanzierungsangebot f√ºr {projekt.name} wurde zur√ºckgezogen",
                                              NotificationType.WARNING.value)
                    st.warning("Angebot zur√ºckgezogen.")
                    st.rerun()

            with col_b:
                if st.button("üóëÔ∏è L√∂schen", key=f"del_{offer.offer_id}"):
                    del st.session_state.financing_offers[offer.offer_id]
                    st.success("Angebot gel√∂scht.")
                    st.rerun()

        elif show_reactivate:
            if st.button("üîÑ Erneut senden", key=f"react_{offer.offer_id}"):
                offer.status = FinanzierungsStatus.GESENDET.value
                offer.gueltig_bis = None  # Befristung entfernen
                st.session_state.financing_offers[offer.offer_id] = offer

                if projekt:
                    for kaeufer_id in projekt.kaeufer_ids:
                        create_notification(kaeufer_id, "Finanzierungsangebot reaktiviert",
                                          f"Ein Finanzierungsangebot f√ºr {projekt.name} ist wieder verf√ºgbar",
                                          NotificationType.INFO.value)
                st.success("Angebot wurde reaktiviert!")
                st.rerun()

# ============================================================================
# NOTAR-BEREICH
# ============================================================================

def notar_dashboard():
    """Dashboard f√ºr Notar"""
    st.title("‚öñÔ∏è Notar-Dashboard")

    # Aktentasche in der Sidebar
    user_id = st.session_state.current_user.user_id
    render_aktentasche_sidebar(user_id)

    # Benachrichtigungs-Badge in der Sidebar
    render_benachrichtigungs_badge(user_id)

    # Teilen-Dialog anzeigen falls aktiv
    render_aktentasche_teilen_dialog(user_id)

    # Download-Dialog anzeigen falls aktiv
    render_aktentasche_download(user_id)

    # Suchleiste
    search_term = render_dashboard_search("notar")
    if search_term:
        st.session_state['notar_search'] = search_term
    else:
        st.session_state['notar_search'] = ''

    tabs = st.tabs([
        "üìä Timeline",
        "üìã Projekte",
        "üìÅ Aktenmanagement",  # NEU: Aktenf√ºhrung
        "üîç Datenermittlung",  # NEU: Flurkarten, Grundbuch, Baulasten etc.
        "üí∞ Preiseinigungen",
        "üìö Vertragsarchiv",  # Textbausteine & Dokumente
        "üìù Vertragserstellung",  # Vertr√§ge aus Bausteinen erstellen
        "üìù Checklisten",
        "üìã Dokumentenanforderungen",
        "üë• Mitarbeiter",
        "üíµ Finanzierungsnachweise",
        "üìÑ Dokumenten-Freigaben",
        "üìú Kaufvertrag",
        "üîÑ Vertragsvergleich",  # NEU: Side-by-Side Diff
        "üìÖ Termine",
        "ü§ù Maklerempfehlung",
        "üîß Handwerker",
        "ü™™ Ausweisdaten",
        "üìú Rechtsdokumente",
        "üìÅ Aktenimport",  # NEU: PDF-Akten importieren
        "üì® Nachrichten",  # NEU: Kommunikationszentrale
        "‚è∞ Fristen",  # NEU: Fristenmanagement
        "üìà Reporting",  # NEU: KPIs und Berichte
        "üìã Vorlagen",  # NEU: Vorlagen-Management
        "‚öôÔ∏è Einstellungen"
    ])

    with tabs[0]:
        notar_timeline_view()

    with tabs[1]:
        notar_projekte_view()

    with tabs[2]:
        notar_aktenmanagement_view()  # NEU: Aktenf√ºhrung

    with tabs[3]:
        notar_datenermittlung_view()  # NEU: Flurkarten, Grundbuch, Baulasten etc.

    with tabs[4]:
        notar_preiseinigungen_view()

    with tabs[5]:
        notar_vertragsarchiv_view()

    with tabs[6]:
        notar_vertragserstellung_view()

    with tabs[7]:
        notar_checklisten_view()

    with tabs[8]:
        render_document_requests_view(st.session_state.current_user.user_id, UserRole.NOTAR.value)

    with tabs[9]:
        notar_mitarbeiter_view()

    with tabs[10]:
        notar_finanzierungsnachweise()

    with tabs[11]:
        notar_dokumenten_freigaben()

    with tabs[12]:
        notar_kaufvertrag_generator()

    with tabs[13]:
        # Vertragsvergleich - Side-by-Side Diff
        st.subheader("üîÑ Vertragsversionen vergleichen")
        notar_projekte = [p for p in st.session_state.projekte.values()
                         if p.notar_id == user_id]
        if notar_projekte:
            projekt_auswahl = {p.projekt_id: p.name for p in notar_projekte}
            selected_projekt_id = st.selectbox(
                "Projekt ausw√§hlen",
                list(projekt_auswahl.keys()),
                format_func=lambda x: projekt_auswahl[x],
                key="notar_vertragsvergleich_projekt"
            )
            if selected_projekt_id:
                render_vertragsvergleich_tab(selected_projekt_id, user_id, UserRole.NOTAR.value)
        else:
            st.info("Noch keine Projekte zugewiesen.")

    with tabs[14]:
        notar_termine()

    with tabs[15]:
        notar_makler_empfehlung_view()

    with tabs[16]:
        notar_handwerker_view()

    with tabs[17]:
        notar_ausweis_erfassung()

    with tabs[18]:
        notar_rechtsdokumente_view()

    with tabs[19]:
        notar_aktenimport_view()

    with tabs[20]:
        # Kommunikationszentrale
        render_kommunikationszentrale(user_id)

    with tabs[21]:
        # Fristenmanagement
        render_fristenmanagement(user_id)

    with tabs[22]:
        # Reporting Dashboard
        render_reporting_dashboard(user_id)

    with tabs[23]:
        # Vorlagen-Management
        render_vorlagen_management(user_id)

    with tabs[24]:
        notar_einstellungen_view()

def notar_timeline_view():
    """Timeline f√ºr Notar"""
    st.subheader("üìä Projekt-Fortschritt")

    notar_id = st.session_state.current_user.user_id
    search_term = st.session_state.get('notar_search', '')

    alle_projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]
    projekte = filter_projekte_by_search(alle_projekte, search_term)

    display_search_results_info(len(alle_projekte), len(projekte), search_term)

    if not projekte:
        st.info("Keine Projekte gefunden." if search_term else "Noch keine Projekte zugewiesen.")
        return

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            render_timeline(projekt.projekt_id, UserRole.NOTAR.value)

def notar_projekte_view():
    """Projekt-√úbersicht f√ºr Notar"""
    st.subheader("üìã Meine Projekte")

    notar_id = st.session_state.current_user.user_id
    search_term = st.session_state.get('notar_search', '')

    alle_projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]
    projekte = filter_projekte_by_search(alle_projekte, search_term)

    display_search_results_info(len(alle_projekte), len(projekte), search_term)

    if not projekte:
        st.info("Keine Projekte gefunden." if search_term else "Noch keine Projekte zugewiesen.")
        return

    # Verf√ºgbare Mitarbeiter f√ºr diesen Notar
    mitarbeiter = [m for m in st.session_state.notar_mitarbeiter.values() if m.notar_id == notar_id and m.aktiv]

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            col1, col2 = st.columns(2)

            with col1:
                st.markdown(f"**Beschreibung:** {projekt.beschreibung}")
                if projekt.adresse:
                    st.markdown(f"**Adresse:** {projekt.adresse}")
                if projekt.kaufpreis > 0:
                    st.markdown(f"**Kaufpreis:** {format_euro(projekt.kaufpreis)} ‚Ç¨")

            with col2:
                st.markdown("**Parteien:**")
                for kid in projekt.kaeufer_ids:
                    kaeufer = st.session_state.users.get(kid)
                    if kaeufer:
                        st.write(f"üè† K√§ufer: {kaeufer.name}")

                for vid in projekt.verkaeufer_ids:
                    verkaeufer = st.session_state.users.get(vid)
                    if verkaeufer:
                        st.write(f"üè° Verk√§ufer: {verkaeufer.name}")

                # Makler anzeigen
                if projekt.makler_id:
                    makler = st.session_state.users.get(projekt.makler_id)
                    if makler:
                        st.write(f"üëî Makler: {makler.name}")

                # Finanzierer anzeigen
                for fid in projekt.finanzierer_ids:
                    finanzierer = st.session_state.users.get(fid)
                    if finanzierer:
                        st.write(f"üè¶ Finanzierer: {finanzierer.name}")

            # Mitarbeiter-Zuweisung
            st.markdown("---")
            st.markdown("**üë• Zugewiesene Mitarbeiter:**")

            # Zeige aktuell zugewiesene Mitarbeiter
            zugewiesene_ma = [m for m in mitarbeiter if projekt.projekt_id in m.projekt_ids]
            if zugewiesene_ma:
                for ma in zugewiesene_ma:
                    col_ma1, col_ma2 = st.columns([3, 1])
                    with col_ma1:
                        st.write(f"üë§ {ma.name} ({ma.rolle})")
                    with col_ma2:
                        if st.button("‚ùå", key=f"remove_ma_{projekt.projekt_id}_{ma.mitarbeiter_id}", help="Zuweisung entfernen"):
                            ma.projekt_ids.remove(projekt.projekt_id)
                            st.session_state.notar_mitarbeiter[ma.mitarbeiter_id] = ma
                            st.success(f"{ma.name} wurde vom Projekt entfernt.")
                            st.rerun()
            else:
                st.info("Noch keine Mitarbeiter zugewiesen.")

            # Neue Zuweisung
            if mitarbeiter:
                nicht_zugewiesene = [m for m in mitarbeiter if projekt.projekt_id not in m.projekt_ids]
                if nicht_zugewiesene:
                    col_select, col_btn = st.columns([3, 1])
                    with col_select:
                        ma_options = {f"{m.name} ({m.rolle})": m.mitarbeiter_id for m in nicht_zugewiesene}
                        selected_ma_label = st.selectbox(
                            "Mitarbeiter hinzuf√ºgen:",
                            list(ma_options.keys()),
                            key=f"select_ma_{projekt.projekt_id}"
                        )
                    with col_btn:
                        if st.button("‚ûï Zuweisen", key=f"assign_ma_{projekt.projekt_id}"):
                            ma_id = ma_options[selected_ma_label]
                            ma = st.session_state.notar_mitarbeiter[ma_id]
                            ma.projekt_ids.append(projekt.projekt_id)
                            st.session_state.notar_mitarbeiter[ma_id] = ma
                            st.success(f"{ma.name} wurde dem Projekt zugewiesen.")
                            st.rerun()
            else:
                st.info("üí° Legen Sie Mitarbeiter im Tab 'üë• Mitarbeiter' an, um sie Projekten zuzuweisen.")

            # NEU: Parteien-Verwaltung (Gesellschaften, Organe, Handelsregister)
            st.markdown("---")
            with st.expander("üë• Parteien & Gesellschaften verwalten", expanded=False):
                render_parteien_verwaltung(projekt, UserRole.NOTAR.value)

            # NEU: Gating-√úbersicht (Finanzierung & Legal)
            with st.expander("üîê Freigabe-Status & Gating", expanded=False):
                render_gating_uebersicht(projekt.projekt_id, UserRole.NOTAR.value)

            # Aktenzeichen und verkn√ºpfte Akte anzeigen
            if projekt.aktenzeichen:
                st.markdown("---")
                st.markdown(f"**üìÅ Aktenzeichen:** {projekt.aktenzeichen}")
                if projekt.akte_id and projekt.akte_id in st.session_state.importierte_akten:
                    akte = st.session_state.importierte_akten[projekt.akte_id]
                    st.info(f"Verkn√ºpft mit Akte: {akte.bezeichnung}")


def notar_aktenmanagement_view():
    """Aktenmanagement f√ºr Notar - Akten anlegen, suchen und verwalten"""
    st.subheader("üìÅ Aktenmanagement")

    notar_id = st.session_state.current_user.user_id

    # Notar-K√ºrzel setzen falls nicht vorhanden
    if notar_id not in st.session_state.notar_kuerzel:
        st.warning("‚ö†Ô∏è Bitte legen Sie zuerst Ihr Notar-K√ºrzel fest.")
        with st.form("notar_kuerzel_form"):
            kuerzel = st.text_input(
                "Ihr K√ºrzel (z.B. SQ f√ºr Notar Meier)",
                max_chars=5,
                help="Dieses K√ºrzel erscheint im Aktenzeichen"
            )
            if st.form_submit_button("üíæ Speichern"):
                if kuerzel:
                    st.session_state.notar_kuerzel[notar_id] = kuerzel.upper()
                    st.success(f"K√ºrzel '{kuerzel.upper()}' gespeichert!")
                    st.rerun()
                else:
                    st.error("Bitte geben Sie ein K√ºrzel ein.")
        return

    # Sub-Tabs f√ºr Aktenmanagement
    sub_tabs = st.tabs([
        "üìã Akten√ºbersicht",
        "‚ûï Neue Akte",
        "üîç Aktensuche",
        "üìÇ Kategorien verwalten"
    ])

    # --- Akten√ºbersicht ---
    with sub_tabs[0]:
        st.markdown("### üìã Ihre Akten")

        # Filter
        col1, col2, col3 = st.columns(3)
        with col1:
            status_filter = st.selectbox(
                "Status",
                ["Alle"] + [s.value for s in AktenStatus],
                key="akten_status_filter"
            )
        with col2:
            bereich_filter = st.selectbox(
                "Rechtsbereich",
                ["Alle"] + [b.value for b in AktenHauptbereich],
                key="akten_bereich_filter"
            )
        with col3:
            # Sachbearbeiter-Filter
            mitarbeiter_options = {"Alle": None}
            for ma in st.session_state.notar_mitarbeiter.values():
                if ma.notar_id == notar_id and ma.aktiv:
                    mitarbeiter_options[ma.name] = ma.mitarbeiter_id
            ma_filter = st.selectbox("Sachbearbeiter", list(mitarbeiter_options.keys()), key="akten_ma_filter")

        # Akten laden
        akten = get_akten_fuer_notar(notar_id)

        # Filter anwenden
        if status_filter != "Alle":
            akten = [a for a in akten if a.status == status_filter]
        if bereich_filter != "Alle":
            akten = [a for a in akten if a.hauptbereich == bereich_filter]
        if mitarbeiter_options[ma_filter]:
            akten = [a for a in akten if a.sachbearbeiter_id == mitarbeiter_options[ma_filter]]

        # Statistiken
        st.markdown("---")
        stat_col1, stat_col2, stat_col3, stat_col4 = st.columns(4)
        alle_akten = get_akten_fuer_notar(notar_id)
        with stat_col1:
            st.metric("Gesamt", len(alle_akten))
        with stat_col2:
            offene = len([a for a in alle_akten if a.status not in [AktenStatus.ABGESCHLOSSEN.value, AktenStatus.STORNIERT.value]])
            st.metric("Offen", offene)
        with stat_col3:
            beurkundet = len([a for a in alle_akten if a.status == AktenStatus.BEURKUNDET.value])
            st.metric("Beurkundet", beurkundet)
        with stat_col4:
            wiedervorlage = len([a for a in alle_akten if a.naechste_wiedervorlage and a.naechste_wiedervorlage <= date.today()])
            st.metric("Wiedervorlage heute", wiedervorlage, delta=wiedervorlage if wiedervorlage > 0 else None, delta_color="inverse")

        st.markdown("---")

        if not akten:
            st.info("Keine Akten gefunden. Legen Sie eine neue Akte an.")
        else:
            for akte in akten:
                with st.expander(f"üìÅ {akte.aktenzeichen} - {akte.untertyp}", expanded=False):
                    col1, col2 = st.columns([2, 1])
                    with col1:
                        st.markdown(f"**Aktenzeichen:** `{akte.aktenzeichen}`")
                        st.markdown(f"**Kurzbezeichnung:** {akte.kurzbezeichnung}")
                        st.markdown(f"**Bereich:** {akte.hauptbereich} ‚Üí {akte.untertyp}")
                        st.markdown(f"**Betreff:** {akte.betreff or '-'}")

                        # Sachbearbeiter anzeigen
                        if akte.sachbearbeiter_id:
                            ma = st.session_state.notar_mitarbeiter.get(akte.sachbearbeiter_id)
                            if ma:
                                st.markdown(f"**Sachbearbeiter:** {ma.name} ({akte.mitarbeiter_kuerzel})")

                        # Projekt-Verkn√ºpfung
                        if akte.projekt_id:
                            projekt = st.session_state.projekte.get(akte.projekt_id)
                            if projekt:
                                st.markdown(f"**Verkn√ºpftes Projekt:** {projekt.name}")

                    with col2:
                        status_colors = {
                            AktenStatus.NEU.value: "üü°",
                            AktenStatus.IN_BEARBEITUNG.value: "üîµ",
                            AktenStatus.WARTET_AUF_UNTERLAGEN.value: "üü†",
                            AktenStatus.BEURKUNDUNG_VORBEREITET.value: "üü¢",
                            AktenStatus.BEURKUNDET.value: "‚úÖ",
                            AktenStatus.VOLLZUG.value: "‚è≥",
                            AktenStatus.ABGESCHLOSSEN.value: "‚úîÔ∏è",
                            AktenStatus.STORNIERT.value: "‚ùå"
                        }
                        st.markdown(f"**Status:** {status_colors.get(akte.status, '‚ö™')} {akte.status}")
                        st.markdown(f"**Erstellt:** {akte.erstellt_am.strftime('%d.%m.%Y')}")

                        if akte.geschaeftswert > 0:
                            st.markdown(f"**Gesch√§ftswert:** {akte.geschaeftswert:,.2f} ‚Ç¨")

                        if akte.beurkundungstermin:
                            st.markdown(f"**Beurkundung:** {akte.beurkundungstermin.strftime('%d.%m.%Y %H:%M')}")

                        if akte.naechste_wiedervorlage:
                            wv_date = akte.naechste_wiedervorlage
                            if wv_date <= date.today():
                                st.markdown(f"**Wiedervorlage:** ‚ö†Ô∏è {wv_date.strftime('%d.%m.%Y')}")
                            else:
                                st.markdown(f"**Wiedervorlage:** {wv_date.strftime('%d.%m.%Y')}")

                    # Aktionen
                    st.markdown("---")
                    action_col1, action_col2, action_col3 = st.columns(3)
                    with action_col1:
                        neuer_status = st.selectbox(
                            "Status √§ndern",
                            [s.value for s in AktenStatus],
                            index=[s.value for s in AktenStatus].index(akte.status),
                            key=f"status_{akte.akte_id}"
                        )
                    with action_col2:
                        if st.button("üíæ Status speichern", key=f"save_status_{akte.akte_id}"):
                            akte.status = neuer_status
                            akte.aktualisiert_am = datetime.now()
                            st.success("Status aktualisiert!")
                            st.rerun()
                    with action_col3:
                        if st.button("üìã Aktenzeichen kopieren", key=f"copy_az_{akte.akte_id}"):
                            st.code(akte.aktenzeichen)
                            st.info("Aktenzeichen zum Kopieren angezeigt")

    # --- Neue Akte anlegen ---
    with sub_tabs[1]:
        st.markdown("### ‚ûï Neue Akte anlegen")

        # Hauptbereich AUSSERHALB des Formulars f√ºr dynamische Aktualisierung
        st.markdown("#### Rechtsbereich ausw√§hlen")
        hauptbereich = st.selectbox(
            "Hauptbereich",
            [b.value for b in AktenHauptbereich],
            key="neue_akte_hauptbereich"
        )

        # Untertypen basierend auf Hauptbereich (dynamisch aktualisiert)
        untertypen = get_verfuegbare_untertypen(hauptbereich, notar_id)
        untertyp = st.selectbox(
            "Unterbereich / Typ",
            untertypen,
            key="neue_akte_untertyp",
            help=f"Verf√ºgbare Untertypen f√ºr {hauptbereich}"
        )

        st.markdown("---")

        with st.form("neue_akte_form"):
            st.markdown("#### Parteien")
            col1, col2 = st.columns(2)
            with col1:
                verkaeufer_nachname = st.text_input(
                    "Nachname Partei 1 (Verk√§ufer/Erblasser/etc.)",
                    placeholder="z.B. Krug"
                )
            with col2:
                kaeufer_nachname = st.text_input(
                    "Nachname Partei 2 (K√§ufer/Erbe/etc.)",
                    placeholder="z.B. M√ºller"
                )

            st.markdown("---")
            st.markdown("#### Details")

            betreff = st.text_input(
                "Betreff / Kurzbeschreibung",
                placeholder="z.B. Grundst√ºckskauf Musterstra√üe 1"
            )

            col1, col2 = st.columns(2)
            with col1:
                geschaeftswert = st.number_input(
                    "Gesch√§ftswert (‚Ç¨)",
                    min_value=0.0,
                    step=1000.0
                )
            with col2:
                # Sachbearbeiter zuweisen
                mitarbeiter_options = {"-- Keiner --": None}
                for ma in st.session_state.notar_mitarbeiter.values():
                    if ma.notar_id == notar_id and ma.aktiv:
                        mitarbeiter_options[f"{ma.name} ({st.session_state.mitarbeiter_kuerzel.get(ma.mitarbeiter_id, '?')})"] = ma.mitarbeiter_id
                sachbearbeiter = st.selectbox("Sachbearbeiter zuweisen", list(mitarbeiter_options.keys()))

            # Optional: Mit Projekt verkn√ºpfen
            st.markdown("---")
            projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]
            projekt_options = {"-- Kein Projekt --": None}
            for p in projekte:
                # Nur Projekte ohne Akte anzeigen
                if not get_akte_fuer_projekt(p.projekt_id):
                    projekt_options[f"{p.name} ({p.adresse})"] = p.projekt_id

            verknuepftes_projekt = st.selectbox(
                "Mit Projekt verkn√ºpfen (optional)",
                list(projekt_options.keys()),
                help="Verkn√ºpft diese Akte mit einem Makler-Projekt"
            )

            submitted = st.form_submit_button("üìÅ Akte anlegen", type="primary")

            if submitted:
                if not verkaeufer_nachname or not kaeufer_nachname:
                    st.error("Bitte geben Sie beide Partei-Nachnamen ein.")
                else:
                    # Akte erstellen
                    neue_akte = create_akte(
                        notar_id=notar_id,
                        hauptbereich=hauptbereich,
                        untertyp=untertyp,
                        verkaeufer_nachname=verkaeufer_nachname,
                        kaeufer_nachname=kaeufer_nachname,
                        sachbearbeiter_id=mitarbeiter_options[sachbearbeiter],
                        projekt_id=projekt_options[verknuepftes_projekt],
                        betreff=betreff,
                        geschaeftswert=geschaeftswert
                    )

                    st.success(f"‚úÖ Akte angelegt: **{neue_akte.aktenzeichen}**")
                    st.balloons()

                    # Aktenzeichen anzeigen
                    st.markdown("---")
                    st.markdown("### Ihr neues Aktenzeichen:")
                    st.code(neue_akte.aktenzeichen, language=None)
                    st.caption(f"Kurzbezeichnung f√ºr Kommunikation: `{neue_akte.kurzbezeichnung}`")

    # --- Aktensuche ---
    with sub_tabs[2]:
        st.markdown("### üîç Aktensuche")

        suchbegriff = st.text_input(
            "Suche",
            placeholder="Aktenzeichen, Name, Betreff...",
            key="akten_suche_input"
        )

        col1, col2 = st.columns(2)
        with col1:
            such_bereich = st.selectbox(
                "Rechtsbereich",
                ["Alle"] + [b.value for b in AktenHauptbereich],
                key="such_bereich"
            )
        with col2:
            such_status = st.selectbox(
                "Status",
                ["Alle"] + [s.value for s in AktenStatus],
                key="such_status"
            )

        if st.button("üîç Suchen", type="primary"):
            ergebnisse = suche_akten(
                notar_id=notar_id,
                suchbegriff=suchbegriff,
                hauptbereich=such_bereich if such_bereich != "Alle" else None,
                status=such_status if such_status != "Alle" else None
            )

            st.markdown(f"**{len(ergebnisse)} Ergebnis(se) gefunden:**")

            for akte in ergebnisse:
                st.markdown(f"""
                üìÅ **{akte.aktenzeichen}**
                - Bereich: {akte.hauptbereich} ‚Üí {akte.untertyp}
                - Status: {akte.status}
                - Betreff: {akte.betreff or '-'}
                """)

    # --- Kategorien verwalten ---
    with sub_tabs[3]:
        st.markdown("### üìÇ Benutzerdefinierte Kategorien")

        st.info("""
        Hier k√∂nnen Sie neue Kategorien f√ºr Akten erstellen.
        Mitarbeiter k√∂nnen ebenfalls Kategorien vorschlagen, diese m√ºssen jedoch von Ihnen freigegeben werden.
        """)

        # Bestehende Kategorien anzeigen
        kategorien = [k for k in st.session_state.benutzerdefinierte_kategorien.values() if k.notar_id == notar_id]

        if kategorien:
            st.markdown("#### Bestehende Kategorien")
            for kat in kategorien:
                with st.expander(f"{'‚úÖ' if kat.freigegeben else '‚è≥'} {kat.name} ({kat.hauptbereich})"):
                    st.markdown(f"**Beschreibung:** {kat.beschreibung or '-'}")
                    st.markdown(f"**Status:** {'Freigegeben' if kat.freigegeben else 'Wartet auf Freigabe'}")

                    if not kat.freigegeben:
                        if st.button("‚úÖ Freigeben", key=f"approve_kat_{kat.kategorie_id}"):
                            kat.freigegeben = True
                            kat.freigegeben_am = datetime.now()
                            kat.freigegeben_von_id = notar_id
                            st.success(f"Kategorie '{kat.name}' freigegeben!")
                            st.rerun()

        # Neue Kategorie erstellen
        st.markdown("---")
        st.markdown("#### Neue Kategorie erstellen")

        with st.form("neue_kategorie_form"):
            kat_hauptbereich = st.selectbox(
                "Hauptbereich",
                [b.value for b in AktenHauptbereich],
                key="neue_kat_hauptbereich"
            )
            kat_name = st.text_input("Name der Kategorie")
            kat_beschreibung = st.text_area("Beschreibung (optional)")

            if st.form_submit_button("‚ûï Kategorie erstellen"):
                if kat_name:
                    neue_kat = create_benutzerdefinierte_kategorie(
                        notar_id=notar_id,
                        hauptbereich=kat_hauptbereich,
                        name=kat_name,
                        beschreibung=kat_beschreibung,
                        erstellt_von_id=notar_id
                    )
                    # Als Notar direkt freigeben
                    neue_kat.freigegeben = True
                    neue_kat.freigegeben_am = datetime.now()
                    neue_kat.freigegeben_von_id = notar_id
                    st.success(f"Kategorie '{kat_name}' erstellt und freigegeben!")
                    st.rerun()
                else:
                    st.error("Bitte geben Sie einen Namen ein.")


def notar_preiseinigungen_view():
    """VERBESSERUNG 4: √úbersicht aller Preiseinigungen f√ºr Beurkundungsvorbereitung"""
    st.subheader("üí∞ Preiseinigungen")

    notar_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    if not projekte:
        st.info("Noch keine Projekte zugewiesen.")
        return

    # Statistik
    col1, col2, col3 = st.columns(3)

    einigungen = []
    offene_verhandlungen = []
    ohne_verhandlung = []

    for projekt in projekte:
        angebote = get_preisangebote_fuer_projekt(projekt.projekt_id)
        angenommene = [a for a in angebote if a.status == PreisangebotStatus.ANGENOMMEN.value]
        offene = [a for a in angebote if a.status == PreisangebotStatus.OFFEN.value]

        if angenommene:
            einigungen.append((projekt, angenommene[0]))
        elif offene:
            offene_verhandlungen.append((projekt, offene[0]))
        else:
            ohne_verhandlung.append(projekt)

    with col1:
        st.metric("‚úÖ Mit Einigung", len(einigungen))
    with col2:
        st.metric("‚è≥ In Verhandlung", len(offene_verhandlungen))
    with col3:
        st.metric("üìã Ohne Verhandlung", len(ohne_verhandlung))

    st.markdown("---")

    # Einigungen (bereit f√ºr Beurkundung)
    if einigungen:
        st.markdown("### ‚úÖ Bereit f√ºr Beurkundung")
        for projekt, einigung in einigungen:
            kaeufer_namen = [st.session_state.users.get(kid).name for kid in projekt.kaeufer_ids if st.session_state.users.get(kid)]
            verkaeufer_namen = [st.session_state.users.get(vid).name for vid in projekt.verkaeufer_ids if st.session_state.users.get(vid)]

            with st.expander(f"üè† {projekt.name} - {format_euro(einigung.betrag)} ‚Ç¨", expanded=True):
                col1, col2 = st.columns(2)
                with col1:
                    st.markdown(f"**Kaufpreis:** {format_euro(einigung.betrag)} ‚Ç¨")
                    st.markdown(f"**Einigung am:** {einigung.beantwortet_am.strftime('%d.%m.%Y %H:%M') if einigung.beantwortet_am else einigung.erstellt_am.strftime('%d.%m.%Y')}")
                    st.markdown(f"**Adresse:** {projekt.adresse or 'Nicht angegeben'}")
                with col2:
                    st.markdown(f"**K√§ufer:** {', '.join(kaeufer_namen) or 'Keine'}")
                    st.markdown(f"**Verk√§ufer:** {', '.join(verkaeufer_namen) or 'Keine'}")

                # Button f√ºr Terminvorschlag
                if st.button("üìÖ Beurkundungstermin vorschlagen", key=f"termin_einigung_{projekt.projekt_id}"):
                    st.session_state[f"zeige_termin_form_{projekt.projekt_id}"] = True

                if st.session_state.get(f"zeige_termin_form_{projekt.projekt_id}"):
                    st.markdown("**Neuen Beurkundungstermin erstellen:**")
                    termin_datum = st.date_input("Datum", value=date.today() + timedelta(days=14), key=f"notar_termin_datum_{projekt.projekt_id}")
                    termin_uhrzeit = st.time_input("Uhrzeit", value=None, key=f"notar_termin_uhr_{projekt.projekt_id}")

                    if st.button("‚úÖ Termin vorschlagen", key=f"erstelle_termin_{projekt.projekt_id}"):
                        # Termin erstellen (vereinfacht)
                        create_notification(
                            user_id=notar_id,
                            titel="üìÖ Beurkundungstermin erstellt",
                            nachricht=f"Termin f√ºr {projekt.name} am {termin_datum.strftime('%d.%m.%Y')} vorgeschlagen.",
                            typ=NotificationType.SUCCESS.value
                        )
                        # Alle Parteien benachrichtigen
                        for kid in projekt.kaeufer_ids:
                            create_notification(kid, "üìÖ Beurkundungstermin", f"Der Notar schl√§gt einen Beurkundungstermin f√ºr {projekt.name} am {termin_datum.strftime('%d.%m.%Y')} vor.", NotificationType.INFO.value)
                        for vid in projekt.verkaeufer_ids:
                            create_notification(vid, "üìÖ Beurkundungstermin", f"Der Notar schl√§gt einen Beurkundungstermin f√ºr {projekt.name} am {termin_datum.strftime('%d.%m.%Y')} vor.", NotificationType.INFO.value)
                        if projekt.makler_id:
                            create_notification(projekt.makler_id, "üìÖ Beurkundungstermin", f"Beurkundungstermin f√ºr {projekt.name} am {termin_datum.strftime('%d.%m.%Y')} vorgeschlagen.", NotificationType.INFO.value)

                        st.session_state[f"zeige_termin_form_{projekt.projekt_id}"] = False
                        st.success("‚úÖ Termin vorgeschlagen und alle Parteien benachrichtigt!")
                        st.rerun()

    # Offene Verhandlungen
    if offene_verhandlungen:
        st.markdown("---")
        st.markdown("### ‚è≥ Laufende Verhandlungen")
        for projekt, letztes in offene_verhandlungen:
            von_user = st.session_state.users.get(letztes.von_user_id)
            von_name = von_user.name if von_user else "Unbekannt"
            st.info(f"**{projekt.name}**: Offenes Angebot von {von_name} ({letztes.von_rolle}) √ºber {format_euro(letztes.betrag)} ‚Ç¨")

    # Ohne Verhandlung
    if ohne_verhandlung:
        st.markdown("---")
        st.markdown("### üìã Ohne aktive Preisverhandlung")
        for projekt in ohne_verhandlung:
            st.write(f"‚Ä¢ {projekt.name} - Kaufpreis: {format_euro(projekt.kaufpreis)} ‚Ç¨")


# ============================================================================
# VERTRAGSARCHIV & TEXTBAUSTEINE
# ============================================================================

def berechne_text_hash(text: str) -> str:
    """Berechnet einen Hash f√ºr Duplikaterkennung"""
    # Normalisiere Text: Kleinbuchstaben, entferne mehrfache Leerzeichen
    normalized = ' '.join(text.lower().split())
    return hashlib.md5(normalized.encode()).hexdigest()


def finde_aehnliche_bausteine(text: str, notar_id: str, schwellenwert: float = 0.8) -> List[Tuple[str, float]]:
    """Findet √§hnliche Textbausteine basierend auf einfachem Textvergleich"""
    aehnliche = []
    text_hash = berechne_text_hash(text)
    text_words = set(text.lower().split())

    for baustein in st.session_state.textbausteine.values():
        if baustein.notar_id != notar_id:
            continue

        # Exakter Match
        if baustein.text_hash == text_hash:
            aehnliche.append((baustein.baustein_id, 1.0))
            continue

        # Wort-basierte √Ñhnlichkeit (Jaccard)
        baustein_words = set(baustein.text.lower().split())
        if len(text_words) > 0 and len(baustein_words) > 0:
            intersection = len(text_words & baustein_words)
            union = len(text_words | baustein_words)
            similarity = intersection / union if union > 0 else 0

            if similarity >= schwellenwert:
                aehnliche.append((baustein.baustein_id, similarity))

    return sorted(aehnliche, key=lambda x: x[1], reverse=True)


def extrahiere_text_aus_datei(datei_bytes: bytes, dateityp: str, dateiname: str) -> str:
    """Extrahiert Text aus verschiedenen Dateiformaten"""
    text = ""

    if dateityp == "docx":
        try:
            # Versuche docx zu parsen (einfache XML-Extraktion)
            import zipfile
            from xml.etree import ElementTree

            with zipfile.ZipFile(io.BytesIO(datei_bytes)) as docx:
                if 'word/document.xml' in docx.namelist():
                    with docx.open('word/document.xml') as doc:
                        tree = ElementTree.parse(doc)
                        root = tree.getroot()
                        # Namespace f√ºr Word-Dokumente
                        ns = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
                        paragraphs = root.findall('.//w:p', ns)
                        for p in paragraphs:
                            texts = p.findall('.//w:t', ns)
                            para_text = ''.join(t.text or '' for t in texts)
                            if para_text.strip():
                                text += para_text + "\n"
        except Exception as e:
            text = f"[Fehler beim Lesen der DOCX-Datei: {str(e)}]"

    elif dateityp == "rtf":
        try:
            # RTF-Text-Extraktion
            import re as re_rtf
            content = datei_bytes.decode('latin-1', errors='ignore')

            # Entferne RTF-Steuerzeichen und extrahiere Text
            # Entferne RTF-Header und Control-Words
            content = re_rtf.sub(r'\\[a-z]+\d*\s?', '', content)
            # Entferne geschweifte Klammern
            content = re_rtf.sub(r'[{}]', '', content)
            # Entferne Hex-Codes wie \'xx
            content = re_rtf.sub(r"\\'[0-9a-fA-F]{2}", '', content)
            # Ersetze RTF-Zeilenumbr√ºche
            content = content.replace('\\par', '\n')
            content = content.replace('\\line', '\n')
            # Bereinige mehrfache Leerzeichen
            content = re_rtf.sub(r' +', ' ', content)
            content = re_rtf.sub(r'\n+', '\n', content)

            text = content.strip()

            if len(text) < 50:
                text = "[RTF-Text konnte nicht vollst√§ndig extrahiert werden. Bitte pr√ºfen Sie das Dokument.]"
        except Exception as e:
            text = f"[Fehler beim Lesen der RTF-Datei: {str(e)}]"

    elif dateityp == "pdf":
        # PDF-Text-Extraktion (vereinfacht - in Production w√ºrde man PyPDF2 oder pdfplumber verwenden)
        try:
            # Versuche einfache Text-Extraktion aus PDF
            content = datei_bytes.decode('latin-1', errors='ignore')
            # Suche nach Text-Streams
            import re
            text_pattern = re.compile(r'\((.*?)\)', re.DOTALL)
            matches = text_pattern.findall(content)
            text = ' '.join(matches[:100])  # Begrenzen
            if len(text) < 100:
                text = "[PDF-Text konnte nicht automatisch extrahiert werden. Bitte OCR verwenden oder Text manuell eingeben.]"
        except Exception:
            text = "[PDF-Verarbeitung fehlgeschlagen]"

    elif dateityp in ["image", "jpg", "jpeg", "png"]:
        text = "[Bild-Datei erkannt. OCR-Verarbeitung erforderlich f√ºr Textextraktion.]"

    return text.strip()


def ki_analysiere_textbaustein(text: str) -> Dict[str, Any]:
    """Verwendet KI um Titel, Zusammenfassung und Kategorie f√ºr einen Textbaustein zu generieren"""
    api_key = st.session_state.api_keys.get('openai', '')

    if not api_key:
        # Fallback: Einfache Heuristik
        return ki_analysiere_textbaustein_fallback(text)

    try:
        import urllib.request
        import json as json_module

        prompt = f"""Analysiere den folgenden juristischen Textbaustein aus einem notariellen Vertrag und gib folgende Informationen zur√ºck:

1. TITEL: Ein kurzer, pr√§gnanter Titel (max. 50 Zeichen) der den Regelungsinhalt beschreibt
2. ZUSAMMENFASSUNG: Eine kurze Zusammenfassung in 1-2 S√§tzen
3. KATEGORIE: Eine der folgenden Kategorien:
   - Vertragsparteien
   - Kaufgegenstand
   - Kaufpreis & Zahlung
   - Zahlungsmodalit√§ten
   - F√§lligkeit
   - Auflassung & Eigentums√ºbergang
   - Besitz√ºbergang
   - Haftung & Gew√§hrleistung
   - M√§ngelhaftung
   - R√ºcktritt & Aufhebung
   - Vertragsstrafe
   - Kosten & Steuern
   - Belastungen & Lasten
   - Grundbuch
   - Erschlie√üung
   - Baulasten
   - Vorkaufsrecht
   - Vollmachten
   - Schlussbestimmungen
   - Salvatorische Klausel
   - Sonstiges
4. VERTRAGSTYPEN: Liste der Vertragstypen, in denen dieser Baustein typischerweise vorkommt (Kaufvertrag, √úberlassungsvertrag, Erbvertrag, Schenkungsvertrag, etc.)

TEXT:
{text[:2000]}

Antworte im JSON-Format:
{{"titel": "...", "zusammenfassung": "...", "kategorie": "...", "vertragstypen": ["...", "..."]}}"""

        request_data = {
            "model": "gpt-4o-mini",
            "messages": [{"role": "user", "content": prompt}],
            "temperature": 0.3,
            "max_tokens": 500
        }

        req = urllib.request.Request(
            "https://api.openai.com/v1/chat/completions",
            data=json_module.dumps(request_data).encode('utf-8'),
            headers={
                "Content-Type": "application/json",
                "Authorization": f"Bearer {api_key}"
            }
        )

        with urllib.request.urlopen(req, timeout=30) as response:
            result = json_module.loads(response.read().decode('utf-8'))
            content = result['choices'][0]['message']['content']

            # Parse JSON aus Antwort
            # Entferne m√∂gliche Markdown-Code-Bl√∂cke
            if '```json' in content:
                content = content.split('```json')[1].split('```')[0]
            elif '```' in content:
                content = content.split('```')[1].split('```')[0]

            parsed = json_module.loads(content.strip())
            return {
                'titel': parsed.get('titel', 'Unbenannter Baustein'),
                'zusammenfassung': parsed.get('zusammenfassung', ''),
                'kategorie': parsed.get('kategorie', 'Sonstiges'),
                'vertragstypen': parsed.get('vertragstypen', []),
                'ki_generiert': True
            }

    except Exception as e:
        # Fallback bei Fehler
        return ki_analysiere_textbaustein_fallback(text)


def ki_analysiere_textbaustein_fallback(text: str) -> Dict[str, Any]:
    """Fallback-Analyse ohne KI - basiert auf Schl√ºsselw√∂rtern"""
    text_lower = text.lower()

    # Kategorie-Erkennung basierend auf Schl√ºsselw√∂rtern
    kategorie = "Sonstiges"
    kategorie_keywords = {
        "Vertragsparteien": ["k√§ufer", "verk√§ufer", "erschienen", "handelt", "vertreten durch"],
        "Kaufgegenstand": ["kaufgegenstand", "grundst√ºck", "wohnung", "immobilie", "objekt"],
        "Kaufpreis & Zahlung": ["kaufpreis", "euro", "zahlung", "betrag"],
        "Zahlungsmodalit√§ten": ["ratenzahlung", "zahlung in", "teilbetrag"],
        "F√§lligkeit": ["f√§llig", "f√§lligkeit", "zahlbar bis"],
        "Auflassung & Eigentums√ºbergang": ["auflassung", "eigentums√ºbergang", "grundbucheintrag"],
        "Besitz√ºbergang": ["besitz√ºbergang", "√ºbergabe", "besitz geht √ºber"],
        "Haftung & Gew√§hrleistung": ["haftung", "gew√§hrleistung", "haftet"],
        "M√§ngelhaftung": ["m√§ngel", "sachmangel", "rechtsmangel"],
        "R√ºcktritt & Aufhebung": ["r√ºcktritt", "aufhebung", "r√ºcktrittsrecht"],
        "Vertragsstrafe": ["vertragsstrafe", "konventionalstrafe"],
        "Kosten & Steuern": ["kosten", "steuer", "grunderwerbsteuer", "notarkosten"],
        "Belastungen & Lasten": ["belastung", "lasten", "dienstbarkeit"],
        "Grundbuch": ["grundbuch", "eintragung", "l√∂schung"],
        "Erschlie√üung": ["erschlie√üung", "erschlossen"],
        "Baulasten": ["baulast"],
        "Vorkaufsrecht": ["vorkaufsrecht", "vorkauf"],
        "Vollmachten": ["vollmacht", "bevollm√§chtigt"],
        "Schlussbestimmungen": ["schlussbestimmung", "inkrafttreten"],
        "Salvatorische Klausel": ["salvatorisch", "unwirksamkeit einer bestimmung"]
    }

    for kat, keywords in kategorie_keywords.items():
        if any(kw in text_lower for kw in keywords):
            kategorie = kat
            break

    # Titel aus ersten W√∂rtern oder √úberschrift
    lines = text.strip().split('\n')
    first_line = lines[0].strip() if lines else ""
    titel = first_line[:50] if first_line else "Textbaustein"

    # Einfache Zusammenfassung: Erste 100 Zeichen
    zusammenfassung = text[:150].replace('\n', ' ').strip()
    if len(text) > 150:
        zusammenfassung += "..."

    return {
        'titel': titel,
        'zusammenfassung': zusammenfassung,
        'kategorie': kategorie,
        'vertragstypen': [VertragsTyp.KAUFVERTRAG.value],  # Standard
        'ki_generiert': False
    }


def ki_zerlege_vertrag_in_bausteine(volltext: str) -> List[Dict[str, Any]]:
    """Zerlegt einen Vertrag in einzelne Textbausteine mit Start/End-Indizes"""
    bausteine = []
    import re

    # Verschiedene Muster f√ºr Vertragsabschnitte
    patterns = [
        r'¬ß\s*\d+',  # ¬ß 1, ¬ß 2, etc.
        r'Artikel\s+\d+',  # Artikel 1, etc.
        r'\n[IVX]+\.\s',  # I. II. III. etc.
        r'\n\d+\.\s+[A-Z√Ñ√ñ√ú]',  # 1. Titel, 2. Titel
    ]

    # Finde alle Trennpunkte mit Positionen
    trennpunkte = [0]  # Start des Dokuments

    for pattern in patterns:
        matches = list(re.finditer(pattern, volltext, flags=re.MULTILINE))
        if len(matches) >= 2:  # Mindestens 2 Treffer f√ºr sinnvolle Zerlegung
            trennpunkte = [0] + [m.start() for m in matches] + [len(volltext)]
            break

    # Falls keine Muster gefunden, nach doppelten Zeilenumbr√ºchen suchen
    if len(trennpunkte) <= 2:
        matches = list(re.finditer(r'\n\s*\n', volltext))
        if matches:
            trennpunkte = [0] + [m.end() for m in matches] + [len(volltext)]

    # Falls immer noch keine Trennpunkte, den gesamten Text als einen Baustein
    if len(trennpunkte) <= 2:
        trennpunkte = [0, len(volltext)]

    # Bausteine aus Trennpunkten erstellen
    for i in range(len(trennpunkte) - 1):
        start_idx = trennpunkte[i]
        end_idx = trennpunkte[i + 1]
        teil_text = volltext[start_idx:end_idx].strip()

        if len(teil_text) > 50:  # Mindestl√§nge f√ºr einen Baustein
            # Berechne tats√§chliche Start/End-Position (ohne f√ºhrende/trailing Whitespaces)
            actual_start = volltext.find(teil_text, start_idx)
            actual_end = actual_start + len(teil_text)

            bausteine.append({
                'text': teil_text,
                'position': i,
                'start_index': actual_start,
                'end_index': actual_end
            })

    return bausteine


def ki_suche_updates(baustein: Textbaustein) -> Dict[str, Any]:
    """Sucht nach m√∂glichen Updates f√ºr einen Textbaustein via KI"""
    api_key = st.session_state.api_keys.get('openai', '')

    if not api_key:
        return {
            'gefunden': False,
            'fehler': 'Kein OpenAI API-Key konfiguriert'
        }

    try:
        import urllib.request
        import json as json_module

        prompt = f"""Du bist ein Experte f√ºr deutsches Notarrecht und Vertragsrecht.

Analysiere den folgenden Textbaustein aus einem notariellen Vertrag und pr√ºfe:
1. Ist die Formulierung noch aktuell und rechtssicher?
2. Gibt es neuere Gesetzes√§nderungen oder Rechtsprechung, die eine Anpassung erfordern k√∂nnten?
3. Gibt es bessere oder pr√§zisere Formulierungen, die √ºblich sind?

Kategorie des Bausteins: {baustein.kategorie}
Vertragstypen: {', '.join(baustein.vertragstypen)}

AKTUELLER TEXT:
{baustein.text[:2000]}

Wenn du Verbesserungen oder Updates empfiehlst, gib:
1. Den konkreten √Ñnderungsvorschlag
2. Die Begr√ºndung f√ºr die √Ñnderung
3. Falls m√∂glich, eine Quellenangabe (z.B. Gesetzes√§nderung, BGH-Urteil, Mustervertrag)

Antworte im JSON-Format:
{{"update_empfohlen": true/false, "vorschlag": "...", "begruendung": "...", "quelle": "..."}}
Wenn kein Update n√∂tig ist: {{"update_empfohlen": false, "hinweis": "Der Baustein ist aktuell."}}"""

        request_data = {
            "model": "gpt-4o-mini",
            "messages": [{"role": "user", "content": prompt}],
            "temperature": 0.3,
            "max_tokens": 1000
        }

        req = urllib.request.Request(
            "https://api.openai.com/v1/chat/completions",
            data=json_module.dumps(request_data).encode('utf-8'),
            headers={
                "Content-Type": "application/json",
                "Authorization": f"Bearer {api_key}"
            }
        )

        with urllib.request.urlopen(req, timeout=60) as response:
            result = json_module.loads(response.read().decode('utf-8'))
            content = result['choices'][0]['message']['content']

            # Parse JSON
            if '```json' in content:
                content = content.split('```json')[1].split('```')[0]
            elif '```' in content:
                content = content.split('```')[1].split('```')[0]

            parsed = json_module.loads(content.strip())
            return {
                'gefunden': True,
                'update_empfohlen': parsed.get('update_empfohlen', False),
                'vorschlag': parsed.get('vorschlag', ''),
                'begruendung': parsed.get('begruendung', ''),
                'quelle': parsed.get('quelle', ''),
                'hinweis': parsed.get('hinweis', '')
            }

    except Exception as e:
        return {
            'gefunden': False,
            'fehler': f'Fehler bei KI-Abfrage: {str(e)}'
        }


def render_visueller_baustein_editor(dok_id: str, volltext: str, bausteine_ids: List[str], vertragstyp: str):
    """
    Visueller Editor f√ºr Textbausteine mit farblicher Hervorhebung und Grenzanpassung.
    - Zeigt den Dokumenttext mit farblich markierten Bausteinen
    - Erm√∂glicht Anpassung der Baustein-Grenzen per Schieberegler
    - Ber√ºcksichtigt Vertragstyp-Templates f√ºr Reihenfolge und Alternativen
    """
    st.markdown("### üé® Visueller Baustein-Editor")

    # Session State f√ºr Editor initialisieren
    editor_key = f"baustein_editor_{dok_id}"
    if editor_key not in st.session_state:
        st.session_state[editor_key] = {
            'aktiver_baustein': None,
            'temp_grenzen': {}  # baustein_id -> {start, end}
        }

    # Bausteine f√ºr dieses Dokument laden und nach Position sortieren
    dok_bausteine = []
    for bid in bausteine_ids:
        if bid in st.session_state.textbausteine:
            dok_bausteine.append(st.session_state.textbausteine[bid])

    dok_bausteine.sort(key=lambda b: b.start_index)

    if not dok_bausteine:
        st.info("Keine Textbausteine f√ºr dieses Dokument vorhanden.")
        return

    # Template-Info anzeigen wenn verf√ºgbar
    template = VERTRAGSTYP_TEMPLATES.get(vertragstyp)
    if template:
        with st.expander(f"üìã Template-Info: {template['name']}", expanded=False):
            st.markdown(f"**{template['beschreibung']}**")
            st.markdown("**Empfohlene Kategorien-Reihenfolge:**")
            for i, kat_info in enumerate(template['kategorien_reihenfolge'], 1):
                pflicht = "‚úÖ Pflicht" if kat_info['pflicht'] else "‚ûñ Optional"
                mehrfach = " (mehrfach m√∂glich)" if kat_info['mehrfach'] else ""
                st.markdown(f"{i}. {kat_info['kategorie']} - {pflicht}{mehrfach}")

    # Farbige Darstellung des Dokuments
    st.markdown("#### üìÑ Dokument mit markierten Bausteinen")

    # HTML f√ºr farbige Darstellung erstellen
    html_parts = []
    last_end = 0

    for i, baustein in enumerate(dok_bausteine):
        farbe = BAUSTEIN_FARBEN[i % len(BAUSTEIN_FARBEN)]
        start = baustein.start_index
        end = baustein.end_index

        # Text vor diesem Baustein (nicht markiert)
        if start > last_end:
            nicht_zugeordnet = volltext[last_end:start]
            if nicht_zugeordnet.strip():
                html_parts.append(f'<span style="background-color: #FFF9C4; padding: 2px;">{nicht_zugeordnet}</span>')

        # Baustein-Text (farbig markiert)
        baustein_text = volltext[start:end]
        # Escape HTML characters
        baustein_text_escaped = baustein_text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('\n', '<br>')
        html_parts.append(
            f'<span style="background-color: {farbe}; padding: 2px 4px; border-radius: 3px; '
            f'border-left: 3px solid {farbe.replace("E", "8").replace("F", "A")};" '
            f'title="{baustein.titel} ({baustein.kategorie})">'
            f'<strong>[{i+1}]</strong> {baustein_text_escaped}</span>'
        )
        last_end = end

    # Text nach dem letzten Baustein
    if last_end < len(volltext):
        rest_text = volltext[last_end:]
        if rest_text.strip():
            html_parts.append(f'<span style="background-color: #FFF9C4; padding: 2px;">{rest_text}</span>')

    # HTML anzeigen
    combined_html = ''.join(html_parts)
    st.markdown(
        f'<div style="max-height: 400px; overflow-y: auto; padding: 10px; '
        f'border: 1px solid #ddd; border-radius: 5px; font-family: monospace; '
        f'white-space: pre-wrap; line-height: 1.6;">{combined_html}</div>',
        unsafe_allow_html=True
    )

    # Legende
    st.markdown("**Legende:**")
    legend_cols = st.columns(len(dok_bausteine) if len(dok_bausteine) <= 6 else 6)
    for i, baustein in enumerate(dok_bausteine[:6]):
        farbe = BAUSTEIN_FARBEN[i % len(BAUSTEIN_FARBEN)]
        with legend_cols[i]:
            st.markdown(
                f'<span style="background-color: {farbe}; padding: 3px 8px; border-radius: 3px;">'
                f'[{i+1}] {baustein.titel[:15]}...</span>',
                unsafe_allow_html=True
            )

    st.markdown("---")

    # Baustein-Bearbeitung
    st.markdown("#### ‚úèÔ∏è Baustein-Grenzen anpassen")

    # Baustein ausw√§hlen
    baustein_options = {f"[{i+1}] {b.titel} ({b.kategorie})": b.baustein_id for i, b in enumerate(dok_bausteine)}
    selected_label = st.selectbox("Baustein ausw√§hlen:", list(baustein_options.keys()), key=f"select_baustein_{dok_id}")
    selected_id = baustein_options[selected_label]
    selected_baustein = st.session_state.textbausteine[selected_id]

    # Index des ausgew√§hlten Bausteins
    baustein_idx = next(i for i, b in enumerate(dok_bausteine) if b.baustein_id == selected_id)

    # Grenzen bestimmen (min/max basierend auf Nachbarn)
    min_start = dok_bausteine[baustein_idx - 1].end_index if baustein_idx > 0 else 0
    max_end = dok_bausteine[baustein_idx + 1].start_index if baustein_idx < len(dok_bausteine) - 1 else len(volltext)

    col1, col2 = st.columns(2)

    with col1:
        st.markdown(f"**Farbe:** ")
        farbe = BAUSTEIN_FARBEN[baustein_idx % len(BAUSTEIN_FARBEN)]
        st.markdown(f'<span style="background-color: {farbe}; padding: 5px 15px; border-radius: 3px;">‚ñ†</span>', unsafe_allow_html=True)
        st.markdown(f"**Kategorie:** {selected_baustein.kategorie}")
        st.markdown(f"**Aktueller Text-Bereich:** Zeichen {selected_baustein.start_index} - {selected_baustein.end_index}")

    with col2:
        st.markdown(f"**Textl√§nge:** {selected_baustein.end_index - selected_baustein.start_index} Zeichen")
        st.markdown(f"**Min. Start:** {min_start} | **Max. Ende:** {max_end}")

    # Schieberegler f√ºr Start
    new_start = st.slider(
        "Start-Position",
        min_value=min_start,
        max_value=selected_baustein.end_index - 10,  # Mindestens 10 Zeichen
        value=selected_baustein.start_index,
        key=f"slider_start_{dok_id}_{selected_id}"
    )

    # Schieberegler f√ºr Ende
    new_end = st.slider(
        "End-Position",
        min_value=new_start + 10,  # Mindestens 10 Zeichen
        max_value=max_end,
        value=selected_baustein.end_index,
        key=f"slider_end_{dok_id}_{selected_id}"
    )

    # Vorschau des neuen Texts
    if new_start != selected_baustein.start_index or new_end != selected_baustein.end_index:
        st.markdown("**üìù Vorschau des angepassten Bausteins:**")
        new_text = volltext[new_start:new_end]
        st.text_area("Neuer Text:", value=new_text, height=100, disabled=True, key=f"preview_{dok_id}_{selected_id}")

        # √Ñnderungen √ºbernehmen
        col_btn1, col_btn2, col_btn3 = st.columns(3)

        with col_btn1:
            if st.button("‚úÖ √Ñnderungen √ºbernehmen", key=f"apply_{dok_id}_{selected_id}", type="primary"):
                # Aktuellen Baustein aktualisieren
                selected_baustein.start_index = new_start
                selected_baustein.end_index = new_end
                selected_baustein.text = volltext[new_start:new_end].strip()
                selected_baustein.aktualisiert_am = datetime.now()
                selected_baustein.text_hash = berechne_text_hash(selected_baustein.text)

                # Angrenzende Bausteine anpassen (kaskadierend)
                if baustein_idx > 0:
                    vorheriger = dok_bausteine[baustein_idx - 1]
                    if vorheriger.end_index > new_start:
                        vorheriger.end_index = new_start
                        vorheriger.text = volltext[vorheriger.start_index:vorheriger.end_index].strip()
                        vorheriger.text_hash = berechne_text_hash(vorheriger.text)

                if baustein_idx < len(dok_bausteine) - 1:
                    naechster = dok_bausteine[baustein_idx + 1]
                    if naechster.start_index < new_end:
                        naechster.start_index = new_end
                        naechster.text = volltext[naechster.start_index:naechster.end_index].strip()
                        naechster.text_hash = berechne_text_hash(naechster.text)

                st.success("‚úÖ √Ñnderungen √ºbernommen!")
                st.rerun()

        with col_btn2:
            if st.button("‚Ü©Ô∏è Zur√ºcksetzen", key=f"reset_{dok_id}_{selected_id}"):
                st.rerun()

    # Baustein l√∂schen
    st.markdown("---")
    st.markdown("#### üóëÔ∏è Baustein l√∂schen")

    with st.expander("‚ö†Ô∏è Baustein l√∂schen (Vorsicht!)", expanded=False):
        st.warning("Das L√∂schen eines Bausteins kann nicht r√ºckg√§ngig gemacht werden!")

        if st.button("üóëÔ∏è Diesen Baustein l√∂schen", key=f"delete_{dok_id}_{selected_id}", type="secondary"):
            # Aus Dokument-Liste entfernen
            dok = st.session_state.vertragsdokumente.get(dok_id)
            if dok and selected_id in dok.baustein_ids:
                dok.baustein_ids.remove(selected_id)

            # Verkettung anpassen
            if selected_baustein.vorgaenger_baustein_id and selected_baustein.vorgaenger_baustein_id in st.session_state.textbausteine:
                st.session_state.textbausteine[selected_baustein.vorgaenger_baustein_id].nachfolger_baustein_id = selected_baustein.nachfolger_baustein_id

            if selected_baustein.nachfolger_baustein_id and selected_baustein.nachfolger_baustein_id in st.session_state.textbausteine:
                st.session_state.textbausteine[selected_baustein.nachfolger_baustein_id].vorgaenger_baustein_id = selected_baustein.vorgaenger_baustein_id

            # Baustein l√∂schen
            del st.session_state.textbausteine[selected_id]
            st.success("Baustein gel√∂scht!")
            st.rerun()

    # Baustein-Sortierung nach Template
    if template:
        st.markdown("---")
        st.markdown("#### üìã Bausteine nach Template sortieren")

        # Pr√ºfe ob Bausteine nach Template sortiert sind
        template_kategorien = [k['kategorie'] for k in template['kategorien_reihenfolge']]
        aktuelle_kategorien = [b.kategorie for b in dok_bausteine]

        # Finde beste Sortierung
        sortierte_bausteine = []
        nicht_zugeordnet_bausteine = dok_bausteine.copy()

        for kat_info in template['kategorien_reihenfolge']:
            kategorie = kat_info['kategorie']
            passende = [b for b in nicht_zugeordnet_bausteine if b.kategorie == kategorie]
            if passende:
                if kat_info['mehrfach']:
                    sortierte_bausteine.extend(passende)
                    for b in passende:
                        nicht_zugeordnet_bausteine.remove(b)
                else:
                    sortierte_bausteine.append(passende[0])
                    nicht_zugeordnet_bausteine.remove(passende[0])

        # Nicht zugeordnete am Ende
        sortierte_bausteine.extend(nicht_zugeordnet_bausteine)

        # Vergleich anzeigen
        st.markdown("**Aktuelle vs. empfohlene Reihenfolge:**")
        col_aktuell, col_empfohlen = st.columns(2)

        with col_aktuell:
            st.markdown("**Aktuelle Reihenfolge:**")
            for i, b in enumerate(dok_bausteine):
                st.markdown(f"{i+1}. {b.kategorie}")

        with col_empfohlen:
            st.markdown("**Nach Template:**")
            for i, b in enumerate(sortierte_bausteine):
                st.markdown(f"{i+1}. {b.kategorie}")

        # Alternativen anzeigen
        st.markdown("---")
        st.markdown("#### üîÑ Baustein-Alternativen")

        for kat_info in template['kategorien_reihenfolge']:
            kategorie = kat_info['kategorie']
            # Suche alle freigegebenen Bausteine dieser Kategorie
            alternativen = [b for b in st.session_state.textbausteine.values()
                          if b.kategorie == kategorie
                          and b.status == TextbausteinStatus.FREIGEGEBEN.value
                          and vertragstyp in b.vertragstypen]

            if len(alternativen) > 1:
                with st.expander(f"üîÑ {kategorie} - {len(alternativen)} Alternativen verf√ºgbar"):
                    for alt in alternativen:
                        col1, col2 = st.columns([3, 1])
                        with col1:
                            st.markdown(f"**{alt.titel}**")
                            st.text(alt.text[:200] + "..." if len(alt.text) > 200 else alt.text)
                        with col2:
                            # Pr√ºfen ob dieser Baustein im Dokument verwendet wird
                            ist_verwendet = alt.baustein_id in bausteine_ids
                            if ist_verwendet:
                                st.success("‚úÖ Verwendet")
                            else:
                                if st.button("‚ûï Verwenden", key=f"use_alt_{dok_id}_{alt.baustein_id}"):
                                    # Ersetze bestehenden Baustein gleicher Kategorie oder f√ºge hinzu
                                    st.info("Alternative wird eingef√ºgt...")
                                    # Hier k√∂nnte man die Logik erweitern


def render_cloud_storage_integration():
    """
    Rendert die Cloud-Storage-Integration f√ºr Dokument-Import.
    Unterst√ºtzt Google Drive, iCloud und Dropbox.
    """
    st.markdown("### ‚òÅÔ∏è Cloud-Storage verbinden")

    # Session State f√ºr Cloud-Verbindungen
    if 'cloud_connections' not in st.session_state:
        st.session_state.cloud_connections = {
            'google_drive': {'connected': False, 'email': '', 'access_token': ''},
            'icloud': {'connected': False, 'email': '', 'access_token': ''},
            'dropbox': {'connected': False, 'email': '', 'access_token': ''}
        }

    # Cloud-Provider ausw√§hlen
    cloud_provider = st.selectbox(
        "Cloud-Anbieter ausw√§hlen:",
        ["üìÅ Google Drive", "‚òÅÔ∏è iCloud", "üì¶ Dropbox"],
        key="cloud_provider_select"
    )

    provider_key = {
        "üìÅ Google Drive": "google_drive",
        "‚òÅÔ∏è iCloud": "icloud",
        "üì¶ Dropbox": "dropbox"
    }[cloud_provider]

    connection = st.session_state.cloud_connections[provider_key]

    # Provider-spezifische Einstellungen
    if provider_key == "google_drive":
        st.markdown("""
        **Google Drive Integration**

        Um Google Drive zu verbinden, ben√∂tigen Sie:
        1. Eine Google Cloud Console App mit aktivierter Drive API
        2. OAuth 2.0 Client-ID und Client-Secret
        """)

        with st.expander("üîß Google Drive Einstellungen", expanded=not connection['connected']):
            col1, col2 = st.columns(2)
            with col1:
                client_id = st.text_input(
                    "Client ID",
                    value=st.session_state.get('gdrive_client_id', ''),
                    type="password",
                    key="gdrive_client_id_input"
                )
            with col2:
                client_secret = st.text_input(
                    "Client Secret",
                    value=st.session_state.get('gdrive_client_secret', ''),
                    type="password",
                    key="gdrive_client_secret_input"
                )

            if st.button("üîó Mit Google Drive verbinden", key="connect_gdrive"):
                if client_id and client_secret:
                    st.session_state.gdrive_client_id = client_id
                    st.session_state.gdrive_client_secret = client_secret
                    # Simuliere OAuth-Flow (in Production: echte OAuth-Implementierung)
                    connection['connected'] = True
                    connection['email'] = "user@gmail.com"
                    st.success("‚úÖ Google Drive erfolgreich verbunden!")
                    st.rerun()
                else:
                    st.error("Bitte Client ID und Client Secret eingeben.")

    elif provider_key == "icloud":
        st.markdown("""
        **iCloud Integration**

        Um iCloud zu verbinden, ben√∂tigen Sie:
        1. Ihre Apple-ID
        2. Ein App-spezifisches Passwort (unter appleid.apple.com erstellen)
        """)

        with st.expander("üîß iCloud Einstellungen", expanded=not connection['connected']):
            col1, col2 = st.columns(2)
            with col1:
                apple_id = st.text_input(
                    "Apple-ID (E-Mail)",
                    value=st.session_state.get('icloud_apple_id', ''),
                    key="icloud_apple_id_input"
                )
            with col2:
                app_password = st.text_input(
                    "App-spezifisches Passwort",
                    value='',
                    type="password",
                    key="icloud_app_password_input"
                )

            if st.button("üîó Mit iCloud verbinden", key="connect_icloud"):
                if apple_id and app_password:
                    st.session_state.icloud_apple_id = apple_id
                    # Simuliere Verbindung
                    connection['connected'] = True
                    connection['email'] = apple_id
                    st.success("‚úÖ iCloud erfolgreich verbunden!")
                    st.rerun()
                else:
                    st.error("Bitte Apple-ID und App-Passwort eingeben.")

    elif provider_key == "dropbox":
        st.markdown("""
        **Dropbox Integration**

        Um Dropbox zu verbinden, ben√∂tigen Sie:
        1. Eine Dropbox App (unter dropbox.com/developers erstellen)
        2. Access Token f√ºr die App
        """)

        with st.expander("üîß Dropbox Einstellungen", expanded=not connection['connected']):
            access_token = st.text_input(
                "Access Token",
                value=st.session_state.get('dropbox_access_token', ''),
                type="password",
                key="dropbox_access_token_input"
            )

            if st.button("üîó Mit Dropbox verbinden", key="connect_dropbox"):
                if access_token:
                    st.session_state.dropbox_access_token = access_token
                    connection['connected'] = True
                    connection['email'] = "dropbox-user"
                    st.success("‚úÖ Dropbox erfolgreich verbunden!")
                    st.rerun()
                else:
                    st.error("Bitte Access Token eingeben.")

    # Wenn verbunden, zeige Dateibrowser
    if connection['connected']:
        st.success(f"‚úÖ Verbunden als: {connection['email']}")

        st.markdown("---")
        st.markdown("### üìÇ Dateien durchsuchen")

        # Simulierte Ordnerstruktur (in Production: echte API-Aufrufe)
        if 'cloud_current_path' not in st.session_state:
            st.session_state.cloud_current_path = "/"

        # Simulierte Dateien basierend auf Provider
        demo_files = {
            "google_drive": [
                {"name": "Vertr√§ge", "type": "folder", "path": "/Vertr√§ge"},
                {"name": "Mustervertrag_Kaufvertrag.docx", "type": "file", "size": "45 KB", "path": "/Mustervertrag_Kaufvertrag.docx"},
                {"name": "AGB_Vorlage.pdf", "type": "file", "size": "120 KB", "path": "/AGB_Vorlage.pdf"},
                {"name": "Datenschutz_Template.rtf", "type": "file", "size": "28 KB", "path": "/Datenschutz_Template.rtf"},
            ],
            "icloud": [
                {"name": "Dokumente", "type": "folder", "path": "/Dokumente"},
                {"name": "Notarvertrag_2024.docx", "type": "file", "size": "67 KB", "path": "/Notarvertrag_2024.docx"},
                {"name": "Vollmacht_Muster.pdf", "type": "file", "size": "89 KB", "path": "/Vollmacht_Muster.pdf"},
            ],
            "dropbox": [
                {"name": "Rechtsdokumente", "type": "folder", "path": "/Rechtsdokumente"},
                {"name": "Kaufvertrag_Vorlage.docx", "type": "file", "size": "52 KB", "path": "/Kaufvertrag_Vorlage.docx"},
                {"name": "√úbergabeprotokoll.rtf", "type": "file", "size": "15 KB", "path": "/√úbergabeprotokoll.rtf"},
            ]
        }

        files = demo_files.get(provider_key, [])

        # Pfad-Navigation
        col_path, col_refresh = st.columns([4, 1])
        with col_path:
            st.markdown(f"**Aktueller Pfad:** `{st.session_state.cloud_current_path}`")
        with col_refresh:
            if st.button("üîÑ", key="refresh_cloud"):
                st.rerun()

        # Dateien anzeigen
        for item in files:
            col1, col2, col3 = st.columns([3, 1, 1])

            with col1:
                if item['type'] == 'folder':
                    if st.button(f"üìÅ {item['name']}", key=f"folder_{item['path']}"):
                        st.session_state.cloud_current_path = item['path']
                        st.rerun()
                else:
                    # Datei-Icon basierend auf Typ
                    ext = item['name'].split('.')[-1].lower()
                    icon = {"docx": "üìÑ", "pdf": "üìï", "rtf": "üìù", "jpg": "üñºÔ∏è", "png": "üñºÔ∏è"}.get(ext, "üìÑ")
                    st.markdown(f"{icon} **{item['name']}**")

            with col2:
                if item['type'] == 'file':
                    st.markdown(f"*{item['size']}*")

            with col3:
                if item['type'] == 'file':
                    if st.button("‚¨áÔ∏è Import", key=f"import_{item['path']}"):
                        # Simuliere Datei-Import
                        st.session_state[f"cloud_import_{item['name']}"] = {
                            "name": item['name'],
                            "provider": provider_key,
                            "path": item['path'],
                            "imported": True
                        }
                        st.success(f"‚úÖ '{item['name']}' wurde importiert!")
                        st.info("üí° Die Datei wird im Demo-Modus simuliert. In der Produktionsversion wird die echte Datei heruntergeladen.")

        # Trennen-Button
        st.markdown("---")
        if st.button(f"üîå {cloud_provider} trennen", key=f"disconnect_{provider_key}"):
            connection['connected'] = False
            connection['email'] = ''
            connection['access_token'] = ''
            st.success("Verbindung getrennt.")
            st.rerun()

    # Verbindungs-Status √úbersicht
    st.markdown("---")
    st.markdown("### üìä Verbindungs-Status")

    status_cols = st.columns(3)
    providers = [
        ("üìÅ Google Drive", "google_drive"),
        ("‚òÅÔ∏è iCloud", "icloud"),
        ("üì¶ Dropbox", "dropbox")
    ]

    for i, (name, key) in enumerate(providers):
        with status_cols[i]:
            conn = st.session_state.cloud_connections[key]
            if conn['connected']:
                st.success(f"{name}\n‚úÖ Verbunden")
            else:
                st.info(f"{name}\n‚ö™ Nicht verbunden")


def notar_vertragsarchiv_view():
    """Hauptansicht f√ºr das Vertragsarchiv - Upload und Verwaltung von Textbausteinen"""
    st.subheader("üìö Vertragsarchiv & Textbausteine")

    notar_id = st.session_state.current_user.user_id

    # Sub-Tabs f√ºr verschiedene Bereiche
    archiv_tabs = st.tabs([
        "üì§ Upload",
        "üìã Textbausteine",
        "üìÑ Hochgeladene Dokumente",
        "‚úÖ Freigaben",
        "üîÑ Updates suchen"
    ])

    # ============ TAB 1: Upload ============
    with archiv_tabs[0]:
        st.markdown("### üì§ Dokument oder Textbaustein hochladen")

        upload_typ = st.radio(
            "Was m√∂chten Sie hochladen?",
            ["üìÑ Komplettes Dokument (Vertrag)", "üìù Einzelnen Textbaustein"],
            horizontal=True
        )

        if upload_typ == "üìÑ Komplettes Dokument (Vertrag)":
            # Upload-Quelle ausw√§hlen
            upload_quelle = st.radio(
                "Dokumentquelle:",
                ["üíª Lokaler Upload", "‚òÅÔ∏è Cloud-Storage"],
                horizontal=True,
                key="upload_quelle_radio"
            )

            if upload_quelle == "üíª Lokaler Upload":
                st.markdown("""
                **Unterst√ºtzte Formate:**
                - Word-Dokumente (.docx)
                - RTF-Dokumente (.rtf)
                - PDF-Dateien (.pdf)
                - Bilder (.jpg, .png) - werden per OCR verarbeitet
                """)

                uploaded_file = st.file_uploader(
                    "Vertragsdokument hochladen",
                    type=['docx', 'rtf', 'pdf', 'jpg', 'jpeg', 'png'],
                    key="archiv_dokument_upload"
                )
            else:
                # Cloud-Storage Integration
                uploaded_file = None
                render_cloud_storage_integration()

            if uploaded_file:
                col1, col2 = st.columns(2)

                with col1:
                    st.markdown(f"**Dateiname:** {uploaded_file.name}")
                    st.markdown(f"**Gr√∂√üe:** {uploaded_file.size / 1024:.1f} KB")

                with col2:
                    vertragstyp = st.selectbox(
                        "Vertragstyp",
                        [vt.value for vt in VertragsTyp],
                        key="upload_vertragstyp"
                    )
                    beschreibung = st.text_input("Beschreibung (optional)")

                # Bestimme Dateityp
                dateityp = uploaded_file.name.split('.')[-1].lower()
                if dateityp in ['jpg', 'jpeg', 'png']:
                    dateityp = 'image'

                # Duplikaterkennung - pr√ºfe ob Dokument bereits existiert
                datei_bytes_temp = uploaded_file.read()
                uploaded_file.seek(0)  # Reset f√ºr sp√§teren Zugriff

                # Berechne Hash des Dateiinhalts
                import hashlib
                datei_hash = hashlib.md5(datei_bytes_temp).hexdigest()

                # Suche nach Duplikaten (gleicher Hash oder gleicher Dateiname)
                duplikat_gefunden = None
                duplikat_typ = None  # 'inhalt' oder 'name'

                for dok_id, dok in st.session_state.vertragsdokumente.items():
                    if dok.notar_id == notar_id:
                        # Pr√ºfe auf identischen Inhalt (Hash)
                        if hasattr(dok, 'datei_bytes') and dok.datei_bytes:
                            vorhandener_hash = hashlib.md5(dok.datei_bytes).hexdigest()
                            if vorhandener_hash == datei_hash:
                                duplikat_gefunden = dok
                                duplikat_typ = 'inhalt'
                                break
                        # Pr√ºfe auf gleichen Dateinamen
                        if dok.dateiname == uploaded_file.name:
                            duplikat_gefunden = dok
                            duplikat_typ = 'name'
                            break

                # Wenn Duplikat gefunden, zeige Optionen
                if duplikat_gefunden:
                    st.warning(f"‚ö†Ô∏è **Duplikat erkannt!**")

                    if duplikat_typ == 'inhalt':
                        st.markdown(f"Ein Dokument mit **identischem Inhalt** existiert bereits:")
                    else:
                        st.markdown(f"Ein Dokument mit **gleichem Dateinamen** existiert bereits:")

                    st.markdown(f"- **Dateiname:** {duplikat_gefunden.dateiname}")
                    st.markdown(f"- **Hochgeladen am:** {duplikat_gefunden.hochgeladen_am.strftime('%d.%m.%Y %H:%M')}")
                    st.markdown(f"- **Vertragstyp:** {duplikat_gefunden.vertragstyp}")

                    # Session State f√ºr Duplikat-Entscheidung
                    duplikat_key = f"duplikat_aktion_{datei_hash[:8]}"

                    col_replace, col_copy, col_cancel = st.columns(3)

                    with col_replace:
                        if st.button("üîÑ Ersetzen", key=f"replace_{datei_hash[:8]}", type="primary"):
                            st.session_state[duplikat_key] = 'ersetzen'
                            st.session_state[f"duplikat_id_{datei_hash[:8]}"] = duplikat_gefunden.dokument_id
                            st.rerun()

                    with col_copy:
                        if st.button("üìã Kopie erstellen", key=f"copy_{datei_hash[:8]}"):
                            st.session_state[duplikat_key] = 'kopie'
                            st.rerun()

                    with col_cancel:
                        if st.button("‚ùå Abbrechen", key=f"cancel_{datei_hash[:8]}"):
                            st.session_state[duplikat_key] = 'abbrechen'
                            st.rerun()

                    # Verarbeite Entscheidung
                    aktion = st.session_state.get(duplikat_key)

                    if aktion == 'ersetzen':
                        # L√∂sche altes Dokument und lade neues hoch
                        altes_dok_id = st.session_state.get(f"duplikat_id_{datei_hash[:8]}")
                        if altes_dok_id and altes_dok_id in st.session_state.vertragsdokumente:
                            del st.session_state.vertragsdokumente[altes_dok_id]

                        datei_bytes = datei_bytes_temp
                        extrahierter_text = extrahiere_text_aus_datei(datei_bytes, dateityp, uploaded_file.name)

                        dokument_id = str(uuid.uuid4())[:8]
                        dokument = VertragsDokument(
                            dokument_id=dokument_id,
                            notar_id=notar_id,
                            dateiname=uploaded_file.name,
                            dateityp=dateityp,
                            dateigroesse=uploaded_file.size,
                            datei_bytes=datei_bytes,
                            volltext=extrahierter_text,
                            vertragstyp=vertragstyp,
                            beschreibung=beschreibung,
                            hochgeladen_von=notar_id,
                            status="Hochgeladen"
                        )

                        st.session_state.vertragsdokumente[dokument_id] = dokument
                        # Aufr√§umen
                        del st.session_state[duplikat_key]
                        if f"duplikat_id_{datei_hash[:8]}" in st.session_state:
                            del st.session_state[f"duplikat_id_{datei_hash[:8]}"]
                        st.success(f"‚úÖ Dokument '{uploaded_file.name}' wurde ersetzt!")
                        st.rerun()

                    elif aktion == 'kopie':
                        datei_bytes = datei_bytes_temp
                        extrahierter_text = extrahiere_text_aus_datei(datei_bytes, dateityp, uploaded_file.name)

                        # F√ºge Kopie-Suffix zum Dateinamen hinzu
                        name_parts = uploaded_file.name.rsplit('.', 1)
                        if len(name_parts) == 2:
                            neuer_name = f"{name_parts[0]}_Kopie.{name_parts[1]}"
                        else:
                            neuer_name = f"{uploaded_file.name}_Kopie"

                        dokument_id = str(uuid.uuid4())[:8]
                        dokument = VertragsDokument(
                            dokument_id=dokument_id,
                            notar_id=notar_id,
                            dateiname=neuer_name,
                            dateityp=dateityp,
                            dateigroesse=uploaded_file.size,
                            datei_bytes=datei_bytes,
                            volltext=extrahierter_text,
                            vertragstyp=vertragstyp,
                            beschreibung=beschreibung,
                            hochgeladen_von=notar_id,
                            status="Hochgeladen"
                        )

                        st.session_state.vertragsdokumente[dokument_id] = dokument
                        del st.session_state[duplikat_key]
                        st.success(f"‚úÖ Kopie '{neuer_name}' wurde erstellt!")
                        st.rerun()

                    elif aktion == 'abbrechen':
                        del st.session_state[duplikat_key]
                        st.info("Upload abgebrochen.")
                        st.rerun()

                else:
                    # Kein Duplikat - normaler Upload
                    if st.button("üì§ Dokument verarbeiten", type="primary", key="upload_doc_btn"):
                        with st.spinner("Dokument wird verarbeitet..."):
                            datei_bytes = datei_bytes_temp

                            # Text extrahieren
                            extrahierter_text = extrahiere_text_aus_datei(datei_bytes, dateityp, uploaded_file.name)

                            # Dokument erstellen
                            dokument_id = str(uuid.uuid4())[:8]
                            dokument = VertragsDokument(
                                dokument_id=dokument_id,
                                notar_id=notar_id,
                                dateiname=uploaded_file.name,
                                dateityp=dateityp,
                                dateigroesse=uploaded_file.size,
                                datei_bytes=datei_bytes,
                                volltext=extrahierter_text,
                                vertragstyp=vertragstyp,
                                beschreibung=beschreibung,
                                hochgeladen_von=notar_id,
                                status="Hochgeladen"
                            )

                            st.session_state.vertragsdokumente[dokument_id] = dokument
                            st.success(f"‚úÖ Dokument '{uploaded_file.name}' wurde hochgeladen!")

                            # Dokument-Upload tracken
                            safe_track_interaktion(
                                interaktions_typ='dokument_upload',
                                details={
                                    'dokument_id': dokument_id,
                                    'dateityp': dateityp,
                                    'vertragstyp': vertragstyp,
                                    'dateigroesse': uploaded_file.size
                                }
                            )

                            # Option: In Bausteine zerlegen
                            if len(extrahierter_text) > 100:
                                st.info("üí° M√∂chten Sie das Dokument in Textbausteine zerlegen?")
                                if st.button("üî® In Bausteine zerlegen", key="zerlege_nach_upload"):
                                    st.session_state[f'zerlege_dokument_{dokument_id}'] = True
                                    st.rerun()

        else:  # Einzelner Textbaustein
            st.markdown("### üìù Einzelnen Textbaustein eingeben")

            col1, col2 = st.columns(2)

            with col1:
                titel = st.text_input("Titel des Bausteins", placeholder="z.B. Kaufpreiszahlung")
                kategorie = st.selectbox(
                    "Kategorie (Regelungsinhalt)",
                    [kat.value for kat in TextbausteinKategorie]
                )

            with col2:
                vertragstypen = st.multiselect(
                    "Verwendbar in Vertragstypen",
                    [vt.value for vt in VertragsTyp],
                    default=[VertragsTyp.KAUFVERTRAG.value]
                )

            baustein_text = st.text_area(
                "Klauseltext",
                height=200,
                placeholder="Geben Sie hier den vollst√§ndigen Klauseltext ein..."
            )

            # Oder aus Datei laden
            st.markdown("**Oder aus Datei laden:**")
            baustein_datei = st.file_uploader(
                "Textbaustein als Datei",
                type=['txt', 'docx'],
                key="baustein_datei_upload"
            )

            if baustein_datei:
                if baustein_datei.name.endswith('.txt'):
                    baustein_text = baustein_datei.read().decode('utf-8')
                elif baustein_datei.name.endswith('.docx'):
                    baustein_text = extrahiere_text_aus_datei(
                        baustein_datei.read(), 'docx', baustein_datei.name
                    )
                st.text_area("Geladener Text:", value=baustein_text, height=150, disabled=True)

            col_btn1, col_btn2 = st.columns(2)

            with col_btn1:
                ki_analyse = st.checkbox("ü§ñ KI-Analyse f√ºr Titel & Zusammenfassung", value=True)

            with col_btn2:
                if st.button("üíæ Textbaustein speichern", type="primary", disabled=not baustein_text):
                    with st.spinner("Baustein wird analysiert..."):
                        # KI-Analyse wenn aktiviert
                        if ki_analyse and baustein_text:
                            analyse = ki_analysiere_textbaustein(baustein_text)
                            if not titel:
                                titel = analyse['titel']
                            zusammenfassung = analyse['zusammenfassung']
                            if not kategorie or kategorie == "Sonstiges":
                                kategorie = analyse['kategorie']
                            ki_generiert = analyse.get('ki_generiert', False)
                        else:
                            zusammenfassung = baustein_text[:150] + "..." if len(baustein_text) > 150 else baustein_text
                            ki_generiert = False

                        # Duplikatpr√ºfung
                        text_hash = berechne_text_hash(baustein_text)
                        aehnliche = finde_aehnliche_bausteine(baustein_text, notar_id)

                        baustein_id = str(uuid.uuid4())[:8]
                        baustein = Textbaustein(
                            baustein_id=baustein_id,
                            notar_id=notar_id,
                            titel=titel or "Unbenannter Baustein",
                            text=baustein_text,
                            zusammenfassung=zusammenfassung,
                            kategorie=kategorie,
                            vertragstypen=vertragstypen,
                            status=TextbausteinStatus.ENTWURF.value,
                            ki_generiert=ki_generiert,
                            ki_kategorisiert=ki_generiert,
                            erstellt_von=notar_id,
                            text_hash=text_hash,
                            aehnliche_bausteine=[a[0] for a in aehnliche[:3]]
                        )

                        st.session_state.textbausteine[baustein_id] = baustein

                        if aehnliche:
                            st.warning(f"‚ö†Ô∏è {len(aehnliche)} √§hnliche Bausteine gefunden! Bitte pr√ºfen Sie unter 'Freigaben'.")
                        else:
                            st.success(f"‚úÖ Textbaustein '{titel}' wurde gespeichert!")

                        st.rerun()

    # ============ TAB 2: Textbausteine-√úbersicht ============
    with archiv_tabs[1]:
        st.markdown("### üìã Alle Textbausteine")

        # Filter
        col1, col2, col3 = st.columns(3)
        with col1:
            filter_status = st.selectbox(
                "Status",
                ["Alle"] + [s.value for s in TextbausteinStatus],
                key="filter_baustein_status"
            )
        with col2:
            filter_kategorie = st.selectbox(
                "Kategorie",
                ["Alle"] + [k.value for k in TextbausteinKategorie],
                key="filter_baustein_kategorie"
            )
        with col3:
            filter_vertragstyp = st.selectbox(
                "Vertragstyp",
                ["Alle"] + [v.value for v in VertragsTyp],
                key="filter_baustein_vertragstyp"
            )

        # Bausteine filtern
        bausteine = [b for b in st.session_state.textbausteine.values() if b.notar_id == notar_id]

        if filter_status != "Alle":
            bausteine = [b for b in bausteine if b.status == filter_status]
        if filter_kategorie != "Alle":
            bausteine = [b for b in bausteine if b.kategorie == filter_kategorie]
        if filter_vertragstyp != "Alle":
            bausteine = [b for b in bausteine if filter_vertragstyp in b.vertragstypen]

        # Statistik
        col1, col2, col3, col4 = st.columns(4)
        alle_bausteine = [b for b in st.session_state.textbausteine.values() if b.notar_id == notar_id]
        with col1:
            st.metric("Gesamt", len(alle_bausteine))
        with col2:
            st.metric("Freigegeben", len([b for b in alle_bausteine if b.status == TextbausteinStatus.FREIGEGEBEN.value]))
        with col3:
            st.metric("Entw√ºrfe", len([b for b in alle_bausteine if b.status == TextbausteinStatus.ENTWURF.value]))
        with col4:
            st.metric("Updates", len([b for b in alle_bausteine if b.status == TextbausteinStatus.AKTUALISIERUNG.value]))

        st.markdown("---")

        if not bausteine:
            st.info("Keine Textbausteine gefunden. Laden Sie Bausteine im Tab 'Upload' hoch.")
        else:
            for baustein in sorted(bausteine, key=lambda x: x.erstellt_am, reverse=True):
                status_icon = {
                    TextbausteinStatus.ENTWURF.value: "üìù",
                    TextbausteinStatus.PRUEFUNG.value: "üîç",
                    TextbausteinStatus.FREIGEGEBEN.value: "‚úÖ",
                    TextbausteinStatus.AKTUALISIERUNG.value: "üîÑ",
                    TextbausteinStatus.ABGELEHNT.value: "‚ùå",
                    TextbausteinStatus.ARCHIVIERT.value: "üì¶"
                }.get(baustein.status, "‚ùì")

                with st.expander(f"{status_icon} {baustein.titel} ({baustein.kategorie})"):
                    col1, col2 = st.columns([2, 1])

                    with col1:
                        st.markdown(f"**Zusammenfassung:** {baustein.zusammenfassung}")
                        st.text_area("Volltext:", value=baustein.text, height=150, disabled=True, key=f"text_{baustein.baustein_id}")
                        st.markdown(f"**Vertragstypen:** {', '.join(baustein.vertragstypen)}")

                    with col2:
                        st.markdown(f"**Status:** {baustein.status}")
                        st.markdown(f"**Erstellt:** {baustein.erstellt_am.strftime('%d.%m.%Y')}")
                        if baustein.ki_generiert:
                            st.markdown("ü§ñ *KI-analysiert*")
                        if baustein.aehnliche_bausteine:
                            st.warning(f"‚ö†Ô∏è {len(baustein.aehnliche_bausteine)} √§hnliche Bausteine")

                        # Aktionen
                        if baustein.status == TextbausteinStatus.ENTWURF.value:
                            if st.button("‚úÖ Freigeben", key=f"freigeben_{baustein.baustein_id}"):
                                baustein.status = TextbausteinStatus.FREIGEGEBEN.value
                                baustein.freigegeben_am = datetime.now()
                                baustein.freigegeben_von = notar_id
                                st.success("Baustein freigegeben!")
                                st.rerun()

                        if st.button("üóëÔ∏è L√∂schen", key=f"loeschen_{baustein.baustein_id}"):
                            del st.session_state.textbausteine[baustein.baustein_id]
                            st.success("Baustein gel√∂scht!")
                            st.rerun()

    # ============ TAB 3: Hochgeladene Dokumente ============
    with archiv_tabs[2]:
        st.markdown("### üìÑ Hochgeladene Vertragsdokumente")

        dokumente = [d for d in st.session_state.vertragsdokumente.values() if d.notar_id == notar_id]

        if not dokumente:
            st.info("Noch keine Dokumente hochgeladen.")
        else:
            for dok in sorted(dokumente, key=lambda x: x.hochgeladen_am, reverse=True):
                with st.expander(f"üìÑ {dok.dateiname} ({dok.vertragstyp})"):
                    col1, col2 = st.columns([2, 1])

                    with col1:
                        st.markdown(f"**Typ:** {dok.dateityp.upper()}")
                        st.markdown(f"**Gr√∂√üe:** {dok.dateigroesse / 1024:.1f} KB")
                        st.markdown(f"**Status:** {dok.status}")
                        if dok.beschreibung:
                            st.markdown(f"**Beschreibung:** {dok.beschreibung}")

                        if dok.volltext:
                            st.text_area("Extrahierter Text:", value=dok.volltext[:1000] + "..." if len(dok.volltext) > 1000 else dok.volltext, height=150, disabled=True, key=f"volltext_preview_{dok.dokument_id}")

                    with col2:
                        st.markdown(f"**Hochgeladen:** {dok.hochgeladen_am.strftime('%d.%m.%Y %H:%M')}")

                        if dok.zerlegt:
                            st.success(f"‚úÖ In {len(dok.baustein_ids)} Bausteine zerlegt")
                            # Button f√ºr visuellen Editor
                            if st.button("üé® Visuellen Editor √∂ffnen", key=f"visual_edit_{dok.dokument_id}"):
                                st.session_state[f"show_visual_editor_{dok.dokument_id}"] = True
                                st.rerun()
                        else:
                            if st.button("üî® In Bausteine zerlegen", key=f"zerlege_{dok.dokument_id}"):
                                with st.spinner("Zerlege Dokument..."):
                                    teile = ki_zerlege_vertrag_in_bausteine(dok.volltext)

                                    for i, teil in enumerate(teile):
                                        analyse = ki_analysiere_textbaustein(teil['text'])
                                        baustein_id = str(uuid.uuid4())[:8]

                                        baustein = Textbaustein(
                                            baustein_id=baustein_id,
                                            notar_id=notar_id,
                                            titel=analyse['titel'],
                                            text=teil['text'],
                                            zusammenfassung=analyse['zusammenfassung'],
                                            kategorie=analyse['kategorie'],
                                            vertragstypen=[dok.vertragstyp],
                                            quelle_dokument_id=dok.dokument_id,
                                            position_im_dokument=teil['position'],
                                            start_index=teil.get('start_index', 0),
                                            end_index=teil.get('end_index', len(teil['text'])),
                                            status=TextbausteinStatus.ENTWURF.value,
                                            ki_generiert=True,
                                            ki_kategorisiert=True,
                                            erstellt_von=notar_id,
                                            text_hash=berechne_text_hash(teil['text'])
                                        )

                                        # Verkette Bausteine
                                        if dok.baustein_ids:
                                            vorheriger_id = dok.baustein_ids[-1]
                                            baustein.vorgaenger_baustein_id = vorheriger_id
                                            if vorheriger_id in st.session_state.textbausteine:
                                                st.session_state.textbausteine[vorheriger_id].nachfolger_baustein_id = baustein_id

                                        st.session_state.textbausteine[baustein_id] = baustein
                                        dok.baustein_ids.append(baustein_id)

                                    dok.zerlegt = True
                                    dok.anzahl_erkannte_klauseln = len(teile)
                                    dok.status = "Verarbeitet"
                                    dok.verarbeitet_am = datetime.now()

                                    st.success(f"‚úÖ {len(teile)} Bausteine extrahiert!")
                                    st.rerun()

                        if st.button("üóëÔ∏è L√∂schen", key=f"dok_loeschen_{dok.dokument_id}"):
                            del st.session_state.vertragsdokumente[dok.dokument_id]
                            st.success("Dokument gel√∂scht!")
                            st.rerun()

                # Visueller Editor anzeigen wenn aktiviert
                if st.session_state.get(f"show_visual_editor_{dok.dokument_id}", False):
                    st.markdown("---")
                    col_close, _ = st.columns([1, 4])
                    with col_close:
                        if st.button("‚ùå Editor schlie√üen", key=f"close_editor_{dok.dokument_id}"):
                            st.session_state[f"show_visual_editor_{dok.dokument_id}"] = False
                            st.rerun()
                    render_visueller_baustein_editor(
                        dok_id=dok.dokument_id,
                        volltext=dok.volltext,
                        bausteine_ids=dok.baustein_ids,
                        vertragstyp=dok.vertragstyp
                    )

    # ============ TAB 4: Freigaben ============
    with archiv_tabs[3]:
        st.markdown("### ‚úÖ Bausteine zur Freigabe")

        entwuerfe = [b for b in st.session_state.textbausteine.values()
                     if b.notar_id == notar_id and b.status == TextbausteinStatus.ENTWURF.value]

        if not entwuerfe:
            st.success("‚úÖ Keine Bausteine zur Freigabe ausstehend.")
        else:
            st.warning(f"‚ö†Ô∏è {len(entwuerfe)} Bausteine warten auf Freigabe")

            for baustein in entwuerfe:
                with st.expander(f"üìù {baustein.titel}"):
                    st.markdown(f"**Kategorie:** {baustein.kategorie}")
                    st.markdown(f"**Zusammenfassung:** {baustein.zusammenfassung}")
                    st.text_area("Text:", value=baustein.text, height=150, disabled=True, key=f"freigabe_text_{baustein.baustein_id}")

                    # √Ñhnliche Bausteine anzeigen
                    if baustein.aehnliche_bausteine:
                        st.markdown("---")
                        st.markdown("**‚ö†Ô∏è √Ñhnliche vorhandene Bausteine:**")
                        for aehnlich_id in baustein.aehnliche_bausteine:
                            aehnlich = st.session_state.textbausteine.get(aehnlich_id)
                            if aehnlich:
                                st.info(f"**{aehnlich.titel}** ({aehnlich.status})")
                                with st.expander("Vergleichen"):
                                    col1, col2 = st.columns(2)
                                    with col1:
                                        st.markdown("**Neuer Baustein:**")
                                        st.text(baustein.text[:500])
                                    with col2:
                                        st.markdown("**Vorhandener Baustein:**")
                                        st.text(aehnlich.text[:500])

                    col1, col2, col3 = st.columns(3)
                    with col1:
                        if st.button("‚úÖ Freigeben", key=f"approve_{baustein.baustein_id}", type="primary"):
                            baustein.status = TextbausteinStatus.FREIGEGEBEN.value
                            baustein.freigegeben_am = datetime.now()
                            baustein.freigegeben_von = notar_id
                            st.success("Freigegeben!")
                            st.rerun()
                    with col2:
                        if st.button("‚ùå Ablehnen", key=f"reject_{baustein.baustein_id}"):
                            baustein.status = TextbausteinStatus.ABGELEHNT.value
                            st.warning("Abgelehnt!")
                            st.rerun()
                    with col3:
                        if baustein.aehnliche_bausteine and st.button("üîó Mit vorhandenem verkn√ºpfen", key=f"link_{baustein.baustein_id}"):
                            # Verkn√ºpfe mit erstem √§hnlichen Baustein
                            baustein.duplikat_von = baustein.aehnliche_bausteine[0]
                            baustein.status = TextbausteinStatus.ARCHIVIERT.value
                            st.info("Als Duplikat markiert und archiviert.")
                            st.rerun()

    # ============ TAB 5: Updates suchen ============
    with archiv_tabs[4]:
        st.markdown("### üîÑ Updates f√ºr Textbausteine suchen")
        st.markdown("Nutzen Sie KI, um zu pr√ºfen, ob Ihre Textbausteine noch aktuell sind.")

        api_key = st.session_state.api_keys.get('openai', '')
        if not api_key:
            st.warning("‚ö†Ô∏è Kein OpenAI API-Key konfiguriert. Bitte unter 'Einstellungen' hinterlegen.")
        else:
            freigegebene = [b for b in st.session_state.textbausteine.values()
                           if b.notar_id == notar_id and b.status == TextbausteinStatus.FREIGEGEBEN.value]

            if not freigegebene:
                st.info("Keine freigegebenen Bausteine vorhanden.")
            else:
                baustein_auswahl = st.selectbox(
                    "Baustein ausw√§hlen",
                    options=freigegebene,
                    format_func=lambda b: f"{b.titel} ({b.kategorie})"
                )

                if baustein_auswahl:
                    st.text_area("Aktueller Text:", value=baustein_auswahl.text, height=150, disabled=True)

                    if st.button("üîç Nach Updates suchen", type="primary"):
                        with st.spinner("KI analysiert den Baustein..."):
                            ergebnis = ki_suche_updates(baustein_auswahl)

                            if ergebnis.get('gefunden') and ergebnis.get('update_empfohlen'):
                                st.warning("üîÑ **Update empfohlen!**")
                                st.markdown(f"**Vorschlag:** {ergebnis.get('vorschlag', '')}")
                                st.markdown(f"**Begr√ºndung:** {ergebnis.get('begruendung', '')}")
                                if ergebnis.get('quelle'):
                                    st.markdown(f"**Quelle:** {ergebnis.get('quelle')}")

                                # Update-Vorschlag speichern
                                baustein_auswahl.ki_update_vorschlag = ergebnis.get('vorschlag', '')
                                baustein_auswahl.ki_update_quelle = ergebnis.get('quelle', '')
                                baustein_auswahl.ki_update_datum = datetime.now()
                                baustein_auswahl.status = TextbausteinStatus.AKTUALISIERUNG.value

                                if st.button("‚úÖ Update √ºbernehmen"):
                                    baustein_auswahl.text = ergebnis.get('vorschlag', baustein_auswahl.text)
                                    baustein_auswahl.version += 1
                                    baustein_auswahl.aktualisiert_am = datetime.now()
                                    baustein_auswahl.status = TextbausteinStatus.FREIGEGEBEN.value
                                    st.success("Update √ºbernommen!")
                                    st.rerun()

                            elif ergebnis.get('gefunden'):
                                st.success(f"‚úÖ {ergebnis.get('hinweis', 'Der Baustein ist aktuell.')}")
                            else:
                                st.error(f"‚ùå {ergebnis.get('fehler', 'Fehler bei der Analyse')}")


def notar_vertragserstellung_view():
    """Ansicht f√ºr die modulare Vertragserstellung aus Textbausteinen"""
    st.subheader("üìù Vertragserstellung")

    notar_id = st.session_state.current_user.user_id

    # Sub-Tabs
    erstellung_tabs = st.tabs([
        "üÜï Neuer Vertrag",
        "üìã Aus Bausteinen",
        "ü§ñ KI-Entwurf",
        "üìë Vorlagen",
        "üìÑ Entw√ºrfe"
    ])

    # ============ TAB 1: Neuer Vertrag ============
    with erstellung_tabs[0]:
        st.markdown("### üÜï Neuen Vertragsentwurf erstellen")

        # Projekt ausw√§hlen
        projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

        if not projekte:
            st.warning("Keine Projekte verf√ºgbar. Bitte erst ein Projekt anlegen.")
            return

        projekt_options = {f"{p.name} ({p.adresse or 'Keine Adresse'})": p.projekt_id for p in projekte}
        selected_projekt_label = st.selectbox("Projekt ausw√§hlen:", list(projekt_options.keys()))
        selected_projekt_id = projekt_options[selected_projekt_label]
        projekt = st.session_state.projekte[selected_projekt_id]

        col1, col2 = st.columns(2)
        with col1:
            entwurf_name = st.text_input("Name des Entwurfs", value=f"Kaufvertrag - {projekt.name}")
            vertragstyp = st.selectbox("Vertragstyp", [vt.value for vt in VertragsTyp])

        with col2:
            st.markdown("**Projekt-Informationen:**")
            st.markdown(f"Adresse: {projekt.adresse or 'Nicht angegeben'}")
            st.markdown(f"Kaufpreis: {projekt.kaufpreis:,.2f} ‚Ç¨")

            kaeufer = [st.session_state.users.get(kid) for kid in projekt.kaeufer_ids]
            verkaeufer = [st.session_state.users.get(vid) for vid in projekt.verkaeufer_ids]
            st.markdown(f"K√§ufer: {', '.join([k.name for k in kaeufer if k])}")
            st.markdown(f"Verk√§ufer: {', '.join([v.name for v in verkaeufer if v])}")

        st.markdown("---")
        st.markdown("**Erstellungsmethode w√§hlen:**")

        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("üìã Aus Bausteinen zusammenstellen", use_container_width=True):
                st.session_state['vertrag_methode'] = 'bausteine'
                st.session_state['vertrag_projekt_id'] = selected_projekt_id
                st.session_state['vertrag_name'] = entwurf_name
                st.session_state['vertrag_typ'] = vertragstyp
                st.rerun()

        with col2:
            if st.button("ü§ñ KI-Entwurf generieren", use_container_width=True):
                st.session_state['vertrag_methode'] = 'ki'
                st.session_state['vertrag_projekt_id'] = selected_projekt_id
                st.session_state['vertrag_name'] = entwurf_name
                st.session_state['vertrag_typ'] = vertragstyp
                st.rerun()

        with col3:
            if st.button("üìë Aus Vorlage erstellen", use_container_width=True):
                st.session_state['vertrag_methode'] = 'vorlage'
                st.session_state['vertrag_projekt_id'] = selected_projekt_id
                st.session_state['vertrag_name'] = entwurf_name
                st.session_state['vertrag_typ'] = vertragstyp
                st.rerun()

    # ============ TAB 2: Aus Bausteinen ============
    with erstellung_tabs[1]:
        st.markdown("### üìã Vertrag aus Textbausteinen zusammenstellen")

        # Pr√ºfe ob Bausteine vorhanden
        freigegebene_bausteine = [b for b in st.session_state.textbausteine.values()
                                   if b.notar_id == notar_id and b.status == TextbausteinStatus.FREIGEGEBEN.value]

        if not freigegebene_bausteine:
            st.warning("Keine freigegebenen Textbausteine verf√ºgbar. Bitte erst Bausteine im Vertragsarchiv anlegen und freigeben.")
            return

        # Vertragstyp Filter
        filter_typ = st.selectbox(
            "Nach Vertragstyp filtern",
            ["Alle"] + [vt.value for vt in VertragsTyp],
            key="baustein_filter_typ"
        )

        if filter_typ != "Alle":
            verfuegbare_bausteine = [b for b in freigegebene_bausteine if filter_typ in b.vertragstypen]
        else:
            verfuegbare_bausteine = freigegebene_bausteine

        # Bausteine nach Kategorie gruppiert
        st.markdown("**Verf√ºgbare Bausteine nach Kategorie:**")

        # Session State f√ºr ausgew√§hlte Bausteine
        if 'ausgewaehlte_bausteine' not in st.session_state:
            st.session_state.ausgewaehlte_bausteine = []

        kategorien = {}
        for b in verfuegbare_bausteine:
            if b.kategorie not in kategorien:
                kategorien[b.kategorie] = []
            kategorien[b.kategorie].append(b)

        col1, col2 = st.columns([1, 1])

        with col1:
            st.markdown("**Bausteine ausw√§hlen:**")
            for kat, bausteine_liste in sorted(kategorien.items()):
                with st.expander(f"{kat} ({len(bausteine_liste)} Bausteine)"):
                    for baustein in bausteine_liste:
                        is_selected = baustein.baustein_id in st.session_state.ausgewaehlte_bausteine
                        if st.checkbox(
                            f"{baustein.titel}",
                            value=is_selected,
                            key=f"select_{baustein.baustein_id}",
                            help=baustein.zusammenfassung
                        ):
                            if baustein.baustein_id not in st.session_state.ausgewaehlte_bausteine:
                                st.session_state.ausgewaehlte_bausteine.append(baustein.baustein_id)
                        else:
                            if baustein.baustein_id in st.session_state.ausgewaehlte_bausteine:
                                st.session_state.ausgewaehlte_bausteine.remove(baustein.baustein_id)

        with col2:
            st.markdown("**Ausgew√§hlte Bausteine (in Reihenfolge):**")

            if not st.session_state.ausgewaehlte_bausteine:
                st.info("Noch keine Bausteine ausgew√§hlt")
            else:
                for i, bid in enumerate(st.session_state.ausgewaehlte_bausteine):
                    baustein = st.session_state.textbausteine.get(bid)
                    if baustein:
                        col_a, col_b = st.columns([3, 1])
                        with col_a:
                            st.markdown(f"{i+1}. **{baustein.titel}**")
                        with col_b:
                            if st.button("üóëÔ∏è", key=f"remove_{bid}"):
                                st.session_state.ausgewaehlte_bausteine.remove(bid)
                                st.rerun()

                st.markdown("---")

                # Vorschau generieren
                if st.button("üëÅÔ∏è Vorschau anzeigen"):
                    st.session_state['zeige_vorschau'] = True

                if st.session_state.get('zeige_vorschau'):
                    st.markdown("### Vertragsvorschau")
                    volltext = ""
                    for bid in st.session_state.ausgewaehlte_bausteine:
                        baustein = st.session_state.textbausteine.get(bid)
                        if baustein:
                            volltext += f"\n\n**{baustein.titel}**\n\n{baustein.text}"

                    st.text_area("Vertragsentwurf:", value=volltext, height=400)

                    # Entwurf speichern
                    projekt_id = st.session_state.get('vertrag_projekt_id')
                    if projekt_id and st.button("üíæ Als Entwurf speichern", type="primary"):
                        entwurf_id = str(uuid.uuid4())[:8]
                        entwurf = Vertragsentwurf(
                            entwurf_id=entwurf_id,
                            notar_id=notar_id,
                            projekt_id=projekt_id,
                            name=st.session_state.get('vertrag_name', 'Neuer Entwurf'),
                            vertragstyp=st.session_state.get('vertrag_typ', VertragsTyp.KAUFVERTRAG.value),
                            volltext=volltext,
                            baustein_ids=st.session_state.ausgewaehlte_bausteine.copy(),
                            status=VertragsentwurfStatus.ENTWURF.value,
                            erstellt_von=notar_id
                        )
                        st.session_state.vertragsentwuerfe[entwurf_id] = entwurf
                        st.session_state.ausgewaehlte_bausteine = []
                        st.session_state['zeige_vorschau'] = False
                        st.success(f"‚úÖ Entwurf '{entwurf.name}' gespeichert!")
                        st.rerun()

    # ============ TAB 3: KI-Entwurf ============
    with erstellung_tabs[2]:
        st.markdown("### ü§ñ Vertragsentwurf mit KI generieren")

        api_key = st.session_state.api_keys.get('openai', '')
        if not api_key:
            st.warning("‚ö†Ô∏è Kein OpenAI API-Key konfiguriert. Bitte unter 'Einstellungen' hinterlegen.")
            return

        # Projekt-Daten laden
        projekt_id = st.session_state.get('vertrag_projekt_id')
        if not projekt_id:
            st.info("Bitte zuerst im Tab 'Neuer Vertrag' ein Projekt und die Methode 'KI-Entwurf' w√§hlen.")
            return

        projekt = st.session_state.projekte.get(projekt_id)
        if not projekt:
            st.error("Projekt nicht gefunden.")
            return

        st.markdown(f"**Projekt:** {projekt.name}")

        # Zus√§tzliche Eingaben
        col1, col2 = st.columns(2)

        with col1:
            kaeufer_wuensche = st.text_area(
                "Besondere W√ºnsche des K√§ufers",
                placeholder="z.B. Ratenzahlung gew√ºnscht, R√ºcktrittsrecht bei Finanzierungsausfall...",
                height=100
            )

        with col2:
            verkaeufer_wuensche = st.text_area(
                "Besondere W√ºnsche des Verk√§ufers",
                placeholder="z.B. √úbergabe erst in 3 Monaten, Inventar soll √ºbernommen werden...",
                height=100
            )

        zusaetzliche_infos = st.text_area(
            "Zus√§tzliche Informationen zum Vertrag",
            placeholder="Weitere Details die im Vertrag ber√ºcksichtigt werden sollen...",
            height=100
        )

        if st.button("ü§ñ Vertragsentwurf generieren", type="primary"):
            with st.spinner("KI generiert Vertragsentwurf... Dies kann einige Sekunden dauern."):
                try:
                    import urllib.request
                    import json as json_module

                    # Parteien-Daten sammeln
                    kaeufer_daten = []
                    for kid in projekt.kaeufer_ids:
                        k = st.session_state.users.get(kid)
                        if k:
                            kaeufer_daten.append(k.name)

                    verkaeufer_daten = []
                    for vid in projekt.verkaeufer_ids:
                        v = st.session_state.users.get(vid)
                        if v:
                            verkaeufer_daten.append(v.name)

                    prompt = f"""Erstelle einen professionellen deutschen Immobilienkaufvertrag im Stil eines Notarvertrags.

VERTRAGSDATEN:
- Kaufobjekt: {projekt.name}
- Adresse: {projekt.adresse or 'Wird noch erg√§nzt'}
- Kaufpreis: {projekt.kaufpreis:,.2f} EUR
- K√§ufer: {', '.join(kaeufer_daten) or 'Wird noch erg√§nzt'}
- Verk√§ufer: {', '.join(verkaeufer_daten) or 'Wird noch erg√§nzt'}

BESONDERE W√úNSCHE K√ÑUFER:
{kaeufer_wuensche or 'Keine besonderen W√ºnsche'}

BESONDERE W√úNSCHE VERK√ÑUFER:
{verkaeufer_wuensche or 'Keine besonderen W√ºnsche'}

ZUS√ÑTZLICHE INFORMATIONEN:
{zusaetzliche_infos or 'Keine zus√§tzlichen Informationen'}

Erstelle einen vollst√§ndigen Kaufvertrag mit folgenden Abschnitten:
1. Pr√§ambel und Erscheinende
2. Kaufgegenstand
3. Kaufpreis und Zahlungsmodalit√§ten
4. Lastenfreistellung
5. Auflassung und Eigentums√ºbertragung
6. Besitz√ºbergang
7. Gew√§hrleistung
8. Kosten und Steuern
9. Vollmachten
10. Schlussbestimmungen

Der Vertrag soll rechtlich pr√§zise, aber verst√§ndlich formuliert sein.
Verwende Platzhalter in eckigen Klammern [PLATZHALTER] f√ºr fehlende Informationen."""

                    request_data = {
                        "model": "gpt-4o",
                        "messages": [{"role": "user", "content": prompt}],
                        "temperature": 0.3,
                        "max_tokens": 4000
                    }

                    req = urllib.request.Request(
                        "https://api.openai.com/v1/chat/completions",
                        data=json_module.dumps(request_data).encode('utf-8'),
                        headers={
                            "Content-Type": "application/json",
                            "Authorization": f"Bearer {api_key}"
                        }
                    )

                    with urllib.request.urlopen(req, timeout=120) as response:
                        result = json_module.loads(response.read().decode('utf-8'))
                        generierter_text = result['choices'][0]['message']['content']

                        # Entwurf erstellen
                        entwurf_id = str(uuid.uuid4())[:8]
                        entwurf = Vertragsentwurf(
                            entwurf_id=entwurf_id,
                            notar_id=notar_id,
                            projekt_id=projekt_id,
                            name=st.session_state.get('vertrag_name', f'KI-Entwurf {projekt.name}'),
                            vertragstyp=st.session_state.get('vertrag_typ', VertragsTyp.KAUFVERTRAG.value),
                            volltext=generierter_text,
                            kaeufer_wuensche=[kaeufer_wuensche] if kaeufer_wuensche else [],
                            verkaeufer_wuensche=[verkaeufer_wuensche] if verkaeufer_wuensche else [],
                            status=VertragsentwurfStatus.ENTWURF.value,
                            ki_generiert=True,
                            ki_prompt=prompt,
                            erstellt_von=notar_id
                        )

                        st.session_state.vertragsentwuerfe[entwurf_id] = entwurf

                        st.success("‚úÖ Vertragsentwurf wurde generiert!")
                        st.markdown("### Generierter Entwurf:")
                        st.text_area("Vertragstext:", value=generierter_text, height=500)

                        st.info("üí° Der Entwurf wurde gespeichert und kann im Tab 'Entw√ºrfe' bearbeitet und freigegeben werden.")

                except Exception as e:
                    st.error(f"Fehler bei der KI-Generierung: {str(e)}")

    # ============ TAB 4: Vorlagen ============
    with erstellung_tabs[3]:
        st.markdown("### üìë Vertragsvorlagen verwalten")

        col1, col2 = st.columns([2, 1])

        with col1:
            vorlagen = [v for v in st.session_state.vertragsvorlagen.values() if v.notar_id == notar_id]

            if not vorlagen:
                st.info("Noch keine Vorlagen erstellt. Speichern Sie einen Entwurf als Vorlage.")
            else:
                for vorlage in vorlagen:
                    with st.expander(f"üìë {vorlage.name} ({vorlage.vertragstyp})"):
                        st.markdown(f"**Beschreibung:** {vorlage.beschreibung or 'Keine Beschreibung'}")
                        st.markdown(f"**Erstellt:** {vorlage.erstellt_am.strftime('%d.%m.%Y')}")
                        st.markdown(f"**Bausteine:** {len(vorlage.baustein_ids)}")
                        st.markdown(f"**Status:** {'‚úÖ Freigegeben' if vorlage.freigegeben else 'üìù Entwurf'}")

                        if st.button("üìÑ Neuen Vertrag aus Vorlage", key=f"use_vorlage_{vorlage.vorlage_id}"):
                            st.session_state['vertrag_vorlage_id'] = vorlage.vorlage_id
                            st.info("Bitte im Tab 'Neuer Vertrag' ein Projekt w√§hlen und 'Aus Vorlage erstellen' klicken.")

                        if st.button("üóëÔ∏è L√∂schen", key=f"del_vorlage_{vorlage.vorlage_id}"):
                            del st.session_state.vertragsvorlagen[vorlage.vorlage_id]
                            st.success("Vorlage gel√∂scht!")
                            st.rerun()

        with col2:
            st.markdown("**Neue Vorlage aus Entwurf:**")

            entwuerfe = [e for e in st.session_state.vertragsentwuerfe.values() if e.notar_id == notar_id]

            if entwuerfe:
                entwurf_auswahl = st.selectbox(
                    "Entwurf ausw√§hlen",
                    options=entwuerfe,
                    format_func=lambda e: e.name
                )

                vorlage_name = st.text_input("Vorlagen-Name", value=f"Vorlage: {entwurf_auswahl.name if entwurf_auswahl else ''}")
                vorlage_beschreibung = st.text_area("Beschreibung", height=100)

                if st.button("üíæ Als Vorlage speichern") and entwurf_auswahl:
                    vorlage_id = str(uuid.uuid4())[:8]
                    vorlage = VertragsVorlage(
                        vorlage_id=vorlage_id,
                        notar_id=notar_id,
                        name=vorlage_name,
                        beschreibung=vorlage_beschreibung,
                        vertragstyp=entwurf_auswahl.vertragstyp,
                        baustein_ids=entwurf_auswahl.baustein_ids.copy(),
                        vorlage_text=entwurf_auswahl.volltext,
                        freigegeben=True,
                        freigegeben_am=datetime.now(),
                        erstellt_von=notar_id
                    )
                    st.session_state.vertragsvorlagen[vorlage_id] = vorlage
                    st.success("‚úÖ Vorlage erstellt!")
                    st.rerun()
            else:
                st.info("Keine Entw√ºrfe verf√ºgbar.")

    # ============ TAB 5: Entw√ºrfe ============
    with erstellung_tabs[4]:
        st.markdown("### üìÑ Meine Vertragsentw√ºrfe")

        entwuerfe = [e for e in st.session_state.vertragsentwuerfe.values() if e.notar_id == notar_id]

        if not entwuerfe:
            st.info("Noch keine Vertragsentw√ºrfe erstellt.")
        else:
            # Status-Filter
            filter_status = st.selectbox(
                "Status filtern",
                ["Alle"] + [s.value for s in VertragsentwurfStatus]
            )

            if filter_status != "Alle":
                entwuerfe = [e for e in entwuerfe if e.status == filter_status]

            for entwurf in sorted(entwuerfe, key=lambda x: x.erstellt_am, reverse=True):
                projekt = st.session_state.projekte.get(entwurf.projekt_id)
                projekt_name = projekt.name if projekt else "Unbekanntes Projekt"

                status_icon = {
                    VertragsentwurfStatus.ENTWURF.value: "üìù",
                    VertragsentwurfStatus.IN_BEARBEITUNG.value: "‚úèÔ∏è",
                    VertragsentwurfStatus.PRUEFUNG.value: "üîç",
                    VertragsentwurfStatus.FREIGEGEBEN.value: "‚úÖ",
                    VertragsentwurfStatus.VERSENDET.value: "üì®",
                    VertragsentwurfStatus.UNTERZEICHNET.value: "‚úçÔ∏è",
                    VertragsentwurfStatus.ARCHIVIERT.value: "üì¶"
                }.get(entwurf.status, "‚ùì")

                with st.expander(f"{status_icon} {entwurf.name} - {projekt_name}"):
                    col1, col2 = st.columns([2, 1])

                    with col1:
                        st.markdown(f"**Vertragstyp:** {entwurf.vertragstyp}")
                        st.markdown(f"**Erstellt:** {entwurf.erstellt_am.strftime('%d.%m.%Y %H:%M')}")
                        if entwurf.ki_generiert:
                            st.markdown("ü§ñ *KI-generiert*")

                        # Bearbeitbarer Text
                        neuer_text = st.text_area(
                            "Vertragstext:",
                            value=entwurf.volltext,
                            height=300,
                            key=f"edit_{entwurf.entwurf_id}"
                        )

                        if neuer_text != entwurf.volltext:
                            if st.button("üíæ √Ñnderungen speichern", key=f"save_{entwurf.entwurf_id}"):
                                entwurf.volltext = neuer_text
                                entwurf.aktualisiert_am = datetime.now()
                                entwurf.version += 1
                                st.success("√Ñnderungen gespeichert!")
                                st.rerun()

                    with col2:
                        st.markdown(f"**Status:** {entwurf.status}")
                        st.markdown(f"**Version:** {entwurf.version}")

                        # Status-Aktionen
                        if entwurf.status == VertragsentwurfStatus.ENTWURF.value:
                            if st.button("‚úÖ Freigeben", key=f"approve_entwurf_{entwurf.entwurf_id}", type="primary"):
                                entwurf.status = VertragsentwurfStatus.FREIGEGEBEN.value
                                entwurf.freigegeben_am = datetime.now()
                                entwurf.freigegeben_von = notar_id
                                st.success("Entwurf freigegeben!")
                                st.rerun()

                        if entwurf.status == VertragsentwurfStatus.FREIGEGEBEN.value:
                            st.markdown("**An Beteiligte versenden:**")

                            if projekt:
                                empfaenger = []
                                for kid in projekt.kaeufer_ids:
                                    k = st.session_state.users.get(kid)
                                    if k:
                                        empfaenger.append((kid, f"K√§ufer: {k.name}"))
                                for vid in projekt.verkaeufer_ids:
                                    v = st.session_state.users.get(vid)
                                    if v:
                                        empfaenger.append((vid, f"Verk√§ufer: {v.name}"))
                                if projekt.makler_id:
                                    m = st.session_state.users.get(projekt.makler_id)
                                    if m:
                                        empfaenger.append((projekt.makler_id, f"Makler: {m.name}"))

                                for user_id, label in empfaenger:
                                    if st.button(f"üì® {label}", key=f"send_{entwurf.entwurf_id}_{user_id}"):
                                        create_notification(
                                            user_id=user_id,
                                            titel="üìú Neuer Vertragsentwurf",
                                            nachricht=f"Ein neuer Vertragsentwurf '{entwurf.name}' steht f√ºr Sie bereit."
                                        )
                                        entwurf.versendet_an.append(user_id)
                                        entwurf.versendet_am = datetime.now()
                                        entwurf.status = VertragsentwurfStatus.VERSENDET.value
                                        st.success(f"An {label} gesendet!")
                                        st.rerun()

                        if st.button("üóëÔ∏è L√∂schen", key=f"del_entwurf_{entwurf.entwurf_id}"):
                            del st.session_state.vertragsentwuerfe[entwurf.entwurf_id]
                            st.success("Entwurf gel√∂scht!")
                            st.rerun()


def notar_checklisten_view():
    """Notarielle Checklisten-Verwaltung"""
    st.subheader("üìù Notarielle Checklisten")

    notar_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    if not projekte:
        st.info("Noch keine Projekte zugewiesen.")
        return

    # Projekt ausw√§hlen
    projekt_options = {f"{p.name} (ID: {p.projekt_id})": p.projekt_id for p in projekte}
    selected_projekt_label = st.selectbox("Projekt ausw√§hlen:", list(projekt_options.keys()))
    selected_projekt_id = projekt_options[selected_projekt_label]
    selected_projekt = st.session_state.projekte[selected_projekt_id]

    st.markdown("---")

    # Checklisten f√ºr dieses Projekt anzeigen
    projekt_checklists = [c for c in st.session_state.notar_checklists.values()
                         if c.projekt_id == selected_projekt_id]

    # Neue Checkliste erstellen
    with st.expander("‚ûï Neue Checkliste erstellen", expanded=len(projekt_checklists) == 0):
        col1, col2 = st.columns(2)
        with col1:
            checklist_typ = st.selectbox("Checklisten-Typ:", [t.value for t in ChecklistType])
        with col2:
            # Partei ausw√§hlen (K√§ufer oder Verk√§ufer)
            parteien = []
            for kid in selected_projekt.kaeufer_ids:
                kaeufer = st.session_state.users.get(kid)
                if kaeufer:
                    parteien.append(f"K√§ufer: {kaeufer.name}")
            for vid in selected_projekt.verkaeufer_ids:
                verkaeufer = st.session_state.users.get(vid)
                if verkaeufer:
                    parteien.append(f"Verk√§ufer: {verkaeufer.name}")

            if parteien:
                partei = st.selectbox("F√ºr Partei:", parteien)
            else:
                st.warning("Keine Parteien im Projekt vorhanden")
                partei = None

        if st.button("Checkliste erstellen") and partei:
            checklist_id = f"checklist_{len(st.session_state.notar_checklists)}"
            new_checklist = NotarChecklist(
                checklist_id=checklist_id,
                projekt_id=selected_projekt_id,
                checklist_typ=checklist_typ,
                partei=partei
            )
            st.session_state.notar_checklists[checklist_id] = new_checklist
            st.success(f"Checkliste '{checklist_typ}' f√ºr {partei} erstellt!")
            st.rerun()

    st.markdown("---")

    # Bestehende Checklisten anzeigen
    if projekt_checklists:
        st.markdown("### Bestehende Checklisten")

        for checklist in projekt_checklists:
            with st.expander(f"üìã {checklist.checklist_typ} - {checklist.partei}", expanded=False):
                render_checklist_form(checklist)
    else:
        st.info("Noch keine Checklisten f√ºr dieses Projekt erstellt.")

def notar_mitarbeiter_view():
    """Mitarbeiter-Verwaltung f√ºr Notar"""
    st.subheader("üë• Mitarbeiter-Verwaltung")

    notar_id = st.session_state.current_user.user_id

    # Bestehende Mitarbeiter anzeigen
    mitarbeiter = [m for m in st.session_state.notar_mitarbeiter.values() if m.notar_id == notar_id]

    if mitarbeiter:
        st.markdown("### üë§ Meine Mitarbeiter")

        for ma in mitarbeiter:
            status_icon = "‚úÖ" if ma.aktiv else "‚ùå"
            with st.expander(f"{status_icon} {ma.name} - {ma.rolle}", expanded=False):
                col1, col2 = st.columns(2)

                with col1:
                    st.write(f"**E-Mail:** {ma.email}")
                    st.write(f"**Rolle:** {ma.rolle}")
                    st.write(f"**Status:** {'Aktiv' if ma.aktiv else 'Inaktiv'}")
                    st.write(f"**Erstellt am:** {ma.created_at.strftime('%d.%m.%Y')}")

                with col2:
                    st.write("**Berechtigungen:**")
                    st.write(f"{'‚úÖ' if ma.kann_checklisten_bearbeiten else '‚ùå'} Checklisten bearbeiten")
                    st.write(f"{'‚úÖ' if ma.kann_dokumente_freigeben else '‚ùå'} Dokumente freigeben")
                    st.write(f"{'‚úÖ' if ma.kann_termine_verwalten else '‚ùå'} Termine verwalten")
                    st.write(f"{'‚úÖ' if ma.kann_finanzierung_sehen else '‚ùå'} Finanzierung einsehen")

                st.markdown("---")

                # Zugewiesene Projekte
                st.markdown("**Zugewiesene Projekte:**")
                if ma.projekt_ids:
                    for projekt_id in ma.projekt_ids:
                        projekt = st.session_state.projekte.get(projekt_id)
                        if projekt:
                            st.write(f"üèòÔ∏è {projekt.name}")
                else:
                    st.info("Keine Projekte zugewiesen")

                st.markdown("---")

                # Mitarbeiter bearbeiten
                col1, col2, col3 = st.columns(3)
                with col1:
                    if st.button("‚úèÔ∏è Berechtigungen √§ndern", key=f"edit_ma_{ma.mitarbeiter_id}"):
                        st.session_state[f"edit_mitarbeiter_{ma.mitarbeiter_id}"] = True
                        st.rerun()
                with col2:
                    if ma.aktiv:
                        if st.button("‚ùå Deaktivieren", key=f"deact_ma_{ma.mitarbeiter_id}"):
                            ma.aktiv = False
                            st.session_state.notar_mitarbeiter[ma.mitarbeiter_id] = ma
                            st.success(f"{ma.name} wurde deaktiviert.")
                            st.rerun()
                    else:
                        if st.button("‚úÖ Aktivieren", key=f"act_ma_{ma.mitarbeiter_id}"):
                            ma.aktiv = True
                            st.session_state.notar_mitarbeiter[ma.mitarbeiter_id] = ma
                            st.success(f"{ma.name} wurde aktiviert.")
                            st.rerun()
                with col3:
                    if st.button("üóëÔ∏è L√∂schen", key=f"del_ma_{ma.mitarbeiter_id}"):
                        del st.session_state.notar_mitarbeiter[ma.mitarbeiter_id]
                        st.success(f"{ma.name} wurde gel√∂scht.")
                        st.rerun()

                # Berechtigungen √§ndern (Modal)
                if st.session_state.get(f"edit_mitarbeiter_{ma.mitarbeiter_id}", False):
                    st.markdown("---")
                    st.markdown("#### Berechtigungen √§ndern")

                    with st.form(f"edit_form_{ma.mitarbeiter_id}"):
                        neue_rolle = st.selectbox("Rolle:", [r.value for r in NotarMitarbeiterRolle],
                                                 index=[r.value for r in NotarMitarbeiterRolle].index(ma.rolle) if ma.rolle in [r.value for r in NotarMitarbeiterRolle] else 0)

                        kann_checklisten = st.checkbox("Checklisten bearbeiten", value=ma.kann_checklisten_bearbeiten)
                        kann_dokumente = st.checkbox("Dokumente freigeben", value=ma.kann_dokumente_freigeben)
                        kann_termine = st.checkbox("Termine verwalten", value=ma.kann_termine_verwalten)
                        kann_finanzierung = st.checkbox("Finanzierung einsehen", value=ma.kann_finanzierung_sehen)

                        # Projekte zuweisen
                        st.markdown("**Projekte zuweisen:**")
                        alle_projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]
                        projekt_options = {p.name: p.projekt_id for p in alle_projekte}

                        zugewiesene_projekte = st.multiselect(
                            "Projekte ausw√§hlen:",
                            options=list(projekt_options.keys()),
                            default=[p.name for p in alle_projekte if p.projekt_id in ma.projekt_ids]
                        )

                        col1, col2 = st.columns(2)
                        with col1:
                            if st.form_submit_button("üíæ Speichern", type="primary"):
                                ma.rolle = neue_rolle
                                ma.kann_checklisten_bearbeiten = kann_checklisten
                                ma.kann_dokumente_freigeben = kann_dokumente
                                ma.kann_termine_verwalten = kann_termine
                                ma.kann_finanzierung_sehen = kann_finanzierung
                                ma.projekt_ids = [projekt_options[p_name] for p_name in zugewiesene_projekte]

                                st.session_state.notar_mitarbeiter[ma.mitarbeiter_id] = ma
                                st.session_state[f"edit_mitarbeiter_{ma.mitarbeiter_id}"] = False
                                st.success("Berechtigungen aktualisiert!")
                                st.rerun()

                        with col2:
                            if st.form_submit_button("‚ùå Abbrechen"):
                                st.session_state[f"edit_mitarbeiter_{ma.mitarbeiter_id}"] = False
                                st.rerun()

        st.markdown("---")
    else:
        st.info("Noch keine Mitarbeiter angelegt.")

    # Neuen Mitarbeiter hinzuf√ºgen
    st.markdown("### ‚ûï Neuen Mitarbeiter hinzuf√ºgen")

    with st.form("neuer_mitarbeiter"):
        col1, col2 = st.columns(2)

        with col1:
            ma_name = st.text_input("Name*")
            ma_email = st.text_input("E-Mail*")
            ma_passwort = st.text_input("Passwort*", type="password")

        with col2:
            ma_rolle = st.selectbox("Rolle*", [r.value for r in NotarMitarbeiterRolle])

            # Vordefinierte Berechtigungen basierend auf Rolle
            if ma_rolle == NotarMitarbeiterRolle.VOLLZUGRIFF.value:
                default_checklisten = True
                default_dokumente = True
                default_termine = True
                default_finanzierung = True
            elif ma_rolle == NotarMitarbeiterRolle.SACHBEARBEITER.value:
                default_checklisten = True
                default_dokumente = False
                default_termine = True
                default_finanzierung = False
            elif ma_rolle == NotarMitarbeiterRolle.CHECKLISTEN_VERWALTER.value:
                default_checklisten = True
                default_dokumente = False
                default_termine = False
                default_finanzierung = False
            else:  # NUR_LESEN
                default_checklisten = False
                default_dokumente = False
                default_termine = False
                default_finanzierung = False

        st.markdown("**Berechtigungen:**")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            kann_checklisten = st.checkbox("Checklisten bearbeiten", value=default_checklisten, key="new_ma_checklisten")
        with col2:
            kann_dokumente = st.checkbox("Dokumente freigeben", value=default_dokumente, key="new_ma_dokumente")
        with col3:
            kann_termine = st.checkbox("Termine verwalten", value=default_termine, key="new_ma_termine")
        with col4:
            kann_finanzierung = st.checkbox("Finanzierung einsehen", value=default_finanzierung, key="new_ma_finanzierung")

        # Projekte zuweisen
        st.markdown("**Projekte zuweisen (optional):**")
        alle_projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]
        if alle_projekte:
            projekt_options = {p.name: p.projekt_id for p in alle_projekte}
            zugewiesene_projekte = st.multiselect("Projekte ausw√§hlen:", list(projekt_options.keys()))
        else:
            zugewiesene_projekte = []
            st.info("Noch keine Projekte vorhanden")

        if st.form_submit_button("‚ûï Mitarbeiter hinzuf√ºgen", type="primary"):
            if ma_name and ma_email and ma_passwort:
                mitarbeiter_id = f"notarma_{len(st.session_state.notar_mitarbeiter)}"

                neuer_mitarbeiter = NotarMitarbeiter(
                    mitarbeiter_id=mitarbeiter_id,
                    notar_id=notar_id,
                    name=ma_name,
                    email=ma_email,
                    password_hash=hash_password(ma_passwort),
                    rolle=ma_rolle,
                    kann_checklisten_bearbeiten=kann_checklisten,
                    kann_dokumente_freigeben=kann_dokumente,
                    kann_termine_verwalten=kann_termine,
                    kann_finanzierung_sehen=kann_finanzierung,
                    projekt_ids=[projekt_options[p_name] for p_name in zugewiesene_projekte] if alle_projekte else []
                )

                st.session_state.notar_mitarbeiter[mitarbeiter_id] = neuer_mitarbeiter
                st.success(f"‚úÖ Mitarbeiter {ma_name} wurde erfolgreich hinzugef√ºgt!")
                st.info(f"üîë Login: {ma_email} / {ma_passwort}")
                st.rerun()
            else:
                st.error("Bitte f√ºllen Sie alle Pflichtfelder aus!")

def notar_finanzierungsnachweise():
    """Finanzierungsnachweise f√ºr Notar"""
    st.subheader("üí∞ Finanzierungsnachweise")

    notar_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    if not projekte:
        st.info("Noch keine Projekte zugewiesen.")
        return

    for projekt in projekte:
        st.markdown(f"### üèòÔ∏è {projekt.name}")

        # Angenommene Finanzierungsangebote suchen
        finanzierungen = [o for o in st.session_state.financing_offers.values()
                         if o.projekt_id == projekt.projekt_id
                         and o.status == FinanzierungsStatus.ANGENOMMEN.value]

        if finanzierungen:
            for offer in finanzierungen:
                finanzierer = st.session_state.users.get(offer.finanzierer_id)
                finanzierer_name = finanzierer.name if finanzierer else "Unbekannt"

                icon = "‚≠ê" if offer.fuer_notar_markiert else "‚úÖ"

                with st.expander(f"{icon} Finanzierung von {finanzierer_name}", expanded=offer.fuer_notar_markiert):
                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("Darlehensbetrag", f"{format_euro(offer.darlehensbetrag)} ‚Ç¨")
                        st.metric("Zinssatz", f"{offer.zinssatz:.2f} %")
                    with col2:
                        st.metric("Monatliche Rate", f"{format_euro(offer.monatliche_rate)} ‚Ç¨")
                        st.metric("Angenommen am", offer.accepted_at.strftime("%d.%m.%Y"))

                    if offer.fuer_notar_markiert:
                        st.success("‚≠ê Als offizieller Finanzierungsnachweis markiert")

                    if offer.pdf_data:
                        st.download_button(
                            "üì• Finanzierungsangebot als PDF",
                            offer.pdf_data,
                            file_name=f"Finanzierung_{projekt.name}.pdf",
                            mime="application/pdf",
                            key=f"notar_fin_{offer.offer_id}"
                        )
        else:
            st.info("Noch keine Finanzierung gesichert.")

        st.markdown("---")

def notar_dokumenten_freigaben():
    """Dokumenten-Freigaben f√ºr Notar"""
    st.subheader("üìÑ Dokumenten-Freigaben")

    notar_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    if not projekte:
        st.info("Noch keine Projekte zugewiesen.")
        return

    for projekt in projekte:
        st.markdown(f"### üèòÔ∏è {projekt.name}")

        # Wirtschaftsdaten mit Freigabe
        freigegeben_docs = [d for d in st.session_state.wirtschaftsdaten.values()
                           if d.kaeufer_id in projekt.kaeufer_ids and d.freigegeben_fuer_notar]

        if freigegeben_docs:
            st.success(f"‚úÖ {len(freigegeben_docs)} freigegebene Wirtschaftsdaten-Dokumente")

            for doc in freigegeben_docs:
                kaeufer = st.session_state.users.get(doc.kaeufer_id)
                kaeufer_name = kaeufer.name if kaeufer else "Unbekannt"

                col1, col2 = st.columns([3, 1])
                with col1:
                    st.write(f"üìÑ {doc.filename} (von {kaeufer_name})")
                with col2:
                    st.download_button(
                        "üì•",
                        doc.pdf_data,
                        file_name=doc.filename,
                        key=f"notar_doc_{doc.doc_id}"
                    )
        else:
            st.info("Noch keine Dokumente freigegeben.")

        # NEU: Dokumenten-Versionierung anzeigen
        with st.expander("üìö Dokumentenversionen & History", expanded=False):
            # Alle Dokument-IDs f√ºr dieses Projekt sammeln
            dok_ids = [d.doc_id for d in st.session_state.wirtschaftsdaten.values()
                      if d.kaeufer_id in projekt.kaeufer_ids]
            if dok_ids:
                for dok_id in dok_ids:
                    render_dokument_versionen(dok_id, UserRole.NOTAR.value)
            else:
                st.info("Keine Dokumente mit Versionierung vorhanden.")

        st.markdown("---")


def notar_kaufvertrag_generator():
    """KI-gest√ºtzter Kaufvertragsentwurf-Generator"""
    st.subheader("üìú Kaufvertragsentwurf-Generator")

    notar_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    if not projekte:
        st.info("Noch keine Projekte zugewiesen.")
        return

    # Projekt ausw√§hlen
    projekt_namen = {p.projekt_id: p.name for p in projekte}
    selected_projekt_id = st.selectbox(
        "Projekt ausw√§hlen",
        options=list(projekt_namen.keys()),
        format_func=lambda x: projekt_namen[x],
        key="vertrag_projekt_select"
    )

    if not selected_projekt_id:
        return

    projekt = st.session_state.projekte.get(selected_projekt_id)

    # Tabs f√ºr verschiedene Funktionen
    vertrag_tabs = st.tabs([
        "üìä Daten√ºbersicht",
        "ü§ñ KI-Vertrag generieren",
        "üìù Vertrag bearbeiten",
        "üì§ Vertrag versenden"
    ])

    with vertrag_tabs[0]:
        render_vertrag_datenuebersicht(projekt)

    with vertrag_tabs[1]:
        render_ki_vertrag_generator(projekt)

    with vertrag_tabs[2]:
        render_vertrag_editor(projekt)

    with vertrag_tabs[3]:
        render_vertrag_versenden(projekt)


def render_vertrag_datenuebersicht(projekt):
    """Zeigt alle gesammelten Daten f√ºr den Kaufvertrag"""
    st.markdown("### üìä Gesammelte Vertragsdaten")

    # Verk√§ufer-Daten
    st.markdown("#### üë§ Verk√§ufer")
    verkaeufer_list = []
    for vid in projekt.verkaeufer_ids:
        v = st.session_state.users.get(vid)
        if v:
            verkaeufer_list.append(v)

    if verkaeufer_list:
        for verkaeufer in verkaeufer_list:
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Name:** {verkaeufer.name}")
                st.write(f"**E-Mail:** {verkaeufer.email}")
            with col2:
                personal_key = f"personal_{verkaeufer.user_id}"
                if personal_key in st.session_state:
                    pd = st.session_state[personal_key]
                    st.write(f"**Geburtsdatum:** {pd.get('geburtsdatum', 'N/A')}")
                    st.write(f"**Adresse:** {pd.get('strasse', '')} {pd.get('hausnummer', '')}, {pd.get('plz', '')} {pd.get('ort', '')}")
                else:
                    st.warning("‚ö†Ô∏è Personalausweis nicht erfasst")
    else:
        st.warning("‚ö†Ô∏è Kein Verk√§ufer zugewiesen")

    st.markdown("---")

    # K√§ufer-Daten
    st.markdown("#### üë• K√§ufer")
    for kaeufer_id in projekt.kaeufer_ids:
        kaeufer = st.session_state.users.get(kaeufer_id)
        if kaeufer:
            col1, col2 = st.columns(2)
            with col1:
                st.write(f"**Name:** {kaeufer.name}")
                st.write(f"**E-Mail:** {kaeufer.email}")
            with col2:
                personal_key = f"personal_{kaeufer.user_id}"
                if personal_key in st.session_state:
                    pd = st.session_state[personal_key]
                    st.write(f"**Geburtsdatum:** {pd.get('geburtsdatum', 'N/A')}")
                    st.write(f"**Adresse:** {pd.get('strasse', '')} {pd.get('hausnummer', '')}, {pd.get('plz', '')} {pd.get('ort', '')}")
                else:
                    st.warning("‚ö†Ô∏è Personalausweis nicht erfasst")

    st.markdown("---")

    # Objekt-Daten
    st.markdown("#### üè† Objektdaten")
    expose = st.session_state.expose_data.get(projekt.projekt_id)
    if expose:
        col1, col2 = st.columns(2)
        with col1:
            st.write(f"**Objekttitel:** {expose.objekttitel or 'N/A'}")
            st.write(f"**Adresse:** {expose.strasse} {expose.hausnummer}, {expose.plz} {expose.ort}")
            st.write(f"**Objektart:** {expose.objektart}")
            st.write(f"**Wohnfl√§che:** {expose.wohnflaeche} m¬≤")
        with col2:
            st.write(f"**Kaufpreis:** {format_euro(expose.kaufpreis)} ‚Ç¨" if expose.kaufpreis else "**Kaufpreis:** N/A")
            st.write(f"**Grundst√ºcksfl√§che:** {expose.grundstuecksflaeche} m¬≤" if expose.grundstuecksflaeche else "")
            st.write(f"**Baujahr:** {expose.baujahr}" if expose.baujahr else "")
            st.write(f"**Zimmer:** {expose.anzahl_zimmer}" if expose.anzahl_zimmer else "")
    else:
        st.warning("‚ö†Ô∏è Keine Expos√©-Daten vorhanden")

    st.markdown("---")

    # Makler-Daten
    st.markdown("#### üè¢ Makler")
    makler = st.session_state.users.get(projekt.makler_id)
    if makler:
        st.write(f"**Name:** {makler.name}")
        st.write(f"**E-Mail:** {makler.email}")
        profile = st.session_state.makler_profiles.get(projekt.makler_id)
        if profile:
            st.write(f"**Firma:** {profile.get('firma', 'N/A')}")
            st.write(f"**Provision:** {profile.get('provision', 'N/A')}")

    st.markdown("---")

    # Finanzierung
    st.markdown("#### üí∞ Finanzierung")
    angebote = [o for o in st.session_state.financing_offers.values()
                if o.projekt_id == projekt.projekt_id and o.status == "Angenommen"]
    if angebote:
        for angebot in angebote:
            st.success(f"‚úÖ Finanzierung gesichert: {format_euro(angebot.betrag)} ‚Ç¨ bei {angebot.zinssatz}% Zinsen")
    else:
        st.warning("‚ö†Ô∏è Keine angenommene Finanzierung")

    # Vollst√§ndigkeitscheck
    st.markdown("---")
    st.markdown("### ‚úÖ Vollst√§ndigkeitspr√ºfung")

    checks = {
        "Verk√§ufer erfasst": len(verkaeufer_list) > 0,
        "Verk√§ufer Ausweis": all(f"personal_{v.user_id}" in st.session_state for v in verkaeufer_list) if verkaeufer_list else False,
        "K√§ufer erfasst": len(projekt.kaeufer_ids) > 0,
        "K√§ufer Ausweis": all(f"personal_{kid}" in st.session_state for kid in projekt.kaeufer_ids),
        "Objektdaten vorhanden": expose is not None,
        "Kaufpreis definiert": expose.kaufpreis > 0 if expose else False,
        "Finanzierung gesichert": len(angebote) > 0,
    }

    for check_name, check_result in checks.items():
        if check_result:
            st.write(f"‚úÖ {check_name}")
        else:
            st.write(f"‚ùå {check_name}")

    vollstaendig = all(checks.values())
    if vollstaendig:
        st.success("üéâ Alle Daten vollst√§ndig!")
    else:
        st.warning("‚ö†Ô∏è Bitte vervollst√§ndigen Sie die fehlenden Daten.")


def render_ki_vertrag_generator(projekt):
    """KI-gest√ºtzte Vertragsgenerierung"""
    st.markdown("### ü§ñ KI-Kaufvertragsentwurf generieren")

    api_key = None
    api_type = None

    api_keys = st.session_state.get('api_keys', {})
    if api_keys.get('openai'):
        api_key = api_keys['openai']
        api_type = "openai"
    elif api_keys.get('anthropic'):
        api_key = api_keys['anthropic']
        api_type = "anthropic"

    if not api_key:
        st.warning("‚ö†Ô∏è Kein API-Key konfiguriert. Bitte hinterlegen Sie einen OpenAI oder Anthropic API-Key in den Einstellungen.")
        st.info("üí° Alternativ k√∂nnen Sie einen Vertrag manuell im Tab 'Vertrag bearbeiten' erstellen.")
        return

    st.success(f"‚úÖ API-Key konfiguriert ({api_type.upper()})")

    verkaeufer_list = [st.session_state.users.get(vid) for vid in projekt.verkaeufer_ids if st.session_state.users.get(vid)]
    verkaeufer = verkaeufer_list[0] if verkaeufer_list else None
    kaeufer_list = [st.session_state.users.get(kid) for kid in projekt.kaeufer_ids]
    expose = st.session_state.expose_data.get(projekt.projekt_id)
    makler = st.session_state.users.get(projekt.makler_id)

    st.markdown("#### ‚öôÔ∏è Vertragsoptionen")

    col1, col2 = st.columns(2)
    with col1:
        include_ruecktrittsrecht = st.checkbox("R√ºcktrittsrecht bei Finanzierungsvorbehalt", value=True)
        include_gewaehrleistung = st.checkbox("Gew√§hrleistungsausschluss (gebraucht)", value=True)
        include_besitzuebergang = st.checkbox("Besitz√ºbergangsklausel", value=True)
    with col2:
        include_auflassung = st.checkbox("Auflassungsvormerkung", value=True)
        include_erschliessungskosten = st.checkbox("Regelung Erschlie√üungskosten", value=True)
        include_maklerklausel = st.checkbox("Maklerklausel", value=makler is not None)

    uebergabe_datum = st.date_input(
        "Geplantes √úbergabedatum",
        value=date.today() + timedelta(days=60),
        min_value=date.today()
    )

    zusaetzliche_klauseln = st.text_area(
        "Zus√§tzliche Klauseln/Hinweise f√ºr die KI",
        placeholder="z.B. Besondere Vereinbarungen, Inventar das mitverkauft wird, etc."
    )

    if st.button("ü§ñ Kaufvertrag generieren", type="primary", use_container_width=True):
        with st.spinner("KI generiert Kaufvertragsentwurf..."):
            vertrag_text = generate_kaufvertrag_mit_ki(
                projekt=projekt,
                verkaeufer=verkaeufer,
                kaeufer_list=kaeufer_list,
                expose=expose,
                makler=makler,
                optionen={
                    "ruecktrittsrecht": include_ruecktrittsrecht,
                    "gewaehrleistung": include_gewaehrleistung,
                    "besitzuebergang": include_besitzuebergang,
                    "auflassung": include_auflassung,
                    "erschliessungskosten": include_erschliessungskosten,
                    "maklerklausel": include_maklerklausel,
                    "uebergabe_datum": uebergabe_datum,
                    "zusaetzliche_klauseln": zusaetzliche_klauseln
                },
                api_key=api_key,
                api_type=api_type
            )

            if vertrag_text:
                vertrag_key = f"kaufvertrag_{projekt.projekt_id}"
                st.session_state[vertrag_key] = {
                    "text": vertrag_text,
                    "erstellt_am": datetime.now().isoformat(),
                    "status": "Entwurf"
                }
                st.success("‚úÖ Kaufvertragsentwurf wurde generiert!")
                st.rerun()


def generate_kaufvertrag_mit_ki(projekt, verkaeufer, kaeufer_list, expose, makler, optionen, api_key, api_type):
    """Generiert einen Kaufvertrag mit KI"""

    verkaeufer_data = "Unbekannt"
    if verkaeufer:
        verkaeufer_personal = st.session_state.get(f"personal_{verkaeufer.user_id}", {})
        verkaeufer_data = f"""Name: {verkaeufer.name}
Geburtsdatum: {verkaeufer_personal.get('geburtsdatum', 'N/A')}
Adresse: {verkaeufer_personal.get('strasse', '')} {verkaeufer_personal.get('hausnummer', '')}, {verkaeufer_personal.get('plz', '')} {verkaeufer_personal.get('ort', '')}"""

    kaeufer_data = ""
    for i, kaeufer in enumerate(kaeufer_list, 1):
        if kaeufer:
            kaeufer_personal = st.session_state.get(f"personal_{kaeufer.user_id}", {})
            kaeufer_data += f"""K√§ufer {i}: {kaeufer.name}
Geburtsdatum: {kaeufer_personal.get('geburtsdatum', 'N/A')}
Adresse: {kaeufer_personal.get('strasse', '')} {kaeufer_personal.get('hausnummer', '')}, {kaeufer_personal.get('plz', '')} {kaeufer_personal.get('ort', '')}
"""

    objekt_data = "Keine Objektdaten"
    if expose:
        objekt_data = f"""Adresse: {expose.strasse} {expose.hausnummer}, {expose.plz} {expose.ort}
Objektart: {expose.objektart}
Wohnfl√§che: {expose.wohnflaeche} m¬≤
Kaufpreis: {format_euro(expose.kaufpreis)} EUR"""

    prompt = f"""Erstelle einen professionellen deutschen Kaufvertragsentwurf.

VERK√ÑUFER: {verkaeufer_data}
K√ÑUFER: {kaeufer_data}
OBJEKT: {objekt_data}

OPTIONEN:
- R√ºcktrittsrecht: {"Ja" if optionen.get('ruecktrittsrecht') else "Nein"}
- Gew√§hrleistungsausschluss: {"Ja" if optionen.get('gewaehrleistung') else "Nein"}
- Auflassungsvormerkung: {"Ja" if optionen.get('auflassung') else "Nein"}
- √úbergabedatum: {optionen.get('uebergabe_datum')}

Zus√§tzliche Hinweise: {optionen.get('zusaetzliche_klauseln', 'Keine')}

Erstelle einen vollst√§ndigen notariellen Kaufvertragsentwurf mit: Pr√§ambel, Kaufgegenstand, Kaufpreis, √úbergabe, Gew√§hrleistung, Auflassung, Kosten, Schlussbestimmungen."""

    try:
        if api_type == "openai":
            import urllib.request
            import json as json_module

            data = json_module.dumps({
                "model": "gpt-4",
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": 4000,
                "temperature": 0.3
            }).encode('utf-8')

            req = urllib.request.Request(
                "https://api.openai.com/v1/chat/completions",
                data=data,
                headers={"Content-Type": "application/json", "Authorization": f"Bearer {api_key}"},
                method="POST"
            )

            with urllib.request.urlopen(req, timeout=120) as response:
                result = json_module.loads(response.read().decode('utf-8'))
                return result['choices'][0]['message']['content']

        elif api_type == "anthropic":
            import urllib.request
            import json as json_module

            data = json_module.dumps({
                "model": "claude-3-sonnet-20240229",
                "max_tokens": 4000,
                "messages": [{"role": "user", "content": prompt}]
            }).encode('utf-8')

            req = urllib.request.Request(
                "https://api.anthropic.com/v1/messages",
                data=data,
                headers={"Content-Type": "application/json", "x-api-key": api_key, "anthropic-version": "2023-06-01"},
                method="POST"
            )

            with urllib.request.urlopen(req, timeout=120) as response:
                result = json_module.loads(response.read().decode('utf-8'))
                return result['content'][0]['text']

    except Exception as e:
        st.error(f"API-Fehler: {str(e)}")
        return None

    return None


def render_vertrag_editor(projekt):
    """Editor f√ºr den Kaufvertragsentwurf"""
    st.markdown("### üìù Vertragsentwurf bearbeiten")

    vertrag_key = f"kaufvertrag_{projekt.projekt_id}"

    if vertrag_key not in st.session_state:
        st.info("üí° Noch kein Vertragsentwurf vorhanden.")

        if st.button("üìù Leeren Entwurf erstellen", key="create_empty_vertrag"):
            st.session_state[vertrag_key] = {
                "text": """KAUFVERTRAGSENTWURF

Urkundenrolle Nr. ___/____

Verhandelt zu _____________ am ______________

¬ß 1 KAUFGEGENSTAND
[Beschreibung des Objekts]

¬ß 2 KAUFPREIS
[Kaufpreis und Zahlungsmodalit√§ten]

¬ß 3 √úBERGABE
[√úbergaberegelungen]

¬ß 4 GEW√ÑHRLEISTUNG
[Gew√§hrleistungsregelungen]

¬ß 5 AUFLASSUNG
[Auflassungserkl√§rung]

¬ß 6 KOSTEN
[Kostenverteilung]

¬ß 7 SCHLUSSBESTIMMUNGEN
[Weitere Vereinbarungen]
""",
                "erstellt_am": datetime.now().isoformat(),
                "status": "Entwurf"
            }
            st.rerun()
        return

    vertrag = st.session_state[vertrag_key]

    col1, col2 = st.columns([2, 1])
    with col1:
        st.write(f"**Status:** {vertrag.get('status', 'Entwurf')}")
    with col2:
        erstellt = vertrag.get('erstellt_am', '')
        if erstellt:
            try:
                dt = datetime.fromisoformat(erstellt)
                st.write(f"**Erstellt:** {dt.strftime('%d.%m.%Y %H:%M')}")
            except:
                pass

    neuer_text = st.text_area(
        "Vertragstext",
        value=vertrag.get('text', ''),
        height=500,
        key=f"vertrag_editor_{projekt.projekt_id}"
    )

    col1, col2, col3 = st.columns(3)
    with col1:
        if st.button("üíæ Speichern", use_container_width=True, key="save_vertrag"):
            st.session_state[vertrag_key]['text'] = neuer_text
            st.session_state[vertrag_key]['geaendert_am'] = datetime.now().isoformat()
            st.success("‚úÖ Gespeichert!")

    with col2:
        if st.button("üìÑ Als Entwurf", use_container_width=True, key="mark_draft"):
            st.session_state[vertrag_key]['status'] = "Entwurf"
            st.success("‚úÖ Status: Entwurf")

    with col3:
        if st.button("‚úÖ Als Final", use_container_width=True, key="mark_final"):
            st.session_state[vertrag_key]['status'] = "Final"
            st.success("‚úÖ Status: Final")

    st.markdown("---")
    st.download_button(
        "üì• Vertrag als TXT herunterladen",
        data=neuer_text,
        file_name=f"Kaufvertrag_{projekt.name}_{date.today().isoformat()}.txt",
        mime="text/plain",
        use_container_width=True,
        key="download_vertrag"
    )


def render_vertrag_versenden(projekt):
    """Vertrag an Parteien versenden"""
    st.markdown("### üì§ Vertragsentwurf versenden")

    vertrag_key = f"kaufvertrag_{projekt.projekt_id}"

    if vertrag_key not in st.session_state:
        st.warning("‚ö†Ô∏è Noch kein Vertragsentwurf vorhanden.")
        return

    vertrag = st.session_state[vertrag_key]

    if vertrag.get('status') != "Final":
        st.warning("‚ö†Ô∏è Der Vertrag ist noch nicht als 'Final' markiert.")

    st.markdown("#### üìß Empf√§nger ausw√§hlen")

    verkaeufer_list = [st.session_state.users.get(vid) for vid in projekt.verkaeufer_ids if st.session_state.users.get(vid)]
    kaeufer_list = [st.session_state.users.get(kid) for kid in projekt.kaeufer_ids if st.session_state.users.get(kid)]
    makler = st.session_state.users.get(projekt.makler_id)

    # Verk√§ufer ausw√§hlen
    send_to_verkaeufer = []
    for verkaeufer in verkaeufer_list:
        checked = st.checkbox(
            f"üìß Verk√§ufer: {verkaeufer.name}",
            value=True,
            key=f"send_verkaeufer_{verkaeufer.user_id}"
        )
        if checked:
            send_to_verkaeufer.append(verkaeufer)

    send_to_kaeufer = []
    for kaeufer in kaeufer_list:
        if kaeufer:
            checked = st.checkbox(
                f"üìß K√§ufer: {kaeufer.name}",
                value=True,
                key=f"send_kaeufer_{kaeufer.user_id}"
            )
            if checked:
                send_to_kaeufer.append(kaeufer)

    send_to_makler = False
    if makler:
        send_to_makler = st.checkbox(
            f"üìß Makler: {makler.name}",
            value=True,
            key="send_makler"
        )

    if st.button("üì§ Vertragsentwurf versenden", type="primary", use_container_width=True, key="send_vertrag"):
        empfaenger = []

        for verkaeufer in send_to_verkaeufer:
            empfaenger.append(verkaeufer)
            create_notification(
                verkaeufer.user_id,
                "Kaufvertragsentwurf erhalten",
                f"Sie haben den Kaufvertragsentwurf f√ºr '{projekt.name}' erhalten.",
                NotificationType.INFO.value
            )

        for kaeufer in send_to_kaeufer:
            empfaenger.append(kaeufer)
            create_notification(
                kaeufer.user_id,
                "Kaufvertragsentwurf erhalten",
                f"Sie haben den Kaufvertragsentwurf f√ºr '{projekt.name}' erhalten.",
                NotificationType.INFO.value
            )

        if send_to_makler and makler:
            empfaenger.append(makler)
            create_notification(
                makler.user_id,
                "Kaufvertragsentwurf versendet",
                f"Der Kaufvertragsentwurf f√ºr '{projekt.name}' wurde versendet.",
                NotificationType.INFO.value
            )

        st.session_state[vertrag_key]['status'] = "Versendet"
        st.session_state[vertrag_key]['versendet_am'] = datetime.now().isoformat()

        create_timeline_event(
            projekt.projekt_id,
            "Kaufvertrag",
            "Kaufvertragsentwurf versendet",
            f"Der Kaufvertragsentwurf wurde an {len(empfaenger)} Empf√§nger versendet."
        )

        st.success(f"‚úÖ Vertragsentwurf an {len(empfaenger)} Empf√§nger versendet!")
        st.balloons()


def notar_termine():
    """Erweiterte Termin-Verwaltung f√ºr Notar mit Outlook-Kalender-Integration"""
    st.subheader("üìÖ Notartermine")

    notar_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    # Kalender-Ansicht-Tabs
    termin_tabs = st.tabs(["üìÖ Kalender", "üìÜ Outlook-Integration", "üìã Nach Projekt"])

    with termin_tabs[0]:
        # Vollst√§ndiger Kalender
        render_termin_kalender(notar_id, UserRole.NOTAR.value)

    with termin_tabs[1]:
        # Outlook-Kalender-Simulation
        st.markdown("### üìÜ Mein Outlook-Kalender")
        st.info("üí° Der Kalender zeigt Ihre anstehenden Beurkundungstermine. Termine werden automatisch mit Ihrem Outlook synchronisiert.")

        # Alle best√§tigten Termine anzeigen
        alle_termine = []
        for projekt in projekte:
            for termin_id in projekt.termine:
                termin = st.session_state.termine.get(termin_id)
                if termin and termin.termin_typ == TerminTyp.BEURKUNDUNG.value:
                    alle_termine.append((termin, projekt))

        if alle_termine:
            for termin, projekt in sorted(alle_termine, key=lambda x: x[0].datum):
                status_icon = "üü¢" if termin.status == TerminStatus.BESTAETIGT.value else "üü°" if termin.status == TerminStatus.TEILWEISE_BESTAETIGT.value else "üü†"
                outlook_status = f"[{termin.outlook_status}]" if termin.outlook_status else ""

                col1, col2, col3 = st.columns([3, 2, 1])
                with col1:
                    st.write(f"{status_icon} **{termin.datum.strftime('%d.%m.%Y')}** - {termin.uhrzeit_start} Uhr")
                    st.caption(termin.beschreibung)
                with col2:
                    st.write(f"Projekt: {projekt.name}")
                    st.write(f"Status: {termin.status} {outlook_status}")
                with col3:
                    if termin.status == TerminStatus.BESTAETIGT.value:
                        ics_content = generate_ics_file(termin, projekt)
                        st.download_button("üì• .ics", data=ics_content, file_name=f"beurkundung_{projekt.projekt_id}.ics", mime="text/calendar", key=f"notar_ics_{termin.termin_id}")
        else:
            st.info("Keine Beurkundungstermine vorhanden.")

        st.markdown("---")
        st.markdown("### üìã Terminvorschl√§ge f√ºr Projekte")

        if not projekte:
            st.info("Noch keine Projekte zugewiesen.")
        else:
            for projekt in projekte:
                with st.expander(f"üèòÔ∏è {projekt.name} - Terminvorschl√§ge"):
                    render_termin_verwaltung(projekt, UserRole.NOTAR.value)

    with termin_tabs[2]:
        # Projekt-basierte Ansicht mit erweiterten Terminvorschl√§gen
        if not projekte:
            st.info("Noch keine Projekte zugewiesen.")
        else:
            for projekt in projekte:
                with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
                    # Pr√ºfe ob Kaufvertragsentwurf gesendet wurde
                    entwurf_gesendet = check_kaufvertrag_entwurf_status(projekt.projekt_id)

                    if not entwurf_gesendet:
                        st.warning("‚ö†Ô∏è Kaufvertragsentwurf muss erst versendet werden, bevor Beurkundungstermine vorgeschlagen werden k√∂nnen.")

                        # Manuell als erledigt markieren
                        if st.checkbox("Kaufvertragsentwurf wurde versendet", key=f"entwurf_ok_{projekt.projekt_id}"):
                            # Timeline-Event als erledigt markieren
                            for event_id in projekt.timeline_events:
                                event = st.session_state.timeline_events.get(event_id)
                                if event and "Kaufvertrag" in event.titel and not event.completed:
                                    event.completed = True
                                    event.completed_at = datetime.now()
                                    st.session_state.timeline_events[event_id] = event
                            st.success("Status aktualisiert!")
                            st.rerun()
                        continue

                    # Bestehende Beurkundungstermine anzeigen
                    beurkundungstermine = [st.session_state.termine.get(tid) for tid in projekt.termine
                                           if st.session_state.termine.get(tid) and
                                           st.session_state.termine.get(tid).termin_typ == TerminTyp.BEURKUNDUNG.value]

                    if beurkundungstermine:
                        for termin in beurkundungstermine:
                            status_icon = "üü¢" if termin.status == TerminStatus.BESTAETIGT.value else "üü°"
                            st.markdown(f"{status_icon} **Termin:** {termin.datum.strftime('%d.%m.%Y')} um {termin.uhrzeit_start} Uhr")
                            st.write(f"Status: {termin.status}")

                            # Best√§tigungsstatus anzeigen
                            bestaetigung = check_termin_bestaetigung(termin, projekt)
                            if not bestaetigung['alle_bestaetigt']:
                                ausstehend = []
                                if not bestaetigung['makler_bestaetigt'] and projekt.makler_id:
                                    ausstehend.append("Makler")
                                if bestaetigung['kaeufer_ausstehend']:
                                    ausstehend.append(f"K√§ufer ({len(bestaetigung['kaeufer_ausstehend'])})")
                                if bestaetigung['verkaeufer_ausstehend']:
                                    ausstehend.append(f"Verk√§ufer ({len(bestaetigung['verkaeufer_ausstehend'])})")
                                st.caption(f"Ausstehende Best√§tigungen: {', '.join(ausstehend)}")
                    else:
                        st.info("Noch keine Beurkundungstermine.")

                    # Offene Vorschl√§ge anzeigen
                    offene_vorschlaege = [v for v in st.session_state.terminvorschlaege.values()
                                         if v.projekt_id == projekt.projekt_id and
                                         v.termin_typ == TerminTyp.BEURKUNDUNG.value and
                                         v.status == "offen"]

                    if offene_vorschlaege:
                        st.markdown("##### üì® Bereits gesendete Vorschl√§ge")
                        for vorschlag in offene_vorschlaege:
                            st.write(f"Gesendet am: {vorschlag.erstellt_am.strftime('%d.%m.%Y %H:%M')}")
                            for i, slot in enumerate(vorschlag.vorschlaege):
                                st.write(f"  Option {i+1}: {slot['datum'].strftime('%d.%m.%Y')} ({slot['tageszeit']}) {slot['uhrzeit_start']}-{slot['uhrzeit_ende']} Uhr")

                    # Button zum Erstellen neuer Vorschl√§ge
                    st.markdown("##### ‚ûï Neue Terminvorschl√§ge generieren")
                    st.caption("Basierend auf Ihrem Outlook-Kalender werden 3 verf√ºgbare Termine vorgeschlagen.")

                    col1, col2 = st.columns(2)
                    with col1:
                        tageszeit_filter = st.selectbox("Bevorzugte Tageszeit", ["Alle", "Vormittag", "Nachmittag"], key=f"tageszeit_{projekt.projekt_id}")

                    if st.button("üóìÔ∏è 3 Terminvorschl√§ge generieren", key=f"gen_vorschlag_{projekt.projekt_id}", type="primary"):
                        vorschlag = create_termin_vorschlaege(projekt.projekt_id, notar_id, TerminTyp.BEURKUNDUNG.value)
                        if vorschlag:
                            st.success("‚úÖ 3 Terminvorschl√§ge wurden erstellt und an Makler/K√§ufer/Verk√§ufer gesendet!")

                            # Benachrichtigungen senden
                            if projekt.makler_id:
                                create_notification(
                                    projekt.makler_id,
                                    "Neue Terminvorschl√§ge",
                                    f"Der Notar hat 3 Terminvorschl√§ge f√ºr die Beurkundung von '{projekt.name}' erstellt.",
                                    NotificationType.INFO.value
                                )
                            for kid in projekt.kaeufer_ids:
                                create_notification(kid, "Neue Terminvorschl√§ge", f"Der Notar hat Terminvorschl√§ge f√ºr die Beurkundung erstellt.", NotificationType.INFO.value)
                            for vid in projekt.verkaeufer_ids:
                                create_notification(vid, "Neue Terminvorschl√§ge", f"Der Notar hat Terminvorschl√§ge f√ºr die Beurkundung erstellt.", NotificationType.INFO.value)

                            st.rerun()
                        else:
                            st.error("Keine verf√ºgbaren Termine in den n√§chsten 4 Wochen gefunden.")

                    st.markdown("---")

                    # Alle Termine f√ºr dieses Projekt (alle Typen)
                    st.markdown("##### üìã Alle Termine")
                    render_termin_verwaltung(projekt, UserRole.NOTAR.value)

def notar_makler_empfehlung_view():
    """Makler-Empfehlungen f√ºr Verk√§ufer verwalten"""
    import uuid

    st.subheader("ü§ù Maklerempfehlung f√ºr Verk√§ufer")
    st.info("""
    Empfehlen Sie gepr√ºfte Makler an Verk√§ufer weiter. Eingeladene Makler erhalten
    einen Link zur Dateneingabe und werden nach Ihrer Freigabe f√ºr Verk√§ufer sichtbar.
    """)

    notar_id = st.session_state.current_user.user_id

    # Neuen Makler einladen
    st.markdown("### ‚ûï Neuen Makler einladen")

    with st.form("invite_makler_form"):
        col1, col2 = st.columns(2)
        with col1:
            makler_email = st.text_input("E-Mail-Adresse des Maklers*")
            makler_name = st.text_input("Name/Firma des Maklers")
        with col2:
            notiz = st.text_area("Interne Notiz (nur f√ºr Sie sichtbar)", height=100)

        submit = st.form_submit_button("üìß Einladung senden", type="primary")

        if submit and makler_email:
            # Pr√ºfen ob bereits eingeladen
            existing = [e for e in st.session_state.makler_empfehlungen.values()
                       if e.makler_email.lower() == makler_email.lower() and e.notar_id == notar_id]

            if existing:
                st.warning("‚ö†Ô∏è Dieser Makler wurde bereits eingeladen.")
            else:
                # Neue Empfehlung erstellen
                empfehlung_id = f"emp_{len(st.session_state.makler_empfehlungen) + 1}"
                onboarding_token = str(uuid.uuid4())

                neue_empfehlung = MaklerEmpfehlung(
                    empfehlung_id=empfehlung_id,
                    notar_id=notar_id,
                    makler_email=makler_email,
                    makler_name=makler_name,
                    status=MaklerEmpfehlungStatus.EINGELADEN.value,
                    onboarding_token=onboarding_token,
                    notiz_notar=notiz
                )
                st.session_state.makler_empfehlungen[empfehlung_id] = neue_empfehlung

                # Simulierte E-Mail-Benachrichtigung
                st.success(f"""
                ‚úÖ Einladung gesendet!

                **Simulierte E-Mail an:** {makler_email}

                **Betreff:** Einladung zur Makler-Plattform

                **Inhalt:**
                Sehr geehrte(r) {makler_name or 'Makler'},

                Sie wurden von Notariat {st.session_state.current_user.name} eingeladen,
                sich auf unserer Immobilien-Transaktionsplattform zu registrieren.

                Bitte f√ºllen Sie Ihre Firmendaten unter folgendem Link aus:
                **https://plattform.example.com/makler-onboarding?token={onboarding_token}**

                Mit freundlichen Gr√º√üen,
                {st.session_state.current_user.name}
                """)
                st.rerun()

    st.markdown("---")
    st.markdown("### üìã Eingeladene Makler")

    # Makler nach Status gruppieren
    meine_empfehlungen = [e for e in st.session_state.makler_empfehlungen.values()
                         if e.notar_id == notar_id]

    if not meine_empfehlungen:
        st.info("Noch keine Makler eingeladen.")
        return

    # Tabs f√ºr Status
    status_tabs = st.tabs(["‚è≥ Ausstehend", "‚úÖ Freigegeben", "‚ùå Abgelehnt/Deaktiviert"])

    # Ausstehend (Eingeladen + Daten eingegeben)
    with status_tabs[0]:
        ausstehend = [e for e in meine_empfehlungen
                      if e.status in [MaklerEmpfehlungStatus.EINGELADEN.value,
                                     MaklerEmpfehlungStatus.DATEN_EINGEGEBEN.value]]

        if not ausstehend:
            st.info("Keine ausstehenden Einladungen.")
        else:
            for emp in ausstehend:
                with st.container():
                    col1, col2, col3 = st.columns([3, 2, 2])

                    with col1:
                        st.markdown(f"**{emp.firmenname or emp.makler_name or emp.makler_email}**")
                        st.caption(f"üìß {emp.makler_email}")
                        if emp.kurzvita:
                            st.write(emp.kurzvita[:100] + "..." if len(emp.kurzvita) > 100 else emp.kurzvita)

                    with col2:
                        status_icon = "üì®" if emp.status == MaklerEmpfehlungStatus.EINGELADEN.value else "üìù"
                        st.write(f"{status_icon} **{emp.status}**")
                        st.caption(f"Eingeladen: {emp.eingeladen_am.strftime('%d.%m.%Y')}")
                        if emp.telefon:
                            st.write(f"üìû {emp.telefon}")

                    with col3:
                        if emp.status == MaklerEmpfehlungStatus.DATEN_EINGEGEBEN.value:
                            # Makler hat Daten eingegeben - Freigabe m√∂glich
                            if st.button("‚úÖ Freigeben", key=f"approve_{emp.empfehlung_id}", type="primary"):
                                emp.status = MaklerEmpfehlungStatus.FREIGEGEBEN.value
                                emp.freigegeben_am = datetime.now()
                                st.session_state.makler_empfehlungen[emp.empfehlung_id] = emp
                                st.success("Makler freigegeben!")
                                st.rerun()

                            if st.button("‚ùå Ablehnen", key=f"reject_{emp.empfehlung_id}"):
                                emp.status = MaklerEmpfehlungStatus.ABGELEHNT.value
                                st.session_state.makler_empfehlungen[emp.empfehlung_id] = emp
                                st.rerun()
                        else:
                            # Noch keine Daten - Erinnerung senden
                            if st.button("üìß Erneut senden", key=f"resend_{emp.empfehlung_id}"):
                                st.info(f"Erinnerung an {emp.makler_email} gesendet (simuliert)")

                        # Details anzeigen
                        if emp.kurzvita or emp.spezialisierung:
                            with st.expander("üìÑ Details"):
                                if emp.kurzvita:
                                    st.write(f"**Kurzvita:** {emp.kurzvita}")
                                if emp.spezialisierung:
                                    st.write(f"**Spezialisierung:** {', '.join(emp.spezialisierung)}")
                                if emp.regionen:
                                    st.write(f"**Regionen:** {', '.join(emp.regionen)}")
                                if emp.provision_verkaeufer_prozent > 0:
                                    st.write(f"**Provision Verk√§ufer:** {emp.provision_verkaeufer_prozent}%")
                                if emp.provision_kaeufer_prozent > 0:
                                    st.write(f"**Provision K√§ufer:** {emp.provision_kaeufer_prozent}%")

                    st.markdown("---")

    # Freigegeben
    with status_tabs[1]:
        freigegeben = [e for e in meine_empfehlungen
                       if e.status == MaklerEmpfehlungStatus.FREIGEGEBEN.value]

        if not freigegeben:
            st.info("Noch keine freigegebenen Makler.")
        else:
            for emp in freigegeben:
                with st.container():
                    col1, col2, col3 = st.columns([3, 2, 2])

                    with col1:
                        st.markdown(f"### {emp.firmenname or emp.makler_name}")
                        st.caption(f"üìß {emp.makler_email}")
                        if emp.kurzvita:
                            st.write(emp.kurzvita)

                    with col2:
                        st.write("‚úÖ **Freigegeben**")
                        st.caption(f"Seit: {emp.freigegeben_am.strftime('%d.%m.%Y') if emp.freigegeben_am else 'N/A'}")
                        if emp.telefon:
                            st.write(f"üìû {emp.telefon}")
                        if emp.website:
                            st.write(f"üåê {emp.website}")

                    with col3:
                        if st.button("‚è∏Ô∏è Deaktivieren", key=f"deactivate_{emp.empfehlung_id}"):
                            emp.status = MaklerEmpfehlungStatus.DEAKTIVIERT.value
                            st.session_state.makler_empfehlungen[emp.empfehlung_id] = emp
                            st.rerun()

                        with st.expander("üìÑ Alle Details"):
                            st.write(f"**Adresse:** {emp.adresse}")
                            st.write(f"**Spezialisierung:** {', '.join(emp.spezialisierung)}")
                            st.write(f"**Regionen:** {', '.join(emp.regionen)}")
                            st.write(f"**Provision Verk√§ufer:** {emp.provision_verkaeufer_prozent}%")
                            st.write(f"**Provision K√§ufer:** {emp.provision_kaeufer_prozent}%")
                            if emp.notiz_notar:
                                st.write(f"**Ihre Notiz:** {emp.notiz_notar}")

                    st.markdown("---")

    # Abgelehnt/Deaktiviert
    with status_tabs[2]:
        inaktiv = [e for e in meine_empfehlungen
                   if e.status in [MaklerEmpfehlungStatus.ABGELEHNT.value,
                                  MaklerEmpfehlungStatus.DEAKTIVIERT.value]]

        if not inaktiv:
            st.info("Keine abgelehnten oder deaktivierten Makler.")
        else:
            for emp in inaktiv:
                col1, col2 = st.columns([4, 1])
                with col1:
                    st.write(f"**{emp.firmenname or emp.makler_name or emp.makler_email}** - {emp.status}")
                with col2:
                    if st.button("üîÑ Reaktivieren", key=f"reactivate_{emp.empfehlung_id}"):
                        emp.status = MaklerEmpfehlungStatus.FREIGEGEBEN.value
                        emp.freigegeben_am = datetime.now()
                        st.session_state.makler_empfehlungen[emp.empfehlung_id] = emp
                        st.rerun()


def notar_handwerker_view():
    """Handwerker-Empfehlungen verwalten"""
    import uuid

    st.subheader("üîß Handwerker-Empfehlungen")
    st.caption("Verwalten Sie hier Handwerker-Empfehlungen, die K√§ufern zur Verf√ºgung gestellt werden.")

    notar_id = st.session_state.current_user.user_id

    # Sicherstellen, dass handwerker_empfehlungen existiert
    if 'handwerker_empfehlungen' not in st.session_state:
        st.session_state.handwerker_empfehlungen = {}

    tabs = st.tabs(["üìã Alle Handwerker", "‚ûï Neuen Handwerker anlegen"])

    with tabs[0]:
        # Filter nach Kategorie
        filter_kategorie = st.selectbox(
            "Nach Kategorie filtern",
            options=["Alle"] + [k.value for k in HandwerkerKategorie],
            key="handwerker_filter_kat"
        )

        # Handwerker auflisten
        alle_handwerker = list(st.session_state.handwerker_empfehlungen.values())

        if filter_kategorie != "Alle":
            alle_handwerker = [h for h in alle_handwerker if h.kategorie == filter_kategorie]

        if not alle_handwerker:
            st.info("Noch keine Handwerker angelegt. Erstellen Sie eine neue Empfehlung im Tab 'Neuen Handwerker anlegen'.")
        else:
            # Gruppiert nach Kategorie anzeigen
            kategorien = {}
            for hw in alle_handwerker:
                if hw.kategorie not in kategorien:
                    kategorien[hw.kategorie] = []
                kategorien[hw.kategorie].append(hw)

            for kategorie, handwerker_liste in sorted(kategorien.items()):
                with st.expander(f"üîß {kategorie} ({len(handwerker_liste)})", expanded=True):
                    for hw in handwerker_liste:
                        col1, col2, col3 = st.columns([0.6, 0.25, 0.15])

                        with col1:
                            # Sterne-Bewertung anzeigen
                            sterne = "‚≠ê" * hw.bewertung if hw.bewertung > 0 else "Keine Bewertung"
                            empfohlen_badge = "‚úÖ Empfohlen" if hw.empfohlen else "‚è∏Ô∏è Nicht freigegeben"

                            st.markdown(f"**{hw.firmenname}** {empfohlen_badge}")
                            st.caption(f"{sterne}")
                            if hw.kontaktperson:
                                st.caption(f"üë§ {hw.kontaktperson}")
                            if hw.telefon:
                                st.caption(f"üìû {hw.telefon}")
                            if hw.email:
                                st.caption(f"üìß {hw.email}")
                            if hw.beschreibung:
                                st.caption(hw.beschreibung)

                        with col2:
                            if hw.adresse:
                                st.caption(f"üìç {hw.adresse}")
                            if hw.webseite:
                                st.caption(f"üåê {hw.webseite}")

                        with col3:
                            # Toggle Empfohlen-Status
                            if hw.empfohlen:
                                if st.button("‚è∏Ô∏è Deaktivieren", key=f"deact_hw_{hw.handwerker_id}"):
                                    st.session_state.handwerker_empfehlungen[hw.handwerker_id].empfohlen = False
                                    st.rerun()
                            else:
                                if st.button("‚úÖ Freigeben", key=f"act_hw_{hw.handwerker_id}"):
                                    st.session_state.handwerker_empfehlungen[hw.handwerker_id].empfohlen = True
                                    st.rerun()

                            if st.button("üóëÔ∏è L√∂schen", key=f"del_hw_{hw.handwerker_id}"):
                                del st.session_state.handwerker_empfehlungen[hw.handwerker_id]
                                st.rerun()

                        st.markdown("---")

    with tabs[1]:
        st.markdown("### ‚ûï Neuen Handwerker anlegen")

        with st.form("neuer_handwerker_form"):
            col1, col2 = st.columns(2)

            with col1:
                firmenname = st.text_input("Firmenname *", placeholder="z.B. M√ºller Elektrotechnik GmbH")
                kategorie = st.selectbox(
                    "Kategorie *",
                    options=[k.value for k in HandwerkerKategorie]
                )
                kontaktperson = st.text_input("Ansprechpartner", placeholder="z.B. Herr Max M√ºller")
                telefon = st.text_input("Telefon", placeholder="z.B. 0123 456789")

            with col2:
                email = st.text_input("E-Mail", placeholder="z.B. info@mueller-elektro.de")
                adresse = st.text_input("Adresse", placeholder="z.B. Musterstra√üe 1, 12345 Musterstadt")
                webseite = st.text_input("Webseite", placeholder="z.B. www.mueller-elektro.de")
                bewertung = st.slider("Bewertung (Sterne)", 0, 5, 0)

            beschreibung = st.text_area(
                "Beschreibung / Leistungen",
                placeholder="z.B. Spezialisiert auf Smart Home Installation, E-Check, Photovoltaik..."
            )
            notizen = st.text_area(
                "Interne Notizen (nur f√ºr Notar sichtbar)",
                placeholder="z.B. Besonders zuverl√§ssig, gute Erfahrungen bei Projekt XY..."
            )

            empfohlen = st.checkbox("Sofort f√ºr K√§ufer freigeben", value=True)

            submitted = st.form_submit_button("‚úÖ Handwerker anlegen", use_container_width=True)

            if submitted:
                if not firmenname.strip():
                    st.error("Bitte geben Sie einen Firmennamen ein.")
                else:
                    hw_id = f"hw_{uuid.uuid4().hex[:8]}"
                    neuer_handwerker = Handwerker(
                        handwerker_id=hw_id,
                        notar_id=notar_id,
                        firmenname=firmenname.strip(),
                        kategorie=kategorie,
                        kontaktperson=kontaktperson.strip(),
                        telefon=telefon.strip(),
                        email=email.strip(),
                        adresse=adresse.strip(),
                        webseite=webseite.strip(),
                        beschreibung=beschreibung.strip(),
                        bewertung=bewertung,
                        empfohlen=empfohlen,
                        notizen=notizen.strip()
                    )
                    st.session_state.handwerker_empfehlungen[hw_id] = neuer_handwerker
                    st.success(f"‚úÖ Handwerker '{firmenname}' wurde angelegt!")
                    st.rerun()


def notar_ausweis_erfassung():
    """Ausweisdaten f√ºr K√§ufer und Verk√§ufer erfassen (Notar)"""
    st.subheader("ü™™ Ausweisdaten erfassen")
    st.caption("Erfassen Sie hier die Ausweisdaten der K√§ufer und Verk√§ufer f√ºr Ihre Projekte.")

    notar_id = st.session_state.current_user.user_id
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    if not projekte:
        st.info("Noch keine Projekte zugewiesen.")
        return

    # Projekt ausw√§hlen
    projekt_options = {p.name: p for p in projekte}
    selected_projekt_name = st.selectbox(
        "Projekt ausw√§hlen",
        list(projekt_options.keys()),
        key="notar_ausweis_projekt"
    )
    selected_projekt = projekt_options[selected_projekt_name]

    # Tabs f√ºr K√§ufer und Verk√§ufer
    ausweis_tabs = st.tabs(["üë§ K√§ufer", "üë§ Verk√§ufer"])

    with ausweis_tabs[0]:
        st.markdown("### K√§ufer-Ausweisdaten")
        if selected_projekt.kaeufer_ids:
            for kaeufer_id in selected_projekt.kaeufer_ids:
                kaeufer = st.session_state.users.get(kaeufer_id)
                if kaeufer:
                    with st.expander(f"ü™™ {kaeufer.name}", expanded=True):
                        # Pr√ºfen ob Daten bereits erfasst
                        personal_key = f"personal_{kaeufer_id}"
                        if personal_key in st.session_state or (kaeufer.personal_daten and kaeufer.personal_daten.manuell_bestaetigt):
                            st.success("‚úÖ Ausweisdaten bereits erfasst")
                            if kaeufer.personal_daten:
                                pd = kaeufer.personal_daten
                                st.write(f"**Name:** {pd.vorname} {pd.nachname}")
                                st.write(f"**Geburtsdatum:** {pd.geburtsdatum.strftime('%d.%m.%Y') if pd.geburtsdatum else '-'}")
                                st.write(f"**Adresse:** {pd.strasse} {pd.hausnummer}, {pd.plz} {pd.ort}")

                            if st.button(f"üîÑ Neu erfassen", key=f"reupload_notar_k_{kaeufer_id}"):
                                if f"ausweis_vorderseite_{kaeufer_id}" in st.session_state:
                                    del st.session_state[f"ausweis_vorderseite_{kaeufer_id}"]
                                if f"ausweis_rueckseite_{kaeufer_id}" in st.session_state:
                                    del st.session_state[f"ausweis_rueckseite_{kaeufer_id}"]
                                st.rerun()
                        else:
                            st.info("Ausweisdaten noch nicht erfasst.")
                            render_ausweis_upload(kaeufer_id, UserRole.KAEUFER.value, context=f"notar_{kaeufer_id}")
        else:
            st.info("Noch keine K√§ufer f√ºr dieses Projekt.")

    with ausweis_tabs[1]:
        st.markdown("### Verk√§ufer-Ausweisdaten")
        if selected_projekt.verkaeufer_ids:
            for verkaeufer_id in selected_projekt.verkaeufer_ids:
                verkaeufer = st.session_state.users.get(verkaeufer_id)
                if verkaeufer:
                    with st.expander(f"ü™™ {verkaeufer.name}", expanded=True):
                        # Pr√ºfen ob Daten bereits erfasst
                        personal_key = f"personal_{verkaeufer_id}"
                        if personal_key in st.session_state or (verkaeufer.personal_daten and verkaeufer.personal_daten.manuell_bestaetigt):
                            st.success("‚úÖ Ausweisdaten bereits erfasst")
                            if verkaeufer.personal_daten:
                                pd = verkaeufer.personal_daten
                                st.write(f"**Name:** {pd.vorname} {pd.nachname}")
                                st.write(f"**Geburtsdatum:** {pd.geburtsdatum.strftime('%d.%m.%Y') if pd.geburtsdatum else '-'}")
                                st.write(f"**Adresse:** {pd.strasse} {pd.hausnummer}, {pd.plz} {pd.ort}")

                            if st.button(f"üîÑ Neu erfassen", key=f"reupload_notar_v_{verkaeufer_id}"):
                                if f"ausweis_vorderseite_{verkaeufer_id}" in st.session_state:
                                    del st.session_state[f"ausweis_vorderseite_{verkaeufer_id}"]
                                if f"ausweis_rueckseite_{verkaeufer_id}" in st.session_state:
                                    del st.session_state[f"ausweis_rueckseite_{verkaeufer_id}"]
                                st.rerun()
                        else:
                            st.info("Ausweisdaten noch nicht erfasst.")
                            render_ausweis_upload(verkaeufer_id, UserRole.VERKAEUFER.value, context=f"notar_{verkaeufer_id}")
        else:
            st.info("Noch keine Verk√§ufer f√ºr dieses Projekt.")


# ============================================================================
# NOTAR DATENERMITTLUNG
# ============================================================================

def notar_datenermittlung_view():
    """Datenermittlung f√ºr Notar - Flurkarten, Grundbuch, Baulasten, Steuer-ID, Grunderwerbsteuer, Vorkaufsrecht"""
    st.subheader("üìã Datenermittlung")
    st.caption("Zentrale Stelle f√ºr alle beh√∂rdlichen Anfragen und Datenermittlungen zu Ihren Projekten.")

    notar_id = st.session_state.current_user.user_id

    # Projekte dieses Notars
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    if not projekte:
        st.info("Noch keine Projekte zugewiesen. Datenermittlung ist erst nach Projektzuweisung m√∂glich.")
        return

    # Projekt ausw√§hlen
    projekt_optionen = {p.projekt_id: f"{p.name} - {p.adresse or 'Keine Adresse'}" for p in projekte}
    selected_projekt_id = st.selectbox(
        "Projekt ausw√§hlen",
        options=list(projekt_optionen.keys()),
        format_func=lambda x: projekt_optionen[x],
        key="datenermittlung_projekt"
    )

    if not selected_projekt_id:
        return

    projekt = st.session_state.projekte.get(selected_projekt_id)
    if not projekt:
        return

    st.divider()

    # Tabs f√ºr verschiedene Bereiche
    daten_tabs = st.tabs([
        "üó∫Ô∏è Flurkarten",
        "üìö Grundbuch",
        "üèóÔ∏è Baulastenverzeichnis",
        "ü™™ Steuer-ID",
        "üí∞ Grunderwerbsteuer",
        "üèõÔ∏è Vorkaufsrecht"
    ])

    with daten_tabs[0]:
        _render_flurkarten_bereich(projekt, notar_id)

    with daten_tabs[1]:
        _render_grundbuch_bereich(projekt, notar_id)

    with daten_tabs[2]:
        _render_baulasten_bereich(projekt, notar_id)

    with daten_tabs[3]:
        _render_steuer_id_bereich(projekt, notar_id)

    with daten_tabs[4]:
        _render_grunderwerbsteuer_bereich(projekt, notar_id)

    with daten_tabs[5]:
        _render_vorkaufsrecht_bereich(projekt, notar_id)


def _render_flurkarten_bereich(projekt, notar_id: str):
    """Flurkarten elektronisch kaufen und herunterladen"""
    st.markdown("### üó∫Ô∏è Flurkarten")
    st.caption("Elektronischer Abruf von Flurkarten √ºber die Landesgeoportale.")

    # Bundesland aus Adresse ermitteln
    bundesland = _ermittle_bundesland_aus_adresse(projekt.adresse) if projekt.adresse else None

    # Geoportal-Info anzeigen
    if bundesland and bundesland in GEOPORTALE:
        portal = GEOPORTALE[bundesland]
        st.info(f"üìç **{bundesland}**: [{portal['name']}]({portal['url']})")

    # Bestehende Anfragen anzeigen
    anfragen = [a for a in st.session_state.flurkart_anfragen.values()
                if a.projekt_id == projekt.projekt_id]

    if anfragen:
        st.markdown("#### Bestehende Flurkart-Anfragen")
        for anfrage in anfragen:
            status_icon = _get_datenermittlung_status_icon(anfrage.status)
            with st.expander(f"{status_icon} {anfrage.gemarkung} - Flur {anfrage.flur}, Flurst√ºck {anfrage.flurstueck}"):
                col1, col2 = st.columns(2)
                with col1:
                    st.write(f"**Bundesland:** {anfrage.bundesland}")
                    st.write(f"**Landkreis:** {anfrage.landkreis}")
                    st.write(f"**Gemeinde:** {anfrage.gemeinde}")
                with col2:
                    st.write(f"**Status:** {anfrage.status}")
                    if anfrage.angefragt_am:
                        st.write(f"**Angefragt am:** {anfrage.angefragt_am.strftime('%d.%m.%Y %H:%M')}")
                    if anfrage.kosten:
                        st.write(f"**Kosten:** {anfrage.kosten:.2f} ‚Ç¨")

                if anfrage.flurkarte_pdf:
                    st.download_button(
                        "üì• Flurkarte herunterladen",
                        data=anfrage.flurkarte_pdf,
                        file_name=f"Flurkarte_{anfrage.gemarkung}_{anfrage.flurstueck}.pdf",
                        mime="application/pdf",
                        key=f"dl_flurkarte_{anfrage.anfrage_id}"
                    )

    # Neue Anfrage erstellen
    st.markdown("#### Neue Flurkarte anfordern")

    with st.form(key=f"flurkarte_form_{projekt.projekt_id}"):
        col1, col2 = st.columns(2)

        with col1:
            bundesland_input = st.selectbox(
                "Bundesland",
                options=list(GEOPORTALE.keys()),
                index=list(GEOPORTALE.keys()).index(bundesland) if bundesland in GEOPORTALE.keys() else 0,
                key=f"flurkarte_bundesland_{projekt.projekt_id}"
            )
            landkreis = st.text_input("Landkreis/Kreisfreie Stadt", key=f"flurkarte_landkreis_{projekt.projekt_id}")
            gemeinde = st.text_input("Gemeinde", key=f"flurkarte_gemeinde_{projekt.projekt_id}")

        with col2:
            gemarkung = st.text_input("Gemarkung", key=f"flurkarte_gemarkung_{projekt.projekt_id}")
            flur = st.text_input("Flur", key=f"flurkarte_flur_{projekt.projekt_id}")
            flurstueck = st.text_input("Flurst√ºck", key=f"flurkarte_flurstueck_{projekt.projekt_id}")

        if st.form_submit_button("üó∫Ô∏è Flurkarte anfordern", type="primary"):
            if gemarkung and flur and flurstueck:
                anfrage_id = f"FK-{datetime.now().strftime('%Y%m%d%H%M%S')}-{projekt.projekt_id[:8]}"
                neue_anfrage = FlurkartAnfrage(
                    anfrage_id=anfrage_id,
                    projekt_id=projekt.projekt_id,
                    notar_id=notar_id,
                    bundesland=bundesland_input,
                    landkreis=landkreis,
                    gemeinde=gemeinde,
                    gemarkung=gemarkung,
                    flur=flur,
                    flurstueck=flurstueck,
                    status=DatenermittlungStatus.ANGEFRAGT.value,
                    angefragt_am=datetime.now(),
                    portal_name=GEOPORTALE.get(bundesland_input, {}).get('name', ''),
                    portal_url=GEOPORTALE.get(bundesland_input, {}).get('url', '')
                )
                st.session_state.flurkart_anfragen[anfrage_id] = neue_anfrage
                st.success(f"‚úÖ Flurkarte-Anfrage erstellt! Portal: {neue_anfrage.portal_name}")
                st.rerun()
            else:
                st.error("Bitte Gemarkung, Flur und Flurst√ºck angeben.")


def _render_grundbuch_bereich(projekt, notar_id: str):
    """Elektronisches Grundbuch - Abruf je nach Bundesland"""
    st.markdown("### üìö Elektronisches Grundbuch")
    st.caption("Elektronischer Grundbuchabruf √ºber EGVP oder SolumSTAR je nach Bundesland-Unterst√ºtzung.")

    # Bundesland aus Adresse ermitteln
    bundesland = _ermittle_bundesland_aus_adresse(projekt.adresse) if projekt.adresse else None

    # Support-Info anzeigen
    if bundesland and bundesland in ELEKTRONISCHES_GRUNDBUCH_SUPPORT:
        support = ELEKTRONISCHES_GRUNDBUCH_SUPPORT[bundesland]
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("EGVP", "‚úÖ Ja" if support['egvp'] else "‚ùå Nein")
        with col2:
            st.metric("SolumSTAR", "‚úÖ Ja" if support['solum_star'] else "‚ùå Nein")
        with col3:
            st.info(f"Portal: {support['portal']}")

    # Bestehende Anfragen
    anfragen = [a for a in st.session_state.grundbuch_anfragen.values()
                if a.projekt_id == projekt.projekt_id]

    if anfragen:
        st.markdown("#### Bestehende Grundbuch-Anfragen")
        for anfrage in anfragen:
            status_icon = _get_datenermittlung_status_icon(anfrage.status)
            with st.expander(f"{status_icon} {anfrage.grundbuchamt} - Blatt {anfrage.grundbuchblatt}"):
                col1, col2 = st.columns(2)
                with col1:
                    st.write(f"**Grundbuchbezirk:** {anfrage.grundbuchbezirk}")
                    st.write(f"**Band:** {anfrage.band}")
                    st.write(f"**Abteilung:** {anfrage.abteilung or 'Alle'}")
                with col2:
                    st.write(f"**Status:** {anfrage.status}")
                    st.write(f"**Zugang:** {'EGVP' if anfrage.egvp_zugang else 'SolumSTAR' if anfrage.solum_star_zugang else 'Manuell'}")
                    if anfrage.abruf_datum:
                        st.write(f"**Abgerufen am:** {anfrage.abruf_datum.strftime('%d.%m.%Y %H:%M')}")

                if anfrage.grundbuchauszug_pdf:
                    st.download_button(
                        "üì• Grundbuchauszug herunterladen",
                        data=anfrage.grundbuchauszug_pdf,
                        file_name=f"Grundbuchauszug_{anfrage.grundbuchblatt}.pdf",
                        mime="application/pdf",
                        key=f"dl_grundbuch_{anfrage.anfrage_id}"
                    )

    # Neue Anfrage
    st.markdown("#### Neuen Grundbuchauszug anfordern")

    with st.form(key=f"grundbuch_form_{projekt.projekt_id}"):
        col1, col2 = st.columns(2)

        with col1:
            bundesland_input = st.selectbox(
                "Bundesland",
                options=list(ELEKTRONISCHES_GRUNDBUCH_SUPPORT.keys()),
                index=list(ELEKTRONISCHES_GRUNDBUCH_SUPPORT.keys()).index(bundesland) if bundesland and bundesland in ELEKTRONISCHES_GRUNDBUCH_SUPPORT else 0,
                key=f"grundbuch_bundesland_{projekt.projekt_id}"
            )
            grundbuchamt = st.text_input("Grundbuchamt", key=f"grundbuch_amt_{projekt.projekt_id}")
            grundbuchbezirk = st.text_input("Grundbuchbezirk", key=f"grundbuch_bezirk_{projekt.projekt_id}")

        with col2:
            grundbuchblatt = st.text_input("Grundbuchblatt", key=f"grundbuch_blatt_{projekt.projekt_id}")
            band = st.text_input("Band", key=f"grundbuch_band_{projekt.projekt_id}")
            abteilung = st.selectbox(
                "Abteilung",
                options=["Alle", "I (Eigentum)", "II (Lasten/Beschr√§nkungen)", "III (Grundpfandrechte)"],
                key=f"grundbuch_abteilung_{projekt.projekt_id}"
            )

        # Zugangsmethode
        support = ELEKTRONISCHES_GRUNDBUCH_SUPPORT.get(bundesland_input, {})
        zugang = st.radio(
            "Zugangsart",
            options=["EGVP", "SolumSTAR", "Manuell"],
            horizontal=True,
            key=f"grundbuch_zugang_{projekt.projekt_id}",
            help="EGVP = Elektronisches Gerichts- und Verwaltungspostfach"
        )

        if st.form_submit_button("üìö Grundbuchauszug anfordern", type="primary"):
            if grundbuchamt and grundbuchblatt:
                anfrage_id = f"GB-{datetime.now().strftime('%Y%m%d%H%M%S')}-{projekt.projekt_id[:8]}"
                neue_anfrage = GrundbuchAnfrage(
                    anfrage_id=anfrage_id,
                    projekt_id=projekt.projekt_id,
                    notar_id=notar_id,
                    bundesland=bundesland_input,
                    grundbuchamt=grundbuchamt,
                    grundbuchbezirk=grundbuchbezirk,
                    grundbuchblatt=grundbuchblatt,
                    band=band,
                    abteilung=None if abteilung == "Alle" else abteilung,
                    egvp_zugang=(zugang == "EGVP"),
                    solum_star_zugang=(zugang == "SolumSTAR"),
                    status=DatenermittlungStatus.ANGEFRAGT.value,
                    angefragt_am=datetime.now()
                )
                st.session_state.grundbuch_anfragen[anfrage_id] = neue_anfrage
                st.success(f"‚úÖ Grundbuch-Anfrage erstellt! Zugang: {zugang}")
                st.rerun()
            else:
                st.error("Bitte Grundbuchamt und Grundbuchblatt angeben.")


def _render_baulasten_bereich(projekt, notar_id: str):
    """Baulastenverzeichnis beim zust√§ndigen Bauamt"""
    st.markdown("### üèóÔ∏è Baulastenverzeichnis")
    st.caption("Anfrage an das zust√§ndige Bauamt f√ºr Eintragungen im Baulastenverzeichnis.")

    st.info("üí° **Hinweis:** In Bayern und Brandenburg gibt es kein Baulastenverzeichnis - dort werden Baulasten im Grundbuch eingetragen.")

    # Bestehende Anfragen
    anfragen = [a for a in st.session_state.baulasten_anfragen.values()
                if a.projekt_id == projekt.projekt_id]

    if anfragen:
        st.markdown("#### Bestehende Baulasten-Anfragen")
        for anfrage in anfragen:
            status_icon = _get_datenermittlung_status_icon(anfrage.status)
            with st.expander(f"{status_icon} {anfrage.bauamt_name} - {anfrage.flurstueck}"):
                col1, col2 = st.columns(2)
                with col1:
                    st.write(f"**Bauamt:** {anfrage.bauamt_name}")
                    st.write(f"**Adresse:** {anfrage.bauamt_adresse}")
                    if anfrage.bauamt_ansprechpartner:
                        st.write(f"**Ansprechpartner:** {anfrage.bauamt_ansprechpartner}")
                with col2:
                    st.write(f"**Status:** {anfrage.status}")
                    if anfrage.angefragt_am:
                        st.write(f"**Angefragt am:** {anfrage.angefragt_am.strftime('%d.%m.%Y')}")
                    st.write(f"**Baulasten vorhanden:** {'Ja' if anfrage.baulasten_vorhanden else 'Nein' if anfrage.baulasten_vorhanden is False else 'Unbekannt'}")

                if anfrage.baulastenverzeichnis_pdf:
                    st.download_button(
                        "üì• Baulastenverzeichnis herunterladen",
                        data=anfrage.baulastenverzeichnis_pdf,
                        file_name=f"Baulastenverzeichnis_{anfrage.flurstueck}.pdf",
                        mime="application/pdf",
                        key=f"dl_baulasten_{anfrage.anfrage_id}"
                    )

    # Neue Anfrage
    st.markdown("#### Neue Baulasten-Anfrage")

    with st.form(key=f"baulasten_form_{projekt.projekt_id}"):
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("**Zust√§ndiges Bauamt**")
            bauamt_name = st.text_input("Name des Bauamts", key=f"baulasten_amt_{projekt.projekt_id}")
            bauamt_adresse = st.text_input("Adresse", key=f"baulasten_adresse_{projekt.projekt_id}")
            bauamt_telefon = st.text_input("Telefon", key=f"baulasten_telefon_{projekt.projekt_id}")
            bauamt_email = st.text_input("E-Mail", key=f"baulasten_email_{projekt.projekt_id}")
            bauamt_ansprechpartner = st.text_input("Ansprechpartner (optional)", key=f"baulasten_ansprech_{projekt.projekt_id}")

        with col2:
            st.markdown("**Grundst√ºcksdaten**")
            objekt_adresse = st.text_input("Objekt-Adresse", value=projekt.adresse or "", key=f"baulasten_objekt_{projekt.projekt_id}")
            gemarkung = st.text_input("Gemarkung", key=f"baulasten_gemarkung_{projekt.projekt_id}")
            flur = st.text_input("Flur", key=f"baulasten_flur_{projekt.projekt_id}")
            flurstueck = st.text_input("Flurst√ºck", key=f"baulasten_flurstueck_{projekt.projekt_id}")

        if st.form_submit_button("üèóÔ∏è Baulasten-Anfrage senden", type="primary"):
            if bauamt_name and flurstueck:
                anfrage_id = f"BL-{datetime.now().strftime('%Y%m%d%H%M%S')}-{projekt.projekt_id[:8]}"
                neue_anfrage = BaulastenAnfrage(
                    anfrage_id=anfrage_id,
                    projekt_id=projekt.projekt_id,
                    notar_id=notar_id,
                    bauamt_name=bauamt_name,
                    bauamt_adresse=bauamt_adresse,
                    bauamt_telefon=bauamt_telefon,
                    bauamt_email=bauamt_email,
                    bauamt_ansprechpartner=bauamt_ansprechpartner,
                    objekt_adresse=objekt_adresse,
                    gemarkung=gemarkung,
                    flur=flur,
                    flurstueck=flurstueck,
                    status=DatenermittlungStatus.ANGEFRAGT.value,
                    angefragt_am=datetime.now()
                )
                st.session_state.baulasten_anfragen[anfrage_id] = neue_anfrage
                st.success("‚úÖ Baulasten-Anfrage erstellt!")
                st.rerun()
            else:
                st.error("Bitte Bauamt und Flurst√ºck angeben.")


def _render_steuer_id_bereich(projekt, notar_id: str):
    """Steuer-ID Abfrage basierend auf Wohnort von K√§ufer/Verk√§ufer"""
    st.markdown("### ü™™ Steuer-ID Abfrage")
    st.caption("Abfrage der Steuer-Identifikationsnummer beim Bundeszentralamt f√ºr Steuern (BZSt).")

    st.info("üí° **Hinweis:** Die Steuer-ID wird f√ºr die Grunderwerbsteuer-Anmeldung ben√∂tigt. Die Abfrage erfolgt beim BZSt basierend auf dem Wohnort der Person.")

    # K√§ufer und Verk√§ufer sammeln
    parteien = []
    for kid in projekt.kaeufer_ids:
        kaeufer = st.session_state.users.get(kid)
        if kaeufer:
            parteien.append({"id": kid, "name": kaeufer.name, "rolle": "K√§ufer", "user": kaeufer})

    for vid in projekt.verkaeufer_ids:
        verkaeufer = st.session_state.users.get(vid)
        if verkaeufer:
            parteien.append({"id": vid, "name": verkaeufer.name, "rolle": "Verk√§ufer", "user": verkaeufer})

    if not parteien:
        st.warning("Keine K√§ufer oder Verk√§ufer f√ºr dieses Projekt gefunden.")
        return

    # Bestehende Abfragen
    abfragen = [a for a in st.session_state.steuer_id_abfragen.values()
                if a.projekt_id == projekt.projekt_id]

    if abfragen:
        st.markdown("#### Bestehende Steuer-ID Abfragen")
        for abfrage in abfragen:
            status_icon = _get_datenermittlung_status_icon(abfrage.status)
            with st.expander(f"{status_icon} {abfrage.person_name} ({abfrage.person_rolle})"):
                col1, col2 = st.columns(2)
                with col1:
                    st.write(f"**Name:** {abfrage.person_name}")
                    st.write(f"**Rolle:** {abfrage.person_rolle}")
                    st.write(f"**Wohnort:** {abfrage.wohnort_plz} {abfrage.wohnort_ort}")
                with col2:
                    st.write(f"**Status:** {abfrage.status}")
                    if abfrage.steuer_id:
                        st.write(f"**Steuer-ID:** {abfrage.steuer_id}")
                    if abfrage.finanzamt:
                        st.write(f"**Zust√§ndiges FA:** {abfrage.finanzamt}")

    # Neue Abfrage
    st.markdown("#### Neue Steuer-ID Abfrage")

    with st.form(key=f"steuer_id_form_{projekt.projekt_id}"):
        # Person ausw√§hlen
        person_optionen = {p["id"]: f"{p['name']} ({p['rolle']})" for p in parteien}
        selected_person_id = st.selectbox(
            "Person ausw√§hlen",
            options=list(person_optionen.keys()),
            format_func=lambda x: person_optionen[x],
            key=f"steuer_id_person_{projekt.projekt_id}"
        )

        selected_person = next((p for p in parteien if p["id"] == selected_person_id), None)

        col1, col2 = st.columns(2)

        with col1:
            geburtsdatum = st.date_input(
                "Geburtsdatum",
                min_value=date(1900, 1, 1),
                max_value=date.today(),
                key=f"steuer_id_geburt_{projekt.projekt_id}"
            )
            geburtsort = st.text_input("Geburtsort", key=f"steuer_id_geburtsort_{projekt.projekt_id}")

        with col2:
            wohnort_strasse = st.text_input("Stra√üe und Hausnummer", key=f"steuer_id_strasse_{projekt.projekt_id}")
            col_plz, col_ort = st.columns([1, 2])
            with col_plz:
                wohnort_plz = st.text_input("PLZ", key=f"steuer_id_plz_{projekt.projekt_id}")
            with col_ort:
                wohnort_ort = st.text_input("Ort", key=f"steuer_id_ort_{projekt.projekt_id}")

        if st.form_submit_button("ü™™ Steuer-ID abfragen", type="primary"):
            if selected_person and geburtsdatum and wohnort_plz and wohnort_ort:
                abfrage_id = f"SID-{datetime.now().strftime('%Y%m%d%H%M%S')}-{selected_person_id[:8]}"
                neue_abfrage = SteuerIDAbfrage(
                    abfrage_id=abfrage_id,
                    projekt_id=projekt.projekt_id,
                    notar_id=notar_id,
                    person_id=selected_person_id,
                    person_name=selected_person["name"],
                    person_rolle=selected_person["rolle"],
                    geburtsdatum=geburtsdatum,
                    geburtsort=geburtsort,
                    wohnort_strasse=wohnort_strasse,
                    wohnort_plz=wohnort_plz,
                    wohnort_ort=wohnort_ort,
                    status=DatenermittlungStatus.ANGEFRAGT.value,
                    angefragt_am=datetime.now()
                )
                st.session_state.steuer_id_abfragen[abfrage_id] = neue_abfrage
                st.success("‚úÖ Steuer-ID Abfrage beim BZSt erstellt!")
                st.rerun()
            else:
                st.error("Bitte alle Pflichtfelder ausf√ºllen.")


def _render_grunderwerbsteuer_bereich(projekt, notar_id: str):
    """Grunderwerbsteuer Meldung ans Finanzamt"""
    st.markdown("### üí∞ Grunderwerbsteuer")
    st.caption("Anzeige des Kaufvertrags an das zust√§ndige Finanzamt f√ºr die Grunderwerbsteuer-Festsetzung.")

    # Bundesland und Steuersatz ermitteln
    bundesland = _ermittle_bundesland_aus_adresse(projekt.adresse) if projekt.adresse else None

    if bundesland and bundesland in GRUNDERWERBSTEUER_SAETZE:
        steuersatz = GRUNDERWERBSTEUER_SAETZE[bundesland]
        kaufpreis = projekt.kaufpreis or 0
        steuer = kaufpreis * steuersatz / 100

        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Bundesland", bundesland)
        with col2:
            st.metric("Steuersatz", f"{steuersatz:.1f}%")
        with col3:
            st.metric("Voraussichtliche Steuer", f"{steuer:,.2f} ‚Ç¨")
    else:
        st.warning("Bundesland konnte nicht ermittelt werden. Bitte Objekt-Adresse im Projekt hinterlegen.")

    # Bestehende Meldungen
    meldungen = [m for m in st.session_state.grunderwerbsteuer_meldungen.values()
                 if m.projekt_id == projekt.projekt_id]

    if meldungen:
        st.markdown("#### Bestehende Grunderwerbsteuer-Meldungen")
        for meldung in meldungen:
            status_icon = _get_datenermittlung_status_icon(meldung.status)
            with st.expander(f"{status_icon} UR-Nr. {meldung.urkundennummer} - {meldung.finanzamt}"):
                col1, col2 = st.columns(2)
                with col1:
                    st.write(f"**Finanzamt:** {meldung.finanzamt}")
                    st.write(f"**Kaufpreis:** {meldung.kaufpreis:,.2f} ‚Ç¨")
                    st.write(f"**Steuersatz:** {meldung.steuersatz:.1f}%")
                    st.write(f"**Steuerbetrag:** {meldung.steuerbetrag:,.2f} ‚Ç¨")
                with col2:
                    st.write(f"**Status:** {meldung.status}")
                    if meldung.gemeldet_am:
                        st.write(f"**Gemeldet am:** {meldung.gemeldet_am.strftime('%d.%m.%Y')}")
                    if meldung.steuerbescheid_erhalten:
                        st.write("‚úÖ Steuerbescheid erhalten")
                        if meldung.zahlungsfrist:
                            st.write(f"**Zahlungsfrist:** {meldung.zahlungsfrist.strftime('%d.%m.%Y')}")
                    if meldung.unbedenklichkeitsbescheinigung:
                        st.write("‚úÖ Unbedenklichkeitsbescheinigung erhalten")

    # Neue Meldung
    st.markdown("#### Neue Grunderwerbsteuer-Anzeige")

    with st.form(key=f"grest_form_{projekt.projekt_id}"):
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("**Finanzamt**")
            finanzamt = st.text_input("Zust√§ndiges Finanzamt", key=f"grest_finanzamt_{projekt.projekt_id}")
            finanzamt_adresse = st.text_input("Adresse des Finanzamts", key=f"grest_fa_adresse_{projekt.projekt_id}")
            steuernummer_verkaeufer = st.text_input("Steuernummer Verk√§ufer (optional)", key=f"grest_stnr_v_{projekt.projekt_id}")

        with col2:
            st.markdown("**Kaufvertragsdaten**")
            urkundennummer = st.text_input("Urkundennummer", key=f"grest_urnr_{projekt.projekt_id}")
            kaufvertrag_datum = st.date_input("Datum des Kaufvertrags", key=f"grest_datum_{projekt.projekt_id}")
            kaufpreis_input = st.number_input(
                "Kaufpreis (‚Ç¨)",
                min_value=0.0,
                value=float(projekt.kaufpreis or 0),
                key=f"grest_kaufpreis_{projekt.projekt_id}"
            )

            # Steuersatz basierend auf Bundesland
            bundesland_input = st.selectbox(
                "Bundesland (f√ºr Steuersatz)",
                options=list(GRUNDERWERBSTEUER_SAETZE.keys()),
                index=list(GRUNDERWERBSTEUER_SAETZE.keys()).index(bundesland) if bundesland and bundesland in GRUNDERWERBSTEUER_SAETZE else 0,
                key=f"grest_bundesland_{projekt.projekt_id}"
            )

        steuersatz_aktuell = GRUNDERWERBSTEUER_SAETZE.get(bundesland_input, 5.0)
        steuerbetrag_aktuell = kaufpreis_input * steuersatz_aktuell / 100
        st.info(f"**Berechnete Grunderwerbsteuer:** {steuerbetrag_aktuell:,.2f} ‚Ç¨ ({steuersatz_aktuell:.1f}%)")

        if st.form_submit_button("üí∞ Grunderwerbsteuer anzeigen", type="primary"):
            if finanzamt and urkundennummer and kaufpreis_input > 0:
                meldung_id = f"GREST-{datetime.now().strftime('%Y%m%d%H%M%S')}-{projekt.projekt_id[:8]}"
                neue_meldung = GrunderwerbsteuerMeldung(
                    meldung_id=meldung_id,
                    projekt_id=projekt.projekt_id,
                    notar_id=notar_id,
                    finanzamt=finanzamt,
                    finanzamt_adresse=finanzamt_adresse,
                    bundesland=bundesland_input,
                    kaufpreis=kaufpreis_input,
                    steuersatz=steuersatz_aktuell,
                    steuerbetrag=steuerbetrag_aktuell,
                    urkundennummer=urkundennummer,
                    kaufvertrag_datum=kaufvertrag_datum,
                    steuernummer_verkaeufer=steuernummer_verkaeufer,
                    status=DatenermittlungStatus.ANGEFRAGT.value,
                    gemeldet_am=datetime.now()
                )
                st.session_state.grunderwerbsteuer_meldungen[meldung_id] = neue_meldung
                st.success("‚úÖ Grunderwerbsteuer-Anzeige an das Finanzamt erstellt!")
                st.rerun()
            else:
                st.error("Bitte Finanzamt, Urkundennummer und Kaufpreis angeben.")


def _render_vorkaufsrecht_bereich(projekt, notar_id: str):
    """Anfrage auf Vorkaufsrecht an Gemeinde/Stadt"""
    st.markdown("### üèõÔ∏è Vorkaufsrecht")
    st.caption("Anfrage an die Gemeinde/Stadt, ob ein gesetzliches Vorkaufsrecht ausge√ºbt wird.")

    st.info("üí° **Hinweis:** Die Gemeinde hat nach ¬ß 28 BauGB ein Vorkaufsrecht bei bestimmten Grundst√ºcksverk√§ufen. "
            "Sie muss innerhalb von 2 Monaten nach Anzeige entscheiden, ob sie das Vorkaufsrecht aus√ºbt. "
            "Nach Verzicht erh√§lt der Notar ein Negativzeugnis.")

    # Bestehende Anfragen
    anfragen = [a for a in st.session_state.vorkaufsrecht_anfragen.values()
                if a.projekt_id == projekt.projekt_id]

    if anfragen:
        st.markdown("#### Bestehende Vorkaufsrecht-Anfragen")
        for anfrage in anfragen:
            status_icon = _get_datenermittlung_status_icon(anfrage.status)

            # Farbcodierung basierend auf Ergebnis
            if anfrage.vorkaufsrecht_ausgeubt is True:
                titel_zusatz = "‚ö†Ô∏è AUSGE√úBT"
            elif anfrage.vorkaufsrecht_ausgeubt is False:
                titel_zusatz = "‚úÖ Verzichtet"
            else:
                titel_zusatz = "‚è≥ Ausstehend"

            with st.expander(f"{status_icon} {anfrage.gemeinde_name} - {titel_zusatz}"):
                col1, col2 = st.columns(2)
                with col1:
                    st.write(f"**Gemeinde/Stadt:** {anfrage.gemeinde_name}")
                    if anfrage.gemeinde_adresse:
                        st.write(f"**Adresse:** {anfrage.gemeinde_adresse}")
                    if anfrage.gemeinde_ansprechpartner:
                        st.write(f"**Ansprechpartner:** {anfrage.gemeinde_ansprechpartner}")
                    st.write(f"**Objekt:** {anfrage.objekt_adresse}")
                with col2:
                    st.write(f"**Status:** {anfrage.status}")
                    if anfrage.angefragt_am:
                        st.write(f"**Angefragt am:** {anfrage.angefragt_am.strftime('%d.%m.%Y')}")
                    if anfrage.frist_bis:
                        tage_bis_frist = (anfrage.frist_bis - date.today()).days
                        if tage_bis_frist > 0:
                            st.write(f"**Frist bis:** {anfrage.frist_bis.strftime('%d.%m.%Y')} ({tage_bis_frist} Tage)")
                        else:
                            st.write(f"**Frist abgelaufen:** {anfrage.frist_bis.strftime('%d.%m.%Y')}")

                    if anfrage.vorkaufsrecht_ausgeubt is True:
                        st.error(f"‚ö†Ô∏è Vorkaufsrecht ausge√ºbt! Grund: {anfrage.vorkaufsrecht_grund}")
                    elif anfrage.vorkaufsrecht_ausgeubt is False:
                        st.success("‚úÖ Vorkaufsrecht nicht ausge√ºbt - Negativzeugnis erhalten")

                if anfrage.negativzeugnis_pdf:
                    st.download_button(
                        "üì• Negativzeugnis herunterladen",
                        data=anfrage.negativzeugnis_pdf,
                        file_name=f"Negativzeugnis_{anfrage.gemeinde_name}_{projekt.projekt_id[:8]}.pdf",
                        mime="application/pdf",
                        key=f"dl_negativ_{anfrage.anfrage_id}"
                    )

    # Neue Anfrage
    st.markdown("#### Neue Vorkaufsrecht-Anfrage")

    with st.form(key=f"vorkaufsrecht_form_{projekt.projekt_id}"):
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("**Gemeinde/Stadt**")
            gemeinde_name = st.text_input("Name der Gemeinde/Stadt", key=f"vkr_gemeinde_{projekt.projekt_id}")
            gemeinde_adresse = st.text_input("Adresse", key=f"vkr_adresse_{projekt.projekt_id}")
            gemeinde_telefon = st.text_input("Telefon", key=f"vkr_telefon_{projekt.projekt_id}")
            gemeinde_email = st.text_input("E-Mail", key=f"vkr_email_{projekt.projekt_id}")
            gemeinde_ansprechpartner = st.text_input("Ansprechpartner (optional)", key=f"vkr_ansprech_{projekt.projekt_id}")

        with col2:
            st.markdown("**Objektdaten**")
            objekt_adresse = st.text_input("Objekt-Adresse", value=projekt.adresse or "", key=f"vkr_objekt_{projekt.projekt_id}")
            gemarkung = st.text_input("Gemarkung", key=f"vkr_gemarkung_{projekt.projekt_id}")
            flur = st.text_input("Flur", key=f"vkr_flur_{projekt.projekt_id}")
            flurstueck = st.text_input("Flurst√ºck", key=f"vkr_flurstueck_{projekt.projekt_id}")
            grundstuecksgroesse = st.number_input("Grundst√ºcksgr√∂√üe (qm)", min_value=0.0, key=f"vkr_groesse_{projekt.projekt_id}")

        st.markdown("**Kaufvertragsdaten**")
        col3, col4 = st.columns(2)
        with col3:
            kaufpreis = st.number_input(
                "Kaufpreis (‚Ç¨)",
                min_value=0.0,
                value=float(projekt.kaufpreis or 0),
                key=f"vkr_kaufpreis_{projekt.projekt_id}"
            )
            urkundennummer = st.text_input("Urkundennummer", key=f"vkr_urnr_{projekt.projekt_id}")
        with col4:
            kaufvertrag_datum = st.date_input("Datum des Kaufvertrags", key=f"vkr_datum_{projekt.projekt_id}")

        if st.form_submit_button("üèõÔ∏è Vorkaufsrecht-Anfrage senden", type="primary"):
            if gemeinde_name and objekt_adresse:
                anfrage_id = f"VKR-{datetime.now().strftime('%Y%m%d%H%M%S')}-{projekt.projekt_id[:8]}"
                frist = date.today() + timedelta(days=60)  # 2 Monate Frist

                neue_anfrage = VorkaufsrechtAnfrage(
                    anfrage_id=anfrage_id,
                    projekt_id=projekt.projekt_id,
                    notar_id=notar_id,
                    gemeinde_name=gemeinde_name,
                    gemeinde_adresse=gemeinde_adresse,
                    gemeinde_telefon=gemeinde_telefon,
                    gemeinde_email=gemeinde_email,
                    gemeinde_ansprechpartner=gemeinde_ansprechpartner,
                    objekt_adresse=objekt_adresse,
                    gemarkung=gemarkung,
                    flur=flur,
                    flurstueck=flurstueck,
                    grundstuecksgroesse_qm=grundstuecksgroesse,
                    kaufpreis=kaufpreis,
                    urkundennummer=urkundennummer,
                    kaufvertrag_datum=kaufvertrag_datum,
                    status=DatenermittlungStatus.ANGEFRAGT.value,
                    angefragt_am=datetime.now(),
                    frist_bis=frist
                )
                st.session_state.vorkaufsrecht_anfragen[anfrage_id] = neue_anfrage
                st.success(f"‚úÖ Vorkaufsrecht-Anfrage an {gemeinde_name} erstellt! Frist: {frist.strftime('%d.%m.%Y')}")
                st.rerun()
            else:
                st.error("Bitte Gemeinde/Stadt und Objekt-Adresse angeben.")


def _get_datenermittlung_status_icon(status: str) -> str:
    """Gibt das passende Icon f√ºr den Datenermittlungs-Status zur√ºck"""
    icons = {
        DatenermittlungStatus.AUSSTEHEND.value: "‚è≥",
        DatenermittlungStatus.ANGEFRAGT.value: "üì§",
        DatenermittlungStatus.IN_BEARBEITUNG.value: "üîÑ",
        DatenermittlungStatus.ERHALTEN.value: "‚úÖ",
        DatenermittlungStatus.FEHLER.value: "‚ùå",
        DatenermittlungStatus.NICHT_VERFUEGBAR.value: "üö´"
    }
    return icons.get(status, "‚ùì")


def _ermittle_bundesland_aus_adresse(adresse: str) -> Optional[str]:
    """Versucht das Bundesland aus einer Adresse zu ermitteln"""
    if not adresse:
        return None

    adresse_lower = adresse.lower()

    # PLZ-Bereiche f√ºr Bundesl√§nder (vereinfacht)
    plz_mapping = {
        "01": "Sachsen", "02": "Sachsen", "03": "Brandenburg", "04": "Sachsen",
        "06": "Sachsen-Anhalt", "07": "Th√ºringen", "08": "Sachsen", "09": "Sachsen",
        "10": "Berlin", "12": "Berlin", "13": "Berlin", "14": "Brandenburg",
        "15": "Brandenburg", "16": "Brandenburg", "17": "Mecklenburg-Vorpommern",
        "18": "Mecklenburg-Vorpommern", "19": "Mecklenburg-Vorpommern",
        "20": "Hamburg", "21": "Niedersachsen", "22": "Hamburg", "23": "Schleswig-Holstein",
        "24": "Schleswig-Holstein", "25": "Schleswig-Holstein", "26": "Niedersachsen",
        "27": "Niedersachsen", "28": "Bremen", "29": "Niedersachsen",
        "30": "Niedersachsen", "31": "Niedersachsen", "32": "Nordrhein-Westfalen",
        "33": "Nordrhein-Westfalen", "34": "Hessen", "35": "Hessen", "36": "Hessen",
        "37": "Niedersachsen", "38": "Niedersachsen", "39": "Sachsen-Anhalt",
        "40": "Nordrhein-Westfalen", "41": "Nordrhein-Westfalen", "42": "Nordrhein-Westfalen",
        "44": "Nordrhein-Westfalen", "45": "Nordrhein-Westfalen", "46": "Nordrhein-Westfalen",
        "47": "Nordrhein-Westfalen", "48": "Nordrhein-Westfalen", "49": "Niedersachsen",
        "50": "Nordrhein-Westfalen", "51": "Nordrhein-Westfalen", "52": "Nordrhein-Westfalen",
        "53": "Nordrhein-Westfalen", "54": "Rheinland-Pfalz", "55": "Rheinland-Pfalz",
        "56": "Rheinland-Pfalz", "57": "Nordrhein-Westfalen", "58": "Nordrhein-Westfalen",
        "59": "Nordrhein-Westfalen",
        "60": "Hessen", "61": "Hessen", "63": "Hessen", "64": "Hessen", "65": "Hessen",
        "66": "Saarland", "67": "Rheinland-Pfalz", "68": "Baden-W√ºrttemberg", "69": "Baden-W√ºrttemberg",
        "70": "Baden-W√ºrttemberg", "71": "Baden-W√ºrttemberg", "72": "Baden-W√ºrttemberg",
        "73": "Baden-W√ºrttemberg", "74": "Baden-W√ºrttemberg", "75": "Baden-W√ºrttemberg",
        "76": "Baden-W√ºrttemberg", "77": "Baden-W√ºrttemberg", "78": "Baden-W√ºrttemberg",
        "79": "Baden-W√ºrttemberg",
        "80": "Bayern", "81": "Bayern", "82": "Bayern", "83": "Bayern", "84": "Bayern",
        "85": "Bayern", "86": "Bayern", "87": "Bayern", "88": "Baden-W√ºrttemberg",
        "89": "Baden-W√ºrttemberg",
        "90": "Bayern", "91": "Bayern", "92": "Bayern", "93": "Bayern", "94": "Bayern",
        "95": "Bayern", "96": "Bayern", "97": "Bayern", "98": "Th√ºringen", "99": "Th√ºringen"
    }

    # PLZ aus Adresse extrahieren
    import re
    plz_match = re.search(r'\b(\d{5})\b', adresse)
    if plz_match:
        plz_prefix = plz_match.group(1)[:2]
        if plz_prefix in plz_mapping:
            return plz_mapping[plz_prefix]

    # Direkte Suche nach Bundesland-Namen
    bundeslaender = list(GRUNDERWERBSTEUER_SAETZE.keys())
    for bl in bundeslaender:
        if bl.lower() in adresse_lower:
            return bl

    return None


def notar_rechtsdokumente_view():
    """Verwaltung von Datenschutz, AGB und Widerrufsbelehrung"""
    st.subheader("üìú Rechtsdokumente verwalten")
    st.caption("Hier k√∂nnen Sie die rechtlichen Dokumente verwalten, die K√§ufer und Verk√§ufer akzeptieren m√ºssen.")

    notar_id = st.session_state.current_user.user_id

    # Sicherstellen dass notar_rechtsdokumente existiert
    if 'notar_rechtsdokumente' not in st.session_state:
        st.session_state.notar_rechtsdokumente = {}

    # Aktuelle Dokumente laden oder Standard erstellen
    if notar_id not in st.session_state.notar_rechtsdokumente:
        st.session_state.notar_rechtsdokumente[notar_id] = {}

    dokumente = st.session_state.notar_rechtsdokumente[notar_id]

    # Tabs f√ºr verschiedene Dokumente
    doc_tabs = st.tabs(["üìã Datenschutzerkl√§rung", "üìã AGB", "üìã Widerrufsbelehrung", "üìä Akzeptanz-Status"])

    with doc_tabs[0]:
        render_rechtsdokument_editor(notar_id, "datenschutz", "Datenschutzerkl√§rung")

    with doc_tabs[1]:
        render_rechtsdokument_editor(notar_id, "agb", "Allgemeine Gesch√§ftsbedingungen")

    with doc_tabs[2]:
        render_rechtsdokument_editor(notar_id, "widerruf", "Widerrufsbelehrung")

    with doc_tabs[3]:
        render_rechtsdokument_akzeptanz_status(notar_id)


def render_rechtsdokument_editor(notar_id: str, doc_type: str, doc_title: str):
    """Rendert den Editor f√ºr ein Rechtsdokument"""

    dokumente = st.session_state.notar_rechtsdokumente.get(notar_id, {})
    doc = dokumente.get(doc_type, {})

    st.markdown(f"### {doc_title}")

    if doc:
        st.success(f"‚úÖ {doc_title} ist konfiguriert (Version {doc.get('version', '1.0')})")
        st.caption(f"G√ºltig ab: {doc.get('gueltig_ab', 'Nicht gesetzt')}")

        with st.expander("üìÑ Aktuellen Inhalt anzeigen", expanded=False):
            st.markdown(doc.get('inhalt', ''))

    with st.form(f"form_{doc_type}_{notar_id}"):
        st.markdown("#### Dokument bearbeiten")

        titel = st.text_input(
            "Titel",
            value=doc.get('titel', doc_title),
            key=f"titel_{doc_type}_{notar_id}"
        )

        inhalt = st.text_area(
            "Inhalt (Markdown unterst√ºtzt)",
            value=doc.get('inhalt', ''),
            height=300,
            key=f"inhalt_{doc_type}_{notar_id}",
            placeholder=f"Geben Sie hier den vollst√§ndigen Text der {doc_title} ein..."
        )

        col1, col2 = st.columns(2)
        with col1:
            version = st.text_input(
                "Version",
                value=doc.get('version', '1.0'),
                key=f"version_{doc_type}_{notar_id}"
            )
        with col2:
            gueltig_ab = st.date_input(
                "G√ºltig ab",
                value=doc.get('gueltig_ab', date.today()),
                key=f"gueltig_{doc_type}_{notar_id}"
            )

        pflicht = st.checkbox(
            "Pflichtdokument (muss akzeptiert werden)",
            value=doc.get('pflicht', True),
            key=f"pflicht_{doc_type}_{notar_id}"
        )

        submitted = st.form_submit_button("üíæ Dokument speichern", type="primary")

        if submitted:
            if not inhalt.strip():
                st.error("Bitte geben Sie einen Inhalt ein.")
            else:
                if notar_id not in st.session_state.notar_rechtsdokumente:
                    st.session_state.notar_rechtsdokumente[notar_id] = {}

                st.session_state.notar_rechtsdokumente[notar_id][doc_type] = {
                    'titel': titel,
                    'inhalt': inhalt,
                    'version': version,
                    'gueltig_ab': gueltig_ab,
                    'pflicht': pflicht
                }
                st.success(f"‚úÖ {doc_title} wurde gespeichert!")
                st.rerun()


def render_rechtsdokument_akzeptanz_status(notar_id: str):
    """Zeigt den Akzeptanz-Status der Rechtsdokumente f√ºr alle K√§ufer und Verk√§ufer"""

    st.markdown("### üìä Akzeptanz-√úbersicht")

    # Projekte des Notars
    projekte = [p for p in st.session_state.projekte.values() if p.notar_id == notar_id]

    if not projekte:
        st.info("Noch keine Projekte zugewiesen.")
        return

    # Akzeptanzen laden
    akzeptanzen = st.session_state.get('rechtsdokument_akzeptanzen', {})

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
            # K√§ufer
            st.markdown("**K√§ufer:**")
            for kaeufer_id in projekt.kaeufer_ids:
                kaeufer = st.session_state.users.get(kaeufer_id)
                if kaeufer:
                    user_akzeptanz = akzeptanzen.get(kaeufer_id, {}).get(notar_id, {})
                    col1, col2, col3, col4 = st.columns(4)

                    with col1:
                        st.write(f"üë§ {kaeufer.name}")

                    with col2:
                        if user_akzeptanz.get('datenschutz'):
                            st.success("‚úÖ Datenschutz")
                        else:
                            st.warning("‚è≥ Datenschutz")

                    with col3:
                        if user_akzeptanz.get('agb'):
                            st.success("‚úÖ AGB")
                        else:
                            st.warning("‚è≥ AGB")

                    with col4:
                        if user_akzeptanz.get('widerruf'):
                            st.success("‚úÖ Widerruf")
                        else:
                            st.warning("‚è≥ Widerruf")

            # Verk√§ufer
            st.markdown("**Verk√§ufer:**")
            for verkaeufer_id in projekt.verkaeufer_ids:
                verkaeufer = st.session_state.users.get(verkaeufer_id)
                if verkaeufer:
                    user_akzeptanz = akzeptanzen.get(verkaeufer_id, {}).get(notar_id, {})
                    col1, col2, col3, col4 = st.columns(4)

                    with col1:
                        st.write(f"üë§ {verkaeufer.name}")

                    with col2:
                        if user_akzeptanz.get('datenschutz'):
                            st.success("‚úÖ Datenschutz")
                        else:
                            st.warning("‚è≥ Datenschutz")

                    with col3:
                        if user_akzeptanz.get('agb'):
                            st.success("‚úÖ AGB")
                        else:
                            st.warning("‚è≥ AGB")

                    with col4:
                        if user_akzeptanz.get('widerruf'):
                            st.success("‚úÖ Widerruf")
                        else:
                            st.warning("‚è≥ Widerruf")


def get_user_notar_ids(user_id: str, rolle: str, nur_mit_rechtsdokument_pflicht: bool = True) -> List[str]:
    """
    Ermittelt alle Notar-IDs f√ºr Projekte des Benutzers.

    Args:
        user_id: Die Benutzer-ID
        rolle: Die Rolle des Benutzers (K√§ufer/Verk√§ufer)
        nur_mit_rechtsdokument_pflicht: Wenn True, nur Notare von Projekten wo Rechtsdokumente erforderlich sind

    Returns:
        Liste der Notar-IDs
    """
    notar_ids = set()
    for projekt in st.session_state.projekte.values():
        # Pr√ºfen ob Rechtsdokumente f√ºr dieses Projekt erforderlich sind
        rechtsdokumente_erforderlich = getattr(projekt, 'rechtsdokumente_erforderlich', True)

        if nur_mit_rechtsdokument_pflicht and not rechtsdokumente_erforderlich:
            continue  # √úberspringen wenn nicht erforderlich

        if rolle == UserRole.KAEUFER.value and user_id in projekt.kaeufer_ids:
            if projekt.notar_id:
                notar_ids.add(projekt.notar_id)
        elif rolle == UserRole.VERKAEUFER.value and user_id in projekt.verkaeufer_ids:
            if projekt.notar_id:
                notar_ids.add(projekt.notar_id)
    return list(notar_ids)


def check_rechtsdokumente_akzeptiert(user_id: str, notar_id: str) -> Tuple[bool, List[str]]:
    """
    Pr√ºft ob der User alle Pflicht-Rechtsdokumente des Notars akzeptiert hat.
    Gibt (alle_akzeptiert, liste_fehlender_dokumente) zur√ºck.
    """
    # Notar-Dokumente laden
    notar_docs = st.session_state.notar_rechtsdokumente.get(notar_id, {})

    if not notar_docs:
        # Keine Dokumente konfiguriert -> keine Akzeptanz erforderlich
        return True, []

    # User-Akzeptanzen laden
    user_akzeptanzen = st.session_state.rechtsdokument_akzeptanzen.get(user_id, {}).get(notar_id, {})

    fehlende = []
    for doc_type, doc_data in notar_docs.items():
        if doc_data.get('pflicht', False):
            if not user_akzeptanzen.get(doc_type):
                fehlende.append(doc_type)

    return len(fehlende) == 0, fehlende


def check_alle_rechtsdokumente_akzeptiert(user_id: str, rolle: str) -> Tuple[bool, Dict[str, List[str]]]:
    """
    Pr√ºft f√ºr alle Projekte des Users ob Rechtsdokumente akzeptiert wurden.
    Gibt (alle_akzeptiert, {notar_id: [fehlende_docs]}) zur√ºck.
    """
    notar_ids = get_user_notar_ids(user_id, rolle)

    if not notar_ids:
        return True, {}

    alle_fehlend = {}
    for notar_id in notar_ids:
        akzeptiert, fehlende = check_rechtsdokumente_akzeptiert(user_id, notar_id)
        if not akzeptiert:
            alle_fehlend[notar_id] = fehlende

    return len(alle_fehlend) == 0, alle_fehlend


def render_rechtsdokumente_akzeptanz_pflicht(user_id: str, rolle: str) -> bool:
    """
    Zeigt Pflicht-Rechtsdokumente an, die akzeptiert werden m√ºssen.
    Gibt True zur√ºck wenn alle akzeptiert wurden, False wenn noch ausstehend.
    """
    alle_akzeptiert, fehlende_pro_notar = check_alle_rechtsdokumente_akzeptiert(user_id, rolle)

    if alle_akzeptiert:
        return True

    st.warning("‚ö†Ô∏è **Bitte akzeptieren Sie die folgenden Rechtsdokumente, bevor Sie fortfahren k√∂nnen.**")
    st.markdown("---")

    for notar_id, fehlende_docs in fehlende_pro_notar.items():
        # Notar-Infos holen
        notar = st.session_state.users.get(notar_id)
        notar_name = notar.name if notar else notar_id

        notar_docs = st.session_state.notar_rechtsdokumente.get(notar_id, {})

        st.subheader(f"üìú Rechtsdokumente von {notar_name}")

        for doc_type in fehlende_docs:
            doc_data = notar_docs.get(doc_type, {})
            titel = doc_data.get('titel', doc_type.capitalize())
            inhalt = doc_data.get('inhalt', '')
            version = doc_data.get('version', '1.0')

            with st.expander(f"üìÑ {titel} (Version {version})", expanded=True):
                # Scrollbarer Container f√ºr den Inhalt
                st.markdown(f"""
                <div style="
                    max-height: 300px;
                    overflow-y: auto;
                    padding: 15px;
                    background-color: #f8f9fa;
                    border-radius: 8px;
                    border: 1px solid #dee2e6;
                    margin-bottom: 15px;
                ">
                    {inhalt.replace(chr(10), '<br>')}
                </div>
                """, unsafe_allow_html=True)

                # Akzeptanz-Checkbox und Button
                checkbox_key = f"akzeptanz_check_{user_id}_{notar_id}_{doc_type}"
                akzeptiert_cb = st.checkbox(
                    f"Ich habe die {titel} gelesen und akzeptiere diese",
                    key=checkbox_key
                )

                button_key = f"akzeptanz_btn_{user_id}_{notar_id}_{doc_type}"
                if st.button(f"‚úÖ {titel} akzeptieren", key=button_key, disabled=not akzeptiert_cb):
                    # Akzeptanz speichern
                    if user_id not in st.session_state.rechtsdokument_akzeptanzen:
                        st.session_state.rechtsdokument_akzeptanzen[user_id] = {}
                    if notar_id not in st.session_state.rechtsdokument_akzeptanzen[user_id]:
                        st.session_state.rechtsdokument_akzeptanzen[user_id][notar_id] = {}

                    st.session_state.rechtsdokument_akzeptanzen[user_id][notar_id][doc_type] = {
                        'akzeptiert_am': datetime.now().isoformat(),
                        'version': version
                    }

                    # Benachrichtigungen senden
                    user = st.session_state.users.get(user_id)
                    notar = st.session_state.users.get(notar_id)
                    user_name = user.name if user else user_id
                    notar_name = notar.name if notar else "Notar"

                    # Nachricht an den User selbst
                    create_notification(
                        user_id=user_id,
                        titel=f"‚úÖ {titel} akzeptiert",
                        nachricht=f"Sie haben die {titel} (Version {version}) von {notar_name} erfolgreich akzeptiert.",
                        typ=NotificationType.SUCCESS.value
                    )

                    # Nachricht an den Notar
                    if notar_id:
                        create_notification(
                            user_id=notar_id,
                            titel=f"üìã Dokument akzeptiert",
                            nachricht=f"{user_name} hat die {titel} (Version {version}) akzeptiert.",
                            typ=NotificationType.INFO.value
                        )

                    st.success(f"‚úÖ {titel} wurde akzeptiert!")
                    st.rerun()

    return False


# ============================================================================
# AKTENZEICHEN & AUTOMATISCHE AKTEN-ERSTELLUNG
# ============================================================================

def generiere_aktenzeichen(notar_id: str) -> str:
    """
    Generiert ein fortlaufendes Aktenzeichen f√ºr einen Notar.
    Format: "Nummer/Jahr" z.B. "123/2025"
    """
    import uuid
    aktuelles_jahr = datetime.now().year
    zaehler_key = f"{notar_id}_{aktuelles_jahr}"

    # Z√§hler initialisieren falls nicht vorhanden
    if 'aktenzeichen_zaehler' not in st.session_state:
        st.session_state.aktenzeichen_zaehler = {}

    if zaehler_key not in st.session_state.aktenzeichen_zaehler:
        # Pr√ºfen ob es bereits Akten f√ºr dieses Jahr gibt
        bestehende_nummern = []
        for akte in st.session_state.importierte_akten.values():
            if akte.notar_id == notar_id and akte.aktenzeichen:
                # Nummer aus Aktenzeichen extrahieren (Format: "123/2025 Name / Name")
                try:
                    teil = akte.aktenzeichen.split('/')[0].strip()
                    nummer = int(teil)
                    jahr_teil = akte.aktenzeichen.split('/')[1].split()[0]
                    if int(jahr_teil) == aktuelles_jahr:
                        bestehende_nummern.append(nummer)
                except:
                    pass

        st.session_state.aktenzeichen_zaehler[zaehler_key] = max(bestehende_nummern) if bestehende_nummern else 0

    # N√§chste Nummer vergeben
    st.session_state.aktenzeichen_zaehler[zaehler_key] += 1
    neue_nummer = st.session_state.aktenzeichen_zaehler[zaehler_key]

    return f"{neue_nummer}/{aktuelles_jahr}"


def erstelle_aktenbezeichnung(projekt: 'Projekt') -> str:
    """
    Erstellt die Aktenbezeichnung im Format:
    "Nummer/Jahr Verk√§ufername(n) / K√§ufername(n)"
    """
    # Verk√§ufer-Namen sammeln
    verkaeufer_namen = []
    for vid in projekt.verkaeufer_ids:
        user = st.session_state.users.get(vid)
        if user:
            # Nur Nachname verwenden
            name_teile = user.name.split()
            nachname = name_teile[-1] if name_teile else user.name
            verkaeufer_namen.append(nachname)

    # Gesellschaften als Verk√§ufer pr√ºfen
    for partei_id in projekt.parteien:
        partei = st.session_state.parteien.get(partei_id)
        if partei and partei.rolle in ["Verk√§ufer", "√úberlasser", "Ver√§u√üerer"] and partei.ist_gesellschaft:
            gesellschaft = st.session_state.gesellschaften.get(partei.gesellschaft_id)
            if gesellschaft:
                # Kurzname oder Firmenname
                verkaeufer_namen.append(gesellschaft.firma_kurz or gesellschaft.firma.split()[0])

    # K√§ufer-Namen sammeln
    kaeufer_namen = []
    for kid in projekt.kaeufer_ids:
        user = st.session_state.users.get(kid)
        if user:
            name_teile = user.name.split()
            nachname = name_teile[-1] if name_teile else user.name
            kaeufer_namen.append(nachname)

    # Gesellschaften als K√§ufer pr√ºfen
    for partei_id in projekt.parteien:
        partei = st.session_state.parteien.get(partei_id)
        if partei and partei.rolle in ["K√§ufer", "Empf√§nger", "Erwerber"] and partei.ist_gesellschaft:
            gesellschaft = st.session_state.gesellschaften.get(partei.gesellschaft_id)
            if gesellschaft:
                kaeufer_namen.append(gesellschaft.firma_kurz or gesellschaft.firma.split()[0])

    # Bezeichnung zusammenstellen
    verkaeufer_str = ", ".join(verkaeufer_namen) if verkaeufer_namen else "N.N."
    kaeufer_str = ", ".join(kaeufer_namen) if kaeufer_namen else "N.N."

    return f"{verkaeufer_str} / {kaeufer_str}"


def erstelle_akte_fuer_projekt(projekt: 'Projekt', notar_id: str) -> 'ImportierteAkte':
    """
    Erstellt automatisch eine Akte f√ºr ein Projekt wenn ein Notar zugewiesen wird.
    """
    import uuid

    akte_id = str(uuid.uuid4())[:8]

    # Aktenzeichen generieren
    az_nummer = generiere_aktenzeichen(notar_id)
    bezeichnung = erstelle_aktenbezeichnung(projekt)
    volles_aktenzeichen = f"{az_nummer} {bezeichnung}"

    # Standard-Ordner erstellen
    ordner = {}
    for i, std_ordner in enumerate(STANDARD_AKTEN_ORDNER):
        ordner_id = str(uuid.uuid4())[:8]
        ordner[ordner_id] = AktenOrdner(
            ordner_id=ordner_id,
            akte_id=akte_id,
            name=std_ordner["name"],
            beschreibung=std_ordner["beschreibung"],
            reihenfolge=i,
            ist_standard_ordner=True
        )

    # Akte erstellen
    akte = ImportierteAkte(
        akte_id=akte_id,
        notar_id=notar_id,
        aktenzeichen=volles_aktenzeichen,
        bezeichnung=f"{projekt.vertragstyp}: {bezeichnung}",
        projekt_id=projekt.projekt_id,
        ordner=ordner,
        status=AktenStatus.IN_BEARBEITUNG.value if hasattr(AktenStatus, 'IN_BEARBEITUNG') else "In Bearbeitung"
    )

    # Beteiligte aus Projekt √ºbernehmen
    for vid in projekt.verkaeufer_ids:
        user = st.session_state.users.get(vid)
        if user:
            akte.verkaeufer_namen.append(user.name)

    for kid in projekt.kaeufer_ids:
        user = st.session_state.users.get(kid)
        if user:
            akte.kaeufer_namen.append(user.name)

    akte.objekt_adresse = projekt.adresse
    akte.kaufpreis = projekt.kaufpreis

    # In Session State speichern
    st.session_state.importierte_akten[akte_id] = akte

    # Projekt mit Akte verkn√ºpfen
    projekt.akte_id = akte_id
    projekt.aktenzeichen = volles_aktenzeichen

    return akte


def verknuepfe_projekt_mit_notar(projekt_id: str, notar_id: str) -> Optional['ImportierteAkte']:
    """
    Wird aufgerufen wenn ein Notar einem Projekt zugewiesen wird.
    Erstellt automatisch eine Akte und verkn√ºpft sie mit dem Projekt.
    """
    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt:
        return None

    # Pr√ºfen ob bereits eine Akte existiert
    if projekt.akte_id and projekt.akte_id in st.session_state.importierte_akten:
        return st.session_state.importierte_akten[projekt.akte_id]

    # Neue Akte erstellen
    akte = erstelle_akte_fuer_projekt(projekt, notar_id)

    return akte


def aktualisiere_aktenbezeichnung(projekt_id: str):
    """
    Aktualisiert die Aktenbezeichnung wenn sich Parteien √§ndern.
    """
    projekt = st.session_state.projekte.get(projekt_id)
    if not projekt or not projekt.akte_id:
        return

    akte = st.session_state.importierte_akten.get(projekt.akte_id)
    if not akte:
        return

    # Nur den Namen-Teil aktualisieren, Nummer beibehalten
    az_teile = akte.aktenzeichen.split(' ', 1)
    if len(az_teile) >= 1:
        az_nummer = az_teile[0]  # z.B. "123/2025"
        neue_bezeichnung = erstelle_aktenbezeichnung(projekt)
        volles_aktenzeichen = f"{az_nummer} {neue_bezeichnung}"

        akte.aktenzeichen = volles_aktenzeichen
        akte.bezeichnung = f"{projekt.vertragstyp}: {neue_bezeichnung}"
        projekt.aktenzeichen = volles_aktenzeichen


# ============================================================================
# PARTEIEN-VERWALTUNG (K√ÑUFER/VERK√ÑUFER/GESELLSCHAFTEN)
# ============================================================================

def render_parteien_verwaltung(projekt: 'Projekt', user_rolle: str):
    """UI f√ºr die Verwaltung der Vertragsparteien eines Projekts."""
    st.markdown("### üë• Vertragsparteien")

    # Tabs f√ºr Verk√§ufer und K√§ufer
    partei_tabs = st.tabs(["üè† Verk√§ufer/√úberlasser", "üõí K√§ufer/Empf√§nger"])

    with partei_tabs[0]:
        render_partei_sektion(projekt, "Verk√§ufer", user_rolle)

    with partei_tabs[1]:
        render_partei_sektion(projekt, "K√§ufer", user_rolle)


def render_partei_sektion(projekt: 'Projekt', rolle: str, user_rolle: str):
    """Rendert eine Sektion f√ºr Verk√§ufer oder K√§ufer."""

    # Bestehende Parteien dieser Rolle anzeigen
    parteien_der_rolle = []

    # Nat√ºrliche Personen aus kaeufer_ids/verkaeufer_ids
    if rolle in ["K√§ufer", "Empf√§nger", "Erwerber"]:
        for user_id in projekt.kaeufer_ids:
            user = st.session_state.users.get(user_id)
            if user:
                parteien_der_rolle.append({
                    "typ": "person",
                    "id": user_id,
                    "name": user.name,
                    "details": user.email
                })
    else:  # Verk√§ufer
        for user_id in projekt.verkaeufer_ids:
            user = st.session_state.users.get(user_id)
            if user:
                parteien_der_rolle.append({
                    "typ": "person",
                    "id": user_id,
                    "name": user.name,
                    "details": user.email
                })

    # Gesellschaften aus parteien
    for partei_id in projekt.parteien:
        partei = st.session_state.parteien.get(partei_id)
        if partei and partei.ist_gesellschaft:
            if (rolle in ["K√§ufer", "Empf√§nger", "Erwerber"] and partei.rolle in ["K√§ufer", "Empf√§nger", "Erwerber"]) or \
               (rolle in ["Verk√§ufer", "√úberlasser", "Ver√§u√üerer"] and partei.rolle in ["Verk√§ufer", "√úberlasser", "Ver√§u√üerer"]):
                gesellschaft = st.session_state.gesellschaften.get(partei.gesellschaft_id)
                if gesellschaft:
                    parteien_der_rolle.append({
                        "typ": "gesellschaft",
                        "id": gesellschaft.gesellschaft_id,
                        "partei_id": partei_id,
                        "name": gesellschaft.firma,
                        "details": f"{gesellschaft.rechtsform} - {gesellschaft.registernummer}"
                    })

    # Parteien anzeigen
    if parteien_der_rolle:
        for i, partei in enumerate(parteien_der_rolle):
            icon = "üë§" if partei["typ"] == "person" else "üè¢"
            with st.expander(f"{icon} {partei['name']}", expanded=False):
                st.write(f"**{partei['details']}**")

                if partei["typ"] == "gesellschaft":
                    gesellschaft = st.session_state.gesellschaften.get(partei["id"])
                    if gesellschaft:
                        render_gesellschaft_details(gesellschaft)

                # Entfernen-Button (nur f√ºr berechtigte Rollen)
                if user_rolle in [UserRole.NOTAR.value, UserRole.MAKLER.value]:
                    if st.button(f"üóëÔ∏è Entfernen", key=f"remove_{rolle}_{partei['id']}_{i}"):
                        if partei["typ"] == "person":
                            if rolle in ["K√§ufer", "Empf√§nger"]:
                                projekt.kaeufer_ids.remove(partei["id"])
                            else:
                                projekt.verkaeufer_ids.remove(partei["id"])
                        else:
                            projekt.parteien.remove(partei["partei_id"])
                        aktualisiere_aktenbezeichnung(projekt.projekt_id)
                        st.success(f"{partei['name']} entfernt")
                        st.rerun()
    else:
        st.info(f"Noch keine {rolle} hinzugef√ºgt.")

    # Neue Partei hinzuf√ºgen (nur f√ºr berechtigte Rollen)
    if user_rolle in [UserRole.NOTAR.value, UserRole.MAKLER.value]:
        st.markdown("---")
        render_neue_partei_formular(projekt, rolle)


def render_neue_partei_formular(projekt: 'Projekt', rolle: str):
    """Formular zum Hinzuf√ºgen einer neuen Partei."""
    import uuid

    with st.expander(f"‚ûï {rolle} hinzuf√ºgen", expanded=False):
        partei_typ = st.radio(
            "Art der Partei",
            ["Nat√ºrliche Person", "Gesellschaft/Firma"],
            key=f"partei_typ_{projekt.projekt_id}_{rolle}",
            horizontal=True
        )

        if partei_typ == "Nat√ºrliche Person":
            # Bestehenden User ausw√§hlen oder neuen anlegen
            st.markdown("##### Bestehenden Teilnehmer ausw√§hlen")

            # Alle verf√ºgbaren User (die noch nicht in diesem Projekt sind)
            verfuegbare_user = []
            for user in st.session_state.users.values():
                if rolle in ["K√§ufer", "Empf√§nger"]:
                    if user.user_id not in projekt.kaeufer_ids:
                        verfuegbare_user.append(user)
                else:
                    if user.user_id not in projekt.verkaeufer_ids:
                        verfuegbare_user.append(user)

            if verfuegbare_user:
                user_optionen = {u.user_id: f"{u.name} ({u.email})" for u in verfuegbare_user}
                selected_user = st.selectbox(
                    "Teilnehmer ausw√§hlen",
                    options=[""] + list(user_optionen.keys()),
                    format_func=lambda x: user_optionen.get(x, "-- Ausw√§hlen --"),
                    key=f"select_user_{projekt.projekt_id}_{rolle}"
                )

                if selected_user and st.button(f"‚úÖ Als {rolle} hinzuf√ºgen", key=f"add_user_{projekt.projekt_id}_{rolle}"):
                    if rolle in ["K√§ufer", "Empf√§nger"]:
                        projekt.kaeufer_ids.append(selected_user)
                    else:
                        projekt.verkaeufer_ids.append(selected_user)
                    aktualisiere_aktenbezeichnung(projekt.projekt_id)
                    st.success(f"Teilnehmer als {rolle} hinzugef√ºgt!")
                    st.rerun()

        else:  # Gesellschaft
            render_gesellschaft_formular(projekt, rolle)


def render_gesellschaft_formular(projekt: 'Projekt', rolle: str):
    """Formular zum Anlegen einer neuen Gesellschaft."""
    import uuid

    st.markdown("##### Neue Gesellschaft anlegen")

    with st.form(f"neue_gesellschaft_{projekt.projekt_id}_{rolle}"):
        col1, col2 = st.columns(2)

        with col1:
            firma = st.text_input("Firma (vollst√§ndig) *", placeholder="Muster GmbH")
            firma_kurz = st.text_input("Kurzbezeichnung", placeholder="Muster")
            rechtsform = st.selectbox(
                "Rechtsform *",
                [r.value for r in Rechtsform if r != Rechtsform.NATUERLICHE_PERSON]
            )

        with col2:
            registergericht = st.text_input("Registergericht", placeholder="Amtsgericht M√ºnchen")
            registernummer = st.text_input("Registernummer", placeholder="HRB 12345")
            sitz = st.text_input("Sitz", placeholder="M√ºnchen")

        st.markdown("##### Gesch√§ftsanschrift")
        col3, col4, col5 = st.columns([3, 1, 2])
        with col3:
            strasse = st.text_input("Stra√üe", key=f"g_strasse_{projekt.projekt_id}_{rolle}")
        with col4:
            hausnummer = st.text_input("Nr.", key=f"g_hnr_{projekt.projekt_id}_{rolle}")
        with col5:
            plz = st.text_input("PLZ", key=f"g_plz_{projekt.projekt_id}_{rolle}")

        ort = st.text_input("Ort", key=f"g_ort_{projekt.projekt_id}_{rolle}")

        st.markdown("##### Vertretung")
        vertretungsregelung = st.text_input(
            "Vertretungsregelung",
            placeholder="z.B. Jeder Gesch√§ftsf√ºhrer allein / Zwei Gesch√§ftsf√ºhrer gemeinsam"
        )

        submitted = st.form_submit_button("üíº Gesellschaft anlegen", type="primary")

        if submitted:
            if not firma:
                st.error("Bitte Firmenname eingeben!")
            else:
                # Gesellschaft erstellen
                gesellschaft_id = str(uuid.uuid4())[:8]
                gesellschaft = Gesellschaft(
                    gesellschaft_id=gesellschaft_id,
                    projekt_id=projekt.projekt_id,
                    firma=firma,
                    firma_kurz=firma_kurz,
                    rechtsform=rechtsform,
                    registergericht=registergericht,
                    registernummer=registernummer,
                    sitz=sitz,
                    strasse=strasse,
                    hausnummer=hausnummer,
                    plz=plz,
                    ort=ort,
                    vertretungsregelung=vertretungsregelung,
                    erfasst_von=st.session_state.current_user.user_id
                )
                st.session_state.gesellschaften[gesellschaft_id] = gesellschaft

                # Partei erstellen und mit Projekt verkn√ºpfen
                partei_id = str(uuid.uuid4())[:8]
                partei = Partei(
                    partei_id=partei_id,
                    projekt_id=projekt.projekt_id,
                    ist_gesellschaft=True,
                    gesellschaft_id=gesellschaft_id,
                    rolle=rolle
                )
                st.session_state.parteien[partei_id] = partei
                projekt.parteien.append(partei_id)
                projekt.gesellschaften.append(gesellschaft_id)

                aktualisiere_aktenbezeichnung(projekt.projekt_id)
                st.success(f"‚úÖ {firma} als {rolle} hinzugef√ºgt!")
                st.rerun()


def render_gesellschaft_details(gesellschaft: 'Gesellschaft'):
    """Zeigt die Details einer Gesellschaft an."""
    col1, col2 = st.columns(2)

    with col1:
        st.write(f"**Rechtsform:** {gesellschaft.rechtsform}")
        st.write(f"**Sitz:** {gesellschaft.sitz}")
        if gesellschaft.registergericht:
            st.write(f"**Registergericht:** {gesellschaft.registergericht}")
        if gesellschaft.registernummer:
            st.write(f"**Registernummer:** {gesellschaft.registernummer}")

    with col2:
        if gesellschaft.strasse:
            st.write(f"**Anschrift:** {gesellschaft.strasse} {gesellschaft.hausnummer}")
            st.write(f"{gesellschaft.plz} {gesellschaft.ort}")
        if gesellschaft.vertretungsregelung:
            st.write(f"**Vertretung:** {gesellschaft.vertretungsregelung}")

    # Organe anzeigen
    if gesellschaft.organe:
        st.markdown("##### Vertretungsberechtigte")
        for organ_id in gesellschaft.organe:
            organ = st.session_state.organe.get(organ_id)
            if organ:
                st.write(f"‚Ä¢ {organ.vorname} {organ.name} ({organ.organ_typ})")
    else:
        st.info("‚ö†Ô∏è Keine Vertretungsberechtigten erfasst")

    # Button f√ºr Handelsregisterabfrage
    if gesellschaft.registernummer and not gesellschaft.hr_abfrage_erfolgt:
        if st.button("üîç Handelsregister abfragen", key=f"hr_query_{gesellschaft.gesellschaft_id}"):
            st.session_state[f"show_hr_query_{gesellschaft.gesellschaft_id}"] = True
            st.rerun()

    if st.session_state.get(f"show_hr_query_{gesellschaft.gesellschaft_id}"):
        render_handelsregister_abfrage(gesellschaft)


def render_handelsregister_abfrage(gesellschaft: 'Gesellschaft'):
    """UI f√ºr die Handelsregister-Abfrage."""
    st.markdown("#### üîç Handelsregister-Abfrage")

    st.info("""
    **Handelsregister-Abfrage**

    F√ºr eine automatische Abfrage ben√∂tigen Sie einen API-Zugang zum
    Handelsregister (z.B. √ºber unternehmensregister.de).

    Alternativ k√∂nnen Sie die Daten manuell eingeben oder einen
    Handelsregisterauszug hochladen.
    """)

    tab1, tab2 = st.tabs(["üìù Manuell eingeben", "üìÑ Auszug hochladen"])

    with tab1:
        render_hr_manuelle_eingabe(gesellschaft)

    with tab2:
        render_hr_upload(gesellschaft)


def render_hr_manuelle_eingabe(gesellschaft: 'Gesellschaft'):
    """Manuelle Eingabe der Handelsregister-Daten."""
    import uuid

    with st.form(f"hr_manuell_{gesellschaft.gesellschaft_id}"):
        st.markdown("##### Registerdaten")
        col1, col2 = st.columns(2)

        with col1:
            registerart = st.selectbox("Registerart", ["HRB", "HRA", "GnR", "PR", "VR"])
            registernummer = st.text_input("Registernummer", value=gesellschaft.registernummer)

        with col2:
            registergericht = st.text_input("Registergericht", value=gesellschaft.registergericht)
            letzte_eintragung = st.text_input("Letzte Eintragung", placeholder="z.B. 01.01.2024")

        st.markdown("##### Firmendaten aus Register")
        firma_hr = st.text_input("Firma lt. HR", value=gesellschaft.firma)
        gegenstand = st.text_area("Unternehmensgegenstand", height=80)

        col3, col4 = st.columns(2)
        with col3:
            stammkapital = st.number_input("Stammkapital (‚Ç¨)", value=gesellschaft.stammkapital if hasattr(gesellschaft, 'stammkapital') else 25000.0, step=1000.0)
        with col4:
            gruendungsdatum = st.text_input("Gr√ºndungsdatum", placeholder="TT.MM.JJJJ")

        st.markdown("##### Gesch√§ftsf√ºhrung / Vertretung")
        st.info("F√ºgen Sie die vertretungsberechtigten Personen hinzu")

        # Bestehende Organe anzeigen
        organe_neu = st.session_state.get(f"neue_organe_{gesellschaft.gesellschaft_id}", [])

        organ_name = st.text_input("Name des Vertreters", key=f"organ_name_{gesellschaft.gesellschaft_id}")
        organ_vorname = st.text_input("Vorname", key=f"organ_vorname_{gesellschaft.gesellschaft_id}")
        organ_typ = st.selectbox("Funktion", [o.value for o in OrganTyp], key=f"organ_typ_{gesellschaft.gesellschaft_id}")
        einzelvertretung = st.checkbox("Einzelvertretungsberechtigt", key=f"organ_einzel_{gesellschaft.gesellschaft_id}")

        if st.form_submit_button("üíæ Speichern"):
            # HR-Eintrag erstellen
            hr_id = str(uuid.uuid4())[:8]
            hr_eintrag = HandelsregisterEintrag(
                hr_id=hr_id,
                gesellschaft_id=gesellschaft.gesellschaft_id,
                registergericht=registergericht,
                registerart=registerart,
                registernummer=registernummer,
                firma=firma_hr,
                gegenstand=gegenstand,
                stammkapital=stammkapital,
                gruendungsdatum=gruendungsdatum,
                letzte_eintragung=letzte_eintragung,
                abfrage_datum=datetime.now()
            )
            st.session_state.hr_eintraege[hr_id] = hr_eintrag

            # Gesellschaft aktualisieren
            gesellschaft.hr_eintrag_id = hr_id
            gesellschaft.hr_abfrage_erfolgt = True
            gesellschaft.registergericht = registergericht
            gesellschaft.registernummer = f"{registerart} {registernummer}"

            # Organ hinzuf√ºgen falls eingegeben
            if organ_name:
                organ_id = str(uuid.uuid4())[:8]
                organ = Organ(
                    organ_id=organ_id,
                    gesellschaft_id=gesellschaft.gesellschaft_id,
                    name=organ_name,
                    vorname=organ_vorname,
                    organ_typ=organ_typ,
                    einzelvertretungsberechtigt=einzelvertretung
                )
                st.session_state.organe[organ_id] = organ
                gesellschaft.organe.append(organ_id)

            st.success("‚úÖ Handelsregister-Daten gespeichert!")
            if f"show_hr_query_{gesellschaft.gesellschaft_id}" in st.session_state:
                del st.session_state[f"show_hr_query_{gesellschaft.gesellschaft_id}"]
            st.rerun()


def render_hr_upload(gesellschaft: 'Gesellschaft'):
    """Upload eines Handelsregisterauszugs."""
    import uuid

    uploaded_file = st.file_uploader(
        "Handelsregisterauszug hochladen (PDF)",
        type=["pdf"],
        key=f"hr_upload_{gesellschaft.gesellschaft_id}"
    )

    if uploaded_file:
        pdf_bytes = uploaded_file.read()
        st.success(f"üìÑ {uploaded_file.name} hochgeladen ({len(pdf_bytes)/1024:.1f} KB)")

        if st.button("üíæ Auszug speichern", key=f"save_hr_{gesellschaft.gesellschaft_id}"):
            hr_id = str(uuid.uuid4())[:8]
            hr_eintrag = HandelsregisterEintrag(
                hr_id=hr_id,
                gesellschaft_id=gesellschaft.gesellschaft_id,
                registergericht=gesellschaft.registergericht,
                registernummer=gesellschaft.registernummer,
                abfrage_datum=datetime.now(),
                abfrage_pdf=pdf_bytes
            )
            st.session_state.hr_eintraege[hr_id] = hr_eintrag

            gesellschaft.hr_eintrag_id = hr_id
            gesellschaft.hr_abfrage_erfolgt = True

            st.success("‚úÖ Handelsregisterauszug gespeichert!")
            if f"show_hr_query_{gesellschaft.gesellschaft_id}" in st.session_state:
                del st.session_state[f"show_hr_query_{gesellschaft.gesellschaft_id}"]
            st.rerun()


def render_organ_verwaltung(gesellschaft: 'Gesellschaft'):
    """Verwaltung der Organe/Vertretungsberechtigten einer Gesellschaft."""
    import uuid

    st.markdown("#### üë• Vertretungsberechtigte")

    # Bestehende Organe anzeigen
    for organ_id in gesellschaft.organe:
        organ = st.session_state.organe.get(organ_id)
        if organ:
            with st.expander(f"üë§ {organ.vorname} {organ.name} - {organ.organ_typ}"):
                col1, col2 = st.columns(2)
                with col1:
                    st.write(f"**Funktion:** {organ.organ_typ}")
                    st.write(f"**Einzelvertretung:** {'Ja' if organ.einzelvertretungsberechtigt else 'Nein'}")
                    if organ.vertretungsbeschraenkung:
                        st.write(f"**Beschr√§nkung:** {organ.vertretungsbeschraenkung}")
                with col2:
                    if organ.geburtsdatum:
                        st.write(f"**Geburtsdatum:** {organ.geburtsdatum}")
                    if organ.ausweis_typ:
                        st.write(f"**Ausweis:** {organ.ausweis_typ} {organ.ausweis_nummer}")

                if st.button("üóëÔ∏è Entfernen", key=f"remove_organ_{organ_id}"):
                    gesellschaft.organe.remove(organ_id)
                    del st.session_state.organe[organ_id]
                    st.success("Organ entfernt")
                    st.rerun()

    # Neues Organ hinzuf√ºgen
    with st.expander("‚ûï Vertretungsberechtigten hinzuf√ºgen"):
        with st.form(f"neues_organ_{gesellschaft.gesellschaft_id}"):
            col1, col2 = st.columns(2)
            with col1:
                vorname = st.text_input("Vorname *")
                name = st.text_input("Name *")
                geburtsdatum = st.text_input("Geburtsdatum", placeholder="TT.MM.JJJJ")
            with col2:
                organ_typ = st.selectbox("Funktion *", [o.value for o in OrganTyp])
                einzelvertretung = st.checkbox("Einzelvertretungsberechtigt")
                beschraenkung = st.text_input("Vertretungsbeschr√§nkung")

            if st.form_submit_button("‚ûï Hinzuf√ºgen"):
                if not name or not vorname:
                    st.error("Bitte Name und Vorname eingeben!")
                else:
                    organ_id = str(uuid.uuid4())[:8]
                    organ = Organ(
                        organ_id=organ_id,
                        gesellschaft_id=gesellschaft.gesellschaft_id,
                        name=name,
                        vorname=vorname,
                        geburtsdatum=geburtsdatum,
                        organ_typ=organ_typ,
                        einzelvertretungsberechtigt=einzelvertretung,
                        vertretungsbeschraenkung=beschraenkung
                    )
                    st.session_state.organe[organ_id] = organ
                    gesellschaft.organe.append(organ_id)
                    st.success(f"‚úÖ {vorname} {name} hinzugef√ºgt!")
                    st.rerun()


# ============================================================================
# AKTENIMPORT - PDF-BASIERTE AKTENVERWALTUNG
# ============================================================================

def analysiere_pdf_struktur(pdf_bytes: bytes) -> Dict:
    """
    Analysiert die Struktur einer PDF-Datei.
    Sucht nach Lesezeichen/Bookmarks und Inhaltsverzeichnis.
    """
    import io

    struktur = {
        "seiten_anzahl": 0,
        "lesezeichen": [],
        "erkannte_ordner": [],
        "erkannte_dokumente": []
    }

    try:
        # PyPDF2 f√ºr PDF-Analyse verwenden
        try:
            from PyPDF2 import PdfReader
            reader = PdfReader(io.BytesIO(pdf_bytes))
            struktur["seiten_anzahl"] = len(reader.pages)

            # Lesezeichen extrahieren (falls vorhanden)
            def extrahiere_lesezeichen(outline, ebene=0):
                lesezeichen = []
                if outline:
                    for item in outline:
                        if isinstance(item, list):
                            lesezeichen.extend(extrahiere_lesezeichen(item, ebene + 1))
                        else:
                            try:
                                titel = item.title if hasattr(item, 'title') else str(item)
                                seite = reader.get_destination_page_number(item) if hasattr(item, 'title') else 0
                                lesezeichen.append({
                                    "titel": titel,
                                    "seite": seite,
                                    "ebene": ebene
                                })
                            except:
                                pass
                return lesezeichen

            if hasattr(reader, 'outline') and reader.outline:
                struktur["lesezeichen"] = extrahiere_lesezeichen(reader.outline)

            # Text der ersten Seiten analysieren f√ºr Inhaltsverzeichnis
            text_seiten = []
            for i, seite in enumerate(reader.pages[:5]):  # Erste 5 Seiten
                try:
                    text = seite.extract_text() or ""
                    text_seiten.append(text)
                except:
                    pass

            # Typische Aktenordner-Namen erkennen
            ordner_keywords = {
                "Kaufvertrag": ["kaufvertrag", "vertragsentwurf", "entwurf"],
                "Grundbuch": ["grundbuch", "grundbuchauszug", "abt.", "abteilung"],
                "Flurkarten & Pl√§ne": ["flurkarte", "lageplan", "teilungsplan", "kataster"],
                "Finanzierung": ["finanzierung", "grundschuld", "darlehen", "bank"],
                "Personalien K√§ufer": ["k√§ufer", "erwerber", "ausweis k√§ufer"],
                "Personalien Verk√§ufer": ["verk√§ufer", "ver√§u√üerer", "ausweis verk√§ufer"],
                "Beh√∂rdliche Unterlagen": ["vorkaufsrecht", "unbedenklichkeit", "genehmigung"],
                "Korrespondenz": ["schreiben", "email", "brief", "korrespondenz"],
                "Abrechnung": ["rechnung", "kostenaufstellung", "geb√ºhren"],
            }

            gesamt_text = " ".join(text_seiten).lower()

            for ordner, keywords in ordner_keywords.items():
                for keyword in keywords:
                    if keyword in gesamt_text:
                        if ordner not in struktur["erkannte_ordner"]:
                            struktur["erkannte_ordner"].append(ordner)
                        break

            # Dokument-Typen aus Lesezeichen erkennen
            for lz in struktur["lesezeichen"]:
                titel_lower = lz["titel"].lower()
                for dok_typ in AktenDokumentTyp:
                    if dok_typ.value.lower() in titel_lower:
                        struktur["erkannte_dokumente"].append({
                            "typ": dok_typ.value,
                            "titel": lz["titel"],
                            "seite": lz.get("seite", 0)
                        })
                        break

        except ImportError:
            struktur["fehler"] = "PyPDF2 nicht installiert"
        except Exception as e:
            struktur["fehler"] = str(e)

    except Exception as e:
        struktur["fehler"] = f"PDF-Analyse fehlgeschlagen: {str(e)}"

    return struktur


def erstelle_akte_aus_pdf(
    notar_id: str,
    pdf_bytes: bytes,
    dateiname: str,
    aktenzeichen: str,
    bezeichnung: str,
    struktur: Dict
) -> ImportierteAkte:
    """Erstellt eine neue Akte aus einer importierten PDF."""
    import uuid

    akte_id = str(uuid.uuid4())[:8]

    # Standard-Ordner erstellen
    ordner = {}
    for std_ordner in STANDARD_AKTEN_ORDNER:
        ordner_id = str(uuid.uuid4())[:8]
        ordner[ordner_id] = AktenOrdner(
            ordner_id=ordner_id,
            akte_id=akte_id,
            name=std_ordner["name"],
            beschreibung=std_ordner["beschreibung"]
        )

    # Dokumente aus erkannter Struktur erstellen
    dokumente = {}

    # Wenn Lesezeichen vorhanden, daraus Dokumente erstellen
    if struktur.get("lesezeichen"):
        ordner_map = {o.name: o.ordner_id for o in ordner.values()}

        for i, lz in enumerate(struktur["lesezeichen"]):
            if lz["ebene"] == 0:  # Hauptebene = Ordner
                continue

            dok_id = str(uuid.uuid4())[:8]

            # Ordner zuweisen basierend auf Keywords
            ziel_ordner = "Sonstiges"
            titel_lower = lz["titel"].lower()

            if any(k in titel_lower for k in ["kaufvertrag", "entwurf", "vertrag"]):
                ziel_ordner = "Vertragsentw√ºrfe"
            elif any(k in titel_lower for k in ["grundbuch", "abteilung"]):
                ziel_ordner = "Grundbuch"
            elif any(k in titel_lower for k in ["flurkarte", "plan", "lage"]):
                ziel_ordner = "Flurkarten & Pl√§ne"
            elif any(k in titel_lower for k in ["finanzierung", "grundschuld", "bank"]):
                ziel_ordner = "Finanzierung"
            elif any(k in titel_lower for k in ["k√§ufer", "erwerber"]):
                ziel_ordner = "Personalien K√§ufer"
            elif any(k in titel_lower for k in ["verk√§ufer", "ver√§u√üerer"]):
                ziel_ordner = "Personalien Verk√§ufer"
            elif any(k in titel_lower for k in ["beh√∂rde", "genehmigung", "vorkauf"]):
                ziel_ordner = "Beh√∂rdliche Unterlagen"
            elif any(k in titel_lower for k in ["rechnung", "kosten", "geb√ºhr"]):
                ziel_ordner = "Abrechnung"
            elif any(k in titel_lower for k in ["brief", "schreiben", "mail"]):
                ziel_ordner = "Korrespondenz"

            ordner_id = ordner_map.get(ziel_ordner, list(ordner_map.values())[-1])

            # Dokument-Typ ermitteln
            dok_typ = AktenDokumentTyp.SONSTIGES.value
            for typ in AktenDokumentTyp:
                if typ.value.lower() in titel_lower:
                    dok_typ = typ.value
                    break

            # Seitenbereiche sch√§tzen
            naechste_seite = struktur["seiten_anzahl"]
            for j, next_lz in enumerate(struktur["lesezeichen"][i+1:]):
                if next_lz.get("seite", 0) > lz.get("seite", 0):
                    naechste_seite = next_lz["seite"]
                    break

            dokumente[dok_id] = AktenDokument(
                dokument_id=dok_id,
                akte_id=akte_id,
                ordner_name=ziel_ordner,
                ordner_id=ordner_id,
                titel=lz["titel"],
                dokument_typ=dok_typ,
                seiten_von=lz.get("seite", 0) + 1,
                seiten_bis=naechste_seite
            )
    else:
        # Keine Lesezeichen - Ganzes PDF als ein Dokument
        dok_id = str(uuid.uuid4())[:8]
        ordner_id = list(ordner.keys())[0]

        dokumente[dok_id] = AktenDokument(
            dokument_id=dok_id,
            akte_id=akte_id,
            ordner_name="Vertragsentw√ºrfe",
            ordner_id=ordner_id,
            titel=dateiname.replace(".pdf", ""),
            dokument_typ=AktenDokumentTyp.SONSTIGES.value,
            seiten_von=1,
            seiten_bis=struktur.get("seiten_anzahl", 0)
        )

    # Akte erstellen
    akte = ImportierteAkte(
        akte_id=akte_id,
        notar_id=notar_id,
        aktenzeichen=aktenzeichen,
        bezeichnung=bezeichnung,
        original_pdf_data=pdf_bytes,
        original_pdf_name=dateiname,
        ordner=ordner,
        dokumente=dokumente,
        status=AktenStatus.IMPORTIERT.value
    )

    return akte


def render_akten_import():
    """Rendert die Import-Oberfl√§che f√ºr PDF-Akten."""
    st.subheader("üìÅ Aktenimport")

    st.info("""
    **PDF-Akten importieren**

    Laden Sie eine komplette Akte als PDF hoch. Das System analysiert die Struktur
    (Lesezeichen, Inhaltsverzeichnis) und erstellt automatisch die entsprechende
    Ordnerstruktur mit allen Dokumenten.
    """)

    notar_id = st.session_state.current_user.user_id

    # Upload-Bereich
    uploaded_file = st.file_uploader(
        "PDF-Akte hochladen",
        type=["pdf"],
        help="Ziehen Sie eine PDF-Datei hierher oder klicken Sie zum Ausw√§hlen"
    )

    if uploaded_file:
        pdf_bytes = uploaded_file.read()

        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### üìÑ Datei-Info")
            st.write(f"**Dateiname:** {uploaded_file.name}")
            st.write(f"**Gr√∂√üe:** {len(pdf_bytes) / 1024:.1f} KB")

        # PDF analysieren
        with st.spinner("Analysiere PDF-Struktur..."):
            struktur = analysiere_pdf_struktur(pdf_bytes)

        with col2:
            st.markdown("### üìä Analyse-Ergebnis")
            st.write(f"**Seiten:** {struktur.get('seiten_anzahl', 'Unbekannt')}")
            st.write(f"**Lesezeichen:** {len(struktur.get('lesezeichen', []))}")
            st.write(f"**Erkannte Ordner:** {len(struktur.get('erkannte_ordner', []))}")

        if struktur.get("fehler"):
            st.warning(f"‚ö†Ô∏è Hinweis: {struktur['fehler']}")

        # Erkannte Struktur anzeigen
        if struktur.get("lesezeichen"):
            with st.expander("üìë Erkannte Lesezeichen", expanded=True):
                for lz in struktur["lesezeichen"][:20]:  # Max 20 anzeigen
                    einrueckung = "  " * lz.get("ebene", 0)
                    st.write(f"{einrueckung}‚Ä¢ {lz['titel']} (Seite {lz.get('seite', 0) + 1})")
                if len(struktur["lesezeichen"]) > 20:
                    st.write(f"... und {len(struktur['lesezeichen']) - 20} weitere")

        if struktur.get("erkannte_ordner"):
            with st.expander("üìÇ Erkannte Ordner-Kategorien"):
                for ordner in struktur["erkannte_ordner"]:
                    st.write(f"‚Ä¢ {ordner}")

        st.markdown("---")

        # Formular f√ºr Akten-Details
        st.markdown("### ‚úèÔ∏è Akten-Details")

        with st.form("akten_import_form"):
            col1, col2 = st.columns(2)

            with col1:
                aktenzeichen = st.text_input(
                    "Aktenzeichen *",
                    placeholder="z.B. UR 123/2024",
                    help="Das offizielle Aktenzeichen des Notariats"
                )

            with col2:
                bezeichnung = st.text_input(
                    "Bezeichnung *",
                    placeholder="z.B. Kaufvertrag Musterstra√üe 1",
                    help="Kurze Beschreibung der Akte"
                )

            # Optional: Mit bestehendem Projekt verkn√ºpfen
            projekte = [p for p in st.session_state.projekte.values()
                       if p.notar_id == notar_id or not p.notar_id]

            projekt_optionen = ["-- Neues Projekt erstellen --"] + [
                f"{p.adresse} ({p.projekt_id[:8]})" for p in projekte
            ]

            projekt_auswahl = st.selectbox(
                "Mit Projekt verkn√ºpfen",
                projekt_optionen,
                help="Optional: Verkn√ºpfen Sie die Akte mit einem bestehenden Projekt"
            )

            submitted = st.form_submit_button("üì• Akte importieren", type="primary")

            if submitted:
                if not aktenzeichen or not bezeichnung:
                    st.error("Bitte Aktenzeichen und Bezeichnung eingeben!")
                else:
                    # Akte erstellen
                    akte = erstelle_akte_aus_pdf(
                        notar_id=notar_id,
                        pdf_bytes=pdf_bytes,
                        dateiname=uploaded_file.name,
                        aktenzeichen=aktenzeichen,
                        bezeichnung=bezeichnung,
                        struktur=struktur
                    )

                    # Mit Projekt verkn√ºpfen falls ausgew√§hlt
                    if projekt_auswahl != "-- Neues Projekt erstellen --":
                        projekt_index = projekt_optionen.index(projekt_auswahl) - 1
                        if 0 <= projekt_index < len(projekte):
                            akte.projekt_id = projekte[projekt_index].projekt_id

                    # Speichern
                    st.session_state.importierte_akten[akte.akte_id] = akte

                    st.success(f"‚úÖ Akte '{bezeichnung}' wurde erfolgreich importiert!")
                    st.info(f"üìä {len(akte.dokumente)} Dokumente in {len(akte.ordner)} Ordnern erstellt.")
                    st.rerun()


def render_akten_verwaltung():
    """Rendert die √úbersicht und Verwaltung importierter Akten."""
    st.subheader("üìÇ Aktenverwaltung")

    notar_id = st.session_state.current_user.user_id

    # Nur Akten des aktuellen Notars
    meine_akten = {
        akte_id: akte
        for akte_id, akte in st.session_state.importierte_akten.items()
        if akte.notar_id == notar_id
    }

    if not meine_akten:
        st.info("üì≠ Noch keine Akten importiert. Nutzen Sie den Tab 'Aktenimport' um Akten hochzuladen.")
        return

    # Akten-Liste
    st.markdown(f"### üìã Meine Akten ({len(meine_akten)})")

    # Suchfilter
    search = st.text_input("üîç Akte suchen", placeholder="Aktenzeichen oder Bezeichnung...")

    gefilterte_akten = meine_akten
    if search:
        search_lower = search.lower()
        gefilterte_akten = {
            k: v for k, v in meine_akten.items()
            if search_lower in v.aktenzeichen.lower() or search_lower in v.bezeichnung.lower()
        }

    # Akten als Karten anzeigen
    for akte_id, akte in gefilterte_akten.items():
        status_farbe = {
            AktenStatus.IMPORTIERT.value: "üîµ",
            AktenStatus.IN_BEARBEITUNG.value: "üü°",
            AktenStatus.VOLLSTAENDIG.value: "üü¢",
            AktenStatus.BEURKUNDET.value: "‚úÖ",
            AktenStatus.ABGESCHLOSSEN.value: "‚¨ú",
            AktenStatus.ARCHIVIERT.value: "üì¶"
        }.get(akte.status, "‚ö™")

        with st.expander(f"{status_farbe} **{akte.aktenzeichen}** - {akte.bezeichnung}", expanded=False):
            col1, col2, col3 = st.columns(3)

            with col1:
                st.write(f"**Status:** {akte.status}")
                st.write(f"**Importiert:** {akte.importiert_am.strftime('%d.%m.%Y') if akte.importiert_am else 'Unbekannt'}")

            with col2:
                st.write(f"**Dokumente:** {len(akte.dokumente)}")
                st.write(f"**Ordner:** {len(akte.ordner)}")

            with col3:
                if akte.projekt_id:
                    st.write(f"**Projekt:** {akte.projekt_id[:8]}")
                else:
                    st.write("**Projekt:** Nicht verkn√ºpft")

            # Ordner-Struktur anzeigen
            st.markdown("---")
            st.markdown("#### üìÅ Ordner-Struktur")

            ordner_tabs = st.tabs([o.name for o in akte.ordner.values()])

            for i, (ordner_id, ordner) in enumerate(akte.ordner.items()):
                with ordner_tabs[i]:
                    # Dokumente in diesem Ordner
                    ordner_dokumente = [
                        d for d in akte.dokumente.values()
                        if d.ordner_id == ordner_id or d.ordner_name == ordner.name
                    ]

                    if ordner_dokumente:
                        for dok in ordner_dokumente:
                            dok_icon = "üìÑ"
                            if "vertrag" in dok.titel.lower():
                                dok_icon = "üìú"
                            elif "ausweis" in dok.titel.lower():
                                dok_icon = "ü™™"
                            elif "grundbuch" in dok.titel.lower():
                                dok_icon = "üìö"

                            col_dok, col_seiten, col_actions = st.columns([3, 1, 1])
                            with col_dok:
                                st.write(f"{dok_icon} {dok.titel}")
                            with col_seiten:
                                if dok.seiten_von and dok.seiten_bis:
                                    st.write(f"S. {dok.seiten_von}-{dok.seiten_bis}")
                            with col_actions:
                                if st.button("üìã", key=f"copy_{dok.dokument_id}", help="Zur Aktentasche"):
                                    # Zur Aktentasche hinzuf√ºgen
                                    add_to_aktentasche(
                                        user_id=notar_id,
                                        inhalt_typ=AktentascheInhaltTyp.DOKUMENT.value,
                                        titel=dok.titel,
                                        beschreibung=f"Aus Akte {akte.aktenzeichen}",
                                        referenz_id=dok.dokument_id,
                                        referenz_typ="AktenDokument"
                                    )
                                    st.success(f"‚úÖ '{dok.titel}' zur Aktentasche hinzugef√ºgt!")
                    else:
                        st.write("*Keine Dokumente in diesem Ordner*")

            # Aktionen
            st.markdown("---")
            col_a1, col_a2, col_a3, col_a4 = st.columns(4)

            with col_a1:
                # Status √§ndern
                neuer_status = st.selectbox(
                    "Status √§ndern",
                    [s.value for s in AktenStatus],
                    index=[s.value for s in AktenStatus].index(akte.status),
                    key=f"status_{akte_id}"
                )
                if neuer_status != akte.status:
                    if st.button("üíæ Speichern", key=f"save_status_{akte_id}"):
                        akte.status = neuer_status
                        st.success("Status aktualisiert!")
                        st.rerun()

            with col_a2:
                # Original-PDF herunterladen
                if akte.original_pdf_data:
                    st.download_button(
                        "üì• Original-PDF",
                        data=akte.original_pdf_data,
                        file_name=akte.original_pdf_name or f"{akte.aktenzeichen}.pdf",
                        mime="application/pdf",
                        key=f"download_{akte_id}"
                    )

            with col_a3:
                # Mit Projekt verkn√ºpfen
                if not akte.projekt_id:
                    if st.button("üîó Projekt verkn√ºpfen", key=f"link_{akte_id}"):
                        st.session_state[f"link_projekt_{akte_id}"] = True
                        st.rerun()

            with col_a4:
                # L√∂schen
                if st.button("üóëÔ∏è L√∂schen", key=f"delete_{akte_id}"):
                    st.session_state[f"confirm_delete_{akte_id}"] = True
                    st.rerun()

            # L√∂sch-Best√§tigung
            if st.session_state.get(f"confirm_delete_{akte_id}"):
                st.warning("‚ö†Ô∏è M√∂chten Sie diese Akte wirklich l√∂schen?")
                col_yes, col_no = st.columns(2)
                with col_yes:
                    if st.button("‚úÖ Ja, l√∂schen", key=f"confirm_yes_{akte_id}"):
                        del st.session_state.importierte_akten[akte_id]
                        del st.session_state[f"confirm_delete_{akte_id}"]
                        st.success("Akte gel√∂scht!")
                        st.rerun()
                with col_no:
                    if st.button("‚ùå Abbrechen", key=f"confirm_no_{akte_id}"):
                        del st.session_state[f"confirm_delete_{akte_id}"]
                        st.rerun()


def notar_aktenimport_view():
    """Haupt-View f√ºr Aktenimport und -verwaltung im Notar-Dashboard."""

    # Sub-Tabs f√ºr Import und Verwaltung
    sub_tabs = st.tabs(["üì• Neue Akte importieren", "üìÇ Akten verwalten"])

    with sub_tabs[0]:
        render_akten_import()

    with sub_tabs[1]:
        render_akten_verwaltung()


def notar_einstellungen_view():
    """Einstellungen f√ºr Notar - API-Keys, Briefkopf, Signaturen, Datenbank"""
    st.subheader("‚öôÔ∏è Einstellungen")

    user_id = st.session_state.current_user.user_id

    # Haupttabs f√ºr alle Einstellungen
    einstellungen_tabs = st.tabs([
        "üîë API-Keys",
        "üìù Briefkopf",
        "‚úâÔ∏è E-Mail-Signaturen",
        "üß™ Demo-Modus",
        "üóÑÔ∏è Datenbank"
    ])

    # ===== TAB 0: API-Keys =====
    with einstellungen_tabs[0]:
        st.info("""
        Hier k√∂nnen Sie API-Schl√ºssel f√ºr die KI-gest√ºtzte Dokumentenerkennung (OCR) konfigurieren.
        Diese werden verwendet, um Personalausweise und Reisep√§sse automatisch zu erkennen.
        """)

        st.warning("""
        ‚ö†Ô∏è **Wichtig f√ºr dauerhafte Speicherung:**

        API-Schl√ºssel, die hier eingegeben werden, gehen bei einem Seiten-Reload verloren.
        F√ºr permanente Speicherung konfigurieren Sie die Schl√ºssel in **Streamlit Cloud**:

        1. Gehen Sie zu Ihrer App auf [share.streamlit.io](https://share.streamlit.io)
        2. Klicken Sie auf ‚öôÔ∏è **Settings** ‚Üí **Secrets**
        3. F√ºgen Sie folgendes hinzu:
        ```
        OPENAI_API_KEY = "sk-..."
        ANTHROPIC_API_KEY = "sk-ant-..."
        ```
        4. Klicken Sie auf **Save**

        Die Schl√ºssel werden dann automatisch bei jedem Start geladen.
        """)

        # Sicherstellen, dass api_keys existiert
        if 'api_keys' not in st.session_state:
            st.session_state.api_keys = {
                'openai': '',
                'anthropic': ''
            }

        st.markdown("### üîë API-Schl√ºssel f√ºr OCR")

        with st.form("api_keys_form"):
            st.markdown("#### OpenAI API")
            st.caption("F√ºr GPT-4 Vision OCR-Erkennung. Erh√§ltlich unter: https://platform.openai.com/api-keys")

            openai_key = st.text_input(
                "OpenAI API-Key",
                value=st.session_state.api_keys.get('openai', ''),
                type="password",
                placeholder="sk-...",
                help="Ihr OpenAI API-Schl√ºssel (beginnt mit 'sk-')"
            )

            st.markdown("#### Anthropic API (Claude)")
            st.caption("F√ºr Claude Vision OCR-Erkennung. Erh√§ltlich unter: https://console.anthropic.com/")

            anthropic_key = st.text_input(
                "Anthropic API-Key",
                value=st.session_state.api_keys.get('anthropic', ''),
                type="password",
                placeholder="sk-ant-...",
                help="Ihr Anthropic API-Schl√ºssel (beginnt mit 'sk-ant-')"
            )

            submit = st.form_submit_button("üíæ API-Schl√ºssel speichern", type="primary")

            if submit:
                st.session_state.api_keys['openai'] = openai_key
                st.session_state.api_keys['anthropic'] = anthropic_key
                st.success("‚úÖ API-Schl√ºssel wurden gespeichert!")

        # Status-Anzeige
        st.markdown("---")
        st.markdown("### üìä Status der API-Konfiguration")

        col1, col2 = st.columns(2)

        with col1:
            st.markdown("**OpenAI:**")
            if st.session_state.api_keys.get('openai'):
                masked_key = st.session_state.api_keys['openai'][:10] + "..." + st.session_state.api_keys['openai'][-4:] if len(st.session_state.api_keys['openai']) > 14 else "****"
                st.success(f"‚úÖ Konfiguriert ({masked_key})")
            else:
                # Pr√ºfe auch Secrets und Umgebungsvariablen
                has_secret = False
                try:
                    if st.secrets.get("OPENAI_API_KEY"):
                        has_secret = True
                except:
                    pass

                import os
                if os.environ.get("OPENAI_API_KEY"):
                    has_secret = True

                if has_secret:
                    st.info("üì¶ √úber Secrets/Umgebungsvariable konfiguriert")
                else:
                    st.warning("‚ö†Ô∏è Nicht konfiguriert")

        with col2:
            st.markdown("**Anthropic (Claude):**")
            if st.session_state.api_keys.get('anthropic'):
                masked_key = st.session_state.api_keys['anthropic'][:10] + "..." + st.session_state.api_keys['anthropic'][-4:] if len(st.session_state.api_keys['anthropic']) > 14 else "****"
                st.success(f"‚úÖ Konfiguriert ({masked_key})")
            else:
                # Pr√ºfe auch Secrets und Umgebungsvariablen
                has_secret = False
                try:
                    if st.secrets.get("ANTHROPIC_API_KEY"):
                        has_secret = True
                except:
                    pass

                import os
                if os.environ.get("ANTHROPIC_API_KEY"):
                    has_secret = True

                if has_secret:
                    st.info("üì¶ √úber Secrets/Umgebungsvariable konfiguriert")
                else:
                    st.warning("‚ö†Ô∏è Nicht konfiguriert")

        # Hinweise
        st.markdown("---")
        st.markdown("### ‚ÑπÔ∏è Hinweise")
        st.markdown("""
        - **Priorit√§t:** Claude Vision ‚Üí OpenAI Vision ‚Üí pytesseract ‚Üí Demo-Daten
        - Die API-Schl√ºssel werden im Session State gespeichert und sind nur f√ºr diese Sitzung g√ºltig.
        - F√ºr permanente Konfiguration nutzen Sie Streamlit Secrets (`.streamlit/secrets.toml`).
        - Die OCR-Erkennung funktioniert am besten mit gut beleuchteten, geraden Aufnahmen.
        - Unterst√ºtzte Dokumente: Deutscher Personalausweis, Reisepass
        """)

    # ===== TAB 1: Briefkopf =====
    with einstellungen_tabs[1]:
        render_briefkopf_administration(user_id)

    # ===== TAB 2: E-Mail-Signaturen =====
    with einstellungen_tabs[2]:
        render_email_signaturen(user_id)

    # ===== TAB 3: Demo-Modus =====
    with einstellungen_tabs[3]:
        st.markdown("### üß™ Demo-Modus")

        # Demo-Modus initialisieren falls nicht vorhanden
        if 'demo_modus_aktiv' not in st.session_state:
            st.session_state.demo_modus_aktiv = True  # Standard: Demo-Modus AN

        st.info("""
        **Demo-Modus:** Alle Dashboards sind voll funktionsf√§hig mit simulierten Daten.
        Im aktiven Modus werden bestimmte Funktionen eingeschr√§nkt, bis alle erforderlichen
        Konfigurationen (API-Keys, echte Daten) vorgenommen wurden.
        """)

        demo_modus = st.toggle(
            "Demo-Modus aktiviert",
            value=st.session_state.demo_modus_aktiv,
            help="AN = Volle Funktionalit√§t mit Demo-Daten | AUS = Aktiver Modus mit Einschr√§nkungen"
        )

        if demo_modus != st.session_state.demo_modus_aktiv:
            st.session_state.demo_modus_aktiv = demo_modus
            if demo_modus:
                st.success("‚úÖ Demo-Modus aktiviert - Alle Funktionen verf√ºgbar")
            else:
                st.warning("‚ö†Ô∏è Aktiver Modus - Einige Funktionen erfordern echte Konfiguration")
            st.rerun()

        col1, col2 = st.columns(2)
        with col1:
            if st.session_state.demo_modus_aktiv:
                st.success("üü¢ **Demo-Modus AKTIV**")
                st.caption("Alle Dashboards funktionieren mit simulierten Daten")
            else:
                st.error("üî¥ **Aktiver Modus**")
                st.caption("Produktivbetrieb - echte Daten erforderlich")

        with col2:
            st.markdown("**Aktuelle Einstellung:**")
            if st.session_state.demo_modus_aktiv:
                st.markdown("- ‚úÖ Demo-Handwerker verf√ºgbar")
                st.markdown("- ‚úÖ Demo-Rechtsdokumente verf√ºgbar")
                st.markdown("- ‚úÖ OCR mit Demo-Daten als Fallback")
            else:
                st.markdown("- ‚ö†Ô∏è Echte Handwerker-Daten erforderlich")
                st.markdown("- ‚ö†Ô∏è Echte Rechtsdokumente erforderlich")
                st.markdown("- ‚ö†Ô∏è API-Keys f√ºr OCR erforderlich")

    # ===== TAB 4: Datenbank =====
    with einstellungen_tabs[4]:
        st.markdown("### üóÑÔ∏è Datenbank-Konfiguration")

        st.info("""
        Hier k√∂nnen Sie eine Datenbank einrichten, um alle Daten der Plattform persistent zu speichern.
        Die Daten bleiben dann auch nach einem Neustart der Anwendung erhalten.
        """)

        # Datenbank-Konfiguration initialisieren
        if 'db_config' not in st.session_state:
            st.session_state.db_config = {
                'db_type': 'sqlite',
                'host': 'localhost',
                'port': 5432,
                'database': 'immobilien_plattform',
                'username': '',
                'password': '',
                'sqlite_path': 'data/immobilien_plattform.db'
            }

        # Tabs f√ºr Konfiguration und Status
        db_tabs = st.tabs(["üîß Verbindung konfigurieren", "üìä Status & Migration", "üìã Datenbankschema"])

        with db_tabs[0]:
            st.markdown("#### Datenbank-Verbindung einrichten")

            # Datenbanktyp ausw√§hlen
            db_type = st.selectbox(
                "Datenbank-Typ",
                ["SQLite (Lokal)", "PostgreSQL", "MySQL/MariaDB"],
                index=0 if st.session_state.db_config['db_type'] == 'sqlite' else
                      (1 if st.session_state.db_config['db_type'] == 'postgresql' else 2),
                key="db_type_select",
                help="SQLite f√ºr lokale Entwicklung, PostgreSQL/MySQL f√ºr Produktion"
            )

            db_type_key = 'sqlite' if 'SQLite' in db_type else ('postgresql' if 'PostgreSQL' in db_type else 'mysql')
            st.session_state.db_config['db_type'] = db_type_key

            if db_type_key == 'sqlite':
                # SQLite Konfiguration
                st.markdown("##### üìÅ SQLite-Datei")

                sqlite_path = st.text_input(
                    "Datenbankpfad",
                    value=st.session_state.db_config.get('sqlite_path', 'data/immobilien_plattform.db'),
                    key="sqlite_path_input",
                    help="Relativer oder absoluter Pfad zur SQLite-Datenbankdatei"
                )
                st.session_state.db_config['sqlite_path'] = sqlite_path

                st.caption("üí° SQLite ist ideal f√ºr Entwicklung und kleinere Installationen. Die Datenbank wird automatisch erstellt.")

                # Verbindungs-URL generieren
                db_url = f"sqlite:///{sqlite_path}"

            else:
                # PostgreSQL / MySQL Konfiguration
                col1, col2 = st.columns(2)

                with col1:
                    host = st.text_input(
                        "Host",
                        value=st.session_state.db_config.get('host', 'localhost'),
                        key="db_host_input",
                        placeholder="localhost oder IP-Adresse"
                    )
                    st.session_state.db_config['host'] = host

                    database = st.text_input(
                        "Datenbankname",
                        value=st.session_state.db_config.get('database', 'immobilien_plattform'),
                        key="db_name_input"
                    )
                    st.session_state.db_config['database'] = database

                with col2:
                    port = st.number_input(
                        "Port",
                        value=st.session_state.db_config.get('port', 5432 if db_type_key == 'postgresql' else 3306),
                        min_value=1,
                        max_value=65535,
                        key="db_port_input"
                    )
                    st.session_state.db_config['port'] = port

                    username = st.text_input(
                        "Benutzername",
                        value=st.session_state.db_config.get('username', ''),
                        key="db_user_input"
                    )
                    st.session_state.db_config['username'] = username

                password = st.text_input(
                    "Passwort",
                    value=st.session_state.db_config.get('password', ''),
                    type="password",
                    key="db_pass_input"
                )
                st.session_state.db_config['password'] = password

                # Verbindungs-URL generieren
                if db_type_key == 'postgresql':
                    db_url = f"postgresql://{username}:{password}@{host}:{port}/{database}"
                else:
                    db_url = f"mysql+pymysql://{username}:{password}@{host}:{port}/{database}"

            # Verbindungs-URL anzeigen (maskiert)
            st.markdown("##### üîó Verbindungs-URL")
            if db_type_key == 'sqlite':
                st.code(db_url)
            else:
                masked_url = db_url.replace(password, '***') if password else db_url
                st.code(masked_url)

            # Aktionen
            col1, col2, col3 = st.columns(3)

            with col1:
                if st.button("üîå Verbindung testen", key="test_db_btn", type="primary"):
                    with st.spinner("Teste Verbindung..."):
                        try:
                            # Teste die Verbindung
                            test_result = test_database_connection(db_url)
                            if test_result['success']:
                                st.success(f"‚úÖ Verbindung erfolgreich! Server: {test_result.get('server_info', 'OK')}")
                                st.session_state.db_connection_url = db_url
                                st.session_state.database_connected = True
                            else:
                                st.error(f"‚ùå Verbindung fehlgeschlagen: {test_result.get('error', 'Unbekannter Fehler')}")
                                st.session_state.database_connected = False
                        except Exception as e:
                            st.error(f"‚ùå Fehler: {str(e)}")
                            st.session_state.database_connected = False

            with col2:
                if st.button("üíæ Konfiguration speichern", key="save_db_config"):
                    try:
                        save_database_config(st.session_state.db_config)
                        st.success("‚úÖ Konfiguration in .streamlit/secrets.toml gespeichert!")
                    except Exception as e:
                        st.error(f"‚ùå Fehler beim Speichern: {e}")

            with col3:
                if st.button("üèóÔ∏è Tabellen erstellen", key="init_db_btn"):
                    if st.session_state.get('database_connected'):
                        with st.spinner("Erstelle Datenbanktabellen..."):
                            try:
                                result = initialize_database_tables(st.session_state.get('db_connection_url', db_url))
                                if result['success']:
                                    st.success(f"‚úÖ {result['tables_created']} Tabellen erstellt!")
                                else:
                                    st.error(f"‚ùå Fehler: {result.get('error', 'Unbekannt')}")
                            except Exception as e:
                                st.error(f"‚ùå Fehler: {e}")
                    else:
                        st.warning("‚ö†Ô∏è Bitte zuerst Verbindung testen!")

        with db_tabs[1]:
            st.markdown("#### üìä Verbindungsstatus")

            db_connected = st.session_state.get('database_connected', False)

            col1, col2, col3 = st.columns(3)

            with col1:
                if db_connected:
                    st.success("üü¢ **Verbunden**")
                    st.caption(f"Typ: {st.session_state.db_config.get('db_type', 'N/A').upper()}")
                else:
                    st.error("üî¥ **Nicht verbunden**")

            with col2:
                # Session State Statistiken
                session_users = len(st.session_state.get('users', {}))
                session_projekte = len(st.session_state.get('projekte', {}))
                st.metric("Session State", f"{session_users} User, {session_projekte} Projekte")

            with col3:
                if db_connected:
                    st.metric("Datenbank", "Bereit")
                else:
                    st.metric("Datenbank", "Offline")

            st.markdown("---")
            st.markdown("#### üîÑ Datenmigration")

            st.info("""
            **Datenmigration:** √úbertragen Sie alle Daten aus dem Session State in die Datenbank.
            Dies erm√∂glicht persistente Speicherung auch nach einem Neustart.
            """)

            col1, col2 = st.columns(2)

            with col1:
                st.markdown("**Von Session State ‚Üí Datenbank:**")
                migrate_items = st.multiselect(
                    "Zu migrierende Daten",
                    ["Nutzer", "Projekte", "Dokumente", "Akten", "Preisverhandlungen", "Benachrichtigungen"],
                    default=["Nutzer", "Projekte"],
                    key="migrate_selection"
                )

                if st.button("üì§ Daten exportieren", key="export_to_db", disabled=not db_connected):
                    if db_connected and migrate_items:
                        with st.spinner("Exportiere Daten..."):
                            result = migrate_session_to_database(migrate_items)
                            if result['success']:
                                st.success(f"‚úÖ {result['migrated_count']} Datens√§tze exportiert!")
                            else:
                                st.error(f"‚ùå Fehler: {result.get('error', 'Unbekannt')}")
                    else:
                        st.warning("‚ö†Ô∏è Keine Verbindung oder keine Daten ausgew√§hlt")

            with col2:
                st.markdown("**Von Datenbank ‚Üí Session State:**")
                st.caption("Laden Sie gespeicherte Daten beim Start der Anwendung")

                if st.button("üì• Daten importieren", key="import_from_db", disabled=not db_connected):
                    if db_connected:
                        with st.spinner("Importiere Daten..."):
                            result = load_database_to_session()
                            if result['success']:
                                st.success(f"‚úÖ {result['loaded_count']} Datens√§tze geladen!")
                                st.rerun()
                            else:
                                st.error(f"‚ùå Fehler: {result.get('error', 'Unbekannt')}")

                auto_load = st.checkbox(
                    "Automatisch beim Start laden",
                    value=st.session_state.get('db_auto_load', False),
                    key="db_auto_load_checkbox",
                    help="L√§dt Daten automatisch aus der Datenbank beim Starten der App"
                )
                st.session_state.db_auto_load = auto_load

        with db_tabs[2]:
            st.markdown("#### üìã Datenbankschema")

            st.markdown("""
            Die Datenbank enth√§lt folgende Tabellen (SQLAlchemy Modelle):

            | Tabelle | Beschreibung |
            |---------|-------------|
            | `nutzer` | Benutzerkonten mit Rollen |
            | `makler_profil` | Makler-Profilinformationen |
            | `notar_profil` | Notar-Profilinformationen |
            | `notar_mitarbeiter` | Notar-Mitarbeiter |
            | `immobilie` | Immobilien-Stammdaten |
            | `projekt` | Transaktionsprojekte |
            | `projekt_beteiligung` | Zuordnung User ‚Üî Projekt |
            | `preisvorschlag` | Preisverhandlungen |
            | `preis_historie` | Preisentwicklung |
            | `markt_daten` | Marktdaten f√ºr ML |
            | `dokument` | Dokumente mit OCR |
            | `interaktion` | Benutzeraktivit√§ten |
            | `benachrichtigung` | Systembenachrichtigungen |
            | `textbaustein` | Vertragsbausteine |
            | `vertragsdokument` | Generierte Vertr√§ge |
            | `akte` | Aktenmanagement |
            | `akten_dokument` | Dokumente in Akten |
            | `akten_nachricht` | Kommunikation in Akten |
            | `api_key` | API-Schl√ºssel |
            """)

            if st.button("üìÑ Schema als SQL anzeigen", key="show_schema_sql"):
                st.code('''
-- Beispiel: Nutzer-Tabelle
CREATE TABLE nutzer (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255),
    rolle VARCHAR(50) NOT NULL,
    telefon VARCHAR(50),
    adresse TEXT,
    profilbild_url TEXT,
    onboarding_complete BOOLEAN DEFAULT FALSE,
    email_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    last_login TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

-- Beispiel: Projekt-Tabelle
CREATE TABLE projekt (
    id SERIAL PRIMARY KEY,
    projekt_id VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    beschreibung TEXT,
    adresse TEXT,
    kaufpreis DECIMAL(15,2),
    status VARCHAR(50),
    makler_id VARCHAR(50) REFERENCES nutzer(user_id),
    notar_id VARCHAR(50) REFERENCES nutzer(user_id),
    created_at TIMESTAMP DEFAULT NOW()
);
                ''', language='sql')


# ============================================================================
# NOTAR-MITARBEITER-BEREICH
# ============================================================================

def notarmitarbeiter_dashboard():
    """Dashboard f√ºr Notar-Mitarbeiter"""
    mitarbeiter = st.session_state.current_user

    st.title("‚öñÔ∏è Notar-Mitarbeiter-Dashboard")
    st.info(f"üë§ {mitarbeiter.name} | Rolle: {mitarbeiter.rolle}")

    # Benachrichtigungs-Badge in der Sidebar
    render_benachrichtigungs_badge(mitarbeiter.user_id)

    # Tab-Liste basierend auf Berechtigungen
    tab_labels = ["üìä Timeline", "üìã Projekte"]

    if mitarbeiter.kann_checklisten_bearbeiten:
        tab_labels.append("üìù Checklisten")

    if mitarbeiter.kann_dokumente_freigeben:
        tab_labels.append("üìÑ Dokumenten-Freigaben")

    if mitarbeiter.kann_termine_verwalten:
        tab_labels.append("üìÖ Termine")

    if mitarbeiter.kann_finanzierung_sehen:
        tab_labels.append("üí∞ Finanzierungsnachweise")

    tabs = st.tabs(tab_labels)

    tab_index = 0

    # Timeline (immer verf√ºgbar)
    with tabs[tab_index]:
        st.subheader("üìä Projekt-Fortschritt")
        if not mitarbeiter.projekt_ids:
            st.info("Ihnen wurden noch keine Projekte zugewiesen.")
        else:
            for projekt_id in mitarbeiter.projekt_ids:
                projekt = st.session_state.projekte.get(projekt_id)
                if projekt:
                    with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
                        render_timeline(projekt_id, "Notar-Mitarbeiter")
    tab_index += 1

    # Projekte (immer verf√ºgbar)
    with tabs[tab_index]:
        st.subheader("üìã Meine zugewiesenen Projekte")
        if not mitarbeiter.projekt_ids:
            st.info("Ihnen wurden noch keine Projekte zugewiesen.")
        else:
            for projekt_id in mitarbeiter.projekt_ids:
                projekt = st.session_state.projekte.get(projekt_id)
                if projekt:
                    with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
                        col1, col2 = st.columns(2)

                        with col1:
                            st.markdown(f"**Beschreibung:** {projekt.beschreibung}")
                            if projekt.adresse:
                                st.markdown(f"**Adresse:** {projekt.adresse}")
                            if projekt.kaufpreis > 0:
                                st.markdown(f"**Kaufpreis:** {format_euro(projekt.kaufpreis)} ‚Ç¨")

                        with col2:
                            st.markdown("**Parteien:**")
                            for kid in projekt.kaeufer_ids:
                                kaeufer = st.session_state.users.get(kid)
                                if kaeufer:
                                    st.write(f"üè† K√§ufer: {kaeufer.name}")

                            for vid in projekt.verkaeufer_ids:
                                verkaeufer = st.session_state.users.get(vid)
                                if verkaeufer:
                                    st.write(f"üè° Verk√§ufer: {verkaeufer.name}")
    tab_index += 1

    # Checklisten (nur wenn berechtigt)
    if mitarbeiter.kann_checklisten_bearbeiten:
        with tabs[tab_index]:
            st.subheader("üìù Checklisten bearbeiten")
            if not mitarbeiter.projekt_ids:
                st.info("Ihnen wurden noch keine Projekte zugewiesen.")
            else:
                # Projekt ausw√§hlen
                projekte = [st.session_state.projekte.get(pid) for pid in mitarbeiter.projekt_ids]
                projekte = [p for p in projekte if p is not None]

                if projekte:
                    projekt_options = {f"{p.name} (ID: {p.projekt_id})": p.projekt_id for p in projekte}
                    selected_projekt_label = st.selectbox("Projekt ausw√§hlen:", list(projekt_options.keys()), key="ma_checklist_projekt")
                    selected_projekt_id = projekt_options[selected_projekt_label]

                    # Checklisten f√ºr dieses Projekt anzeigen
                    projekt_checklists = [c for c in st.session_state.notar_checklists.values()
                                         if c.projekt_id == selected_projekt_id]

                    if projekt_checklists:
                        for checklist in projekt_checklists:
                            with st.expander(f"üìã {checklist.checklist_typ} - {checklist.partei}", expanded=False):
                                render_checklist_form(checklist)
                    else:
                        st.info("Noch keine Checklisten f√ºr dieses Projekt vorhanden.")
        tab_index += 1

    # Dokumenten-Freigaben (nur wenn berechtigt)
    if mitarbeiter.kann_dokumente_freigeben:
        with tabs[tab_index]:
            st.subheader("üìÑ Dokumenten-Freigaben")
            st.info("Diese Funktion w√ºrde Dokumenten-Freigaben anzeigen und verwalten.")
            # Hier k√∂nnte man die Verk√§ufer-Dokumente anzeigen und freigeben lassen
        tab_index += 1

    # Termine (nur wenn berechtigt)
    if mitarbeiter.kann_termine_verwalten:
        with tabs[tab_index]:
            st.subheader("üìÖ Termine verwalten")
            if not mitarbeiter.projekt_ids:
                st.info("Ihnen wurden noch keine Projekte zugewiesen.")
            else:
                for projekt_id in mitarbeiter.projekt_ids:
                    projekt = st.session_state.projekte.get(projekt_id)
                    if projekt:
                        with st.expander(f"üèòÔ∏è {projekt.name}", expanded=True):
                            if projekt.notartermin:
                                st.success(f"‚úÖ Termin vereinbart: {projekt.notartermin.strftime('%d.%m.%Y %H:%M')}")
                            else:
                                st.info("Noch kein Termin vereinbart")

                                with st.form(f"ma_termin_form_{projekt.projekt_id}"):
                                    termin_datum = st.date_input("Datum", value=date.today() + timedelta(days=14))
                                    termin_zeit = st.time_input("Uhrzeit", value=datetime.now().replace(hour=10, minute=0).time())

                                    if st.form_submit_button("üíæ Termin speichern", type="primary"):
                                        termin_dt = datetime.combine(termin_datum, termin_zeit)
                                        projekt.notartermin = termin_dt

                                        # Timeline aktualisieren
                                        for event_id in projekt.timeline_events:
                                            event = st.session_state.timeline_events.get(event_id)
                                            if event and event.titel == "Notartermin vereinbaren" and not event.completed:
                                                event.completed = True
                                                event.completed_at = datetime.now()
                                        update_projekt_status(projekt.projekt_id)

                                        st.success("‚úÖ Termin gespeichert!")
                                        st.rerun()
        tab_index += 1

    # Finanzierungsnachweise (nur wenn berechtigt)
    if mitarbeiter.kann_finanzierung_sehen:
        with tabs[tab_index]:
            st.subheader("üí∞ Finanzierungsnachweise")
            if not mitarbeiter.projekt_ids:
                st.info("Ihnen wurden noch keine Projekte zugewiesen.")
            else:
                for projekt_id in mitarbeiter.projekt_ids:
                    projekt = st.session_state.projekte.get(projekt_id)
                    if projekt:
                        st.markdown(f"### üèòÔ∏è {projekt.name}")

                        # Angenommene Finanzierungsangebote suchen
                        finanzierungen = [o for o in st.session_state.financing_offers.values()
                                         if o.projekt_id == projekt.projekt_id and o.status == FinanzierungsStatus.ANGENOMMEN.value]

                        if finanzierungen:
                            for offer in finanzierungen:
                                finanzierer = st.session_state.users.get(offer.finanzierer_id)
                                finanzierer_name = finanzierer.name if finanzierer else "Unbekannt"

                                with st.expander(f"üí∞ Angebot von {finanzierer_name}", expanded=True):
                                    col1, col2 = st.columns(2)

                                    with col1:
                                        st.write(f"**Darlehensbetrag:** {format_euro(offer.darlehensbetrag)} ‚Ç¨")
                                        st.write(f"**Zinssatz:** {offer.zinssatz}%")
                                        st.write(f"**Sollzinsbindung:** {offer.sollzinsbindung} Jahre")
                                        st.write(f"**Tilgungssatz:** {offer.tilgungssatz}%")

                                    with col2:
                                        st.write(f"**Gesamtlaufzeit:** {offer.gesamtlaufzeit} Jahre")
                                        st.write(f"**Monatliche Rate:** {format_euro(offer.monatliche_rate)} ‚Ç¨")
                                        st.write(f"**Angenommen am:** {offer.accepted_at.strftime('%d.%m.%Y') if offer.accepted_at else 'N/A'}")

                                    if offer.besondere_bedingungen:
                                        st.markdown("**Besondere Bedingungen:**")
                                        st.text(offer.besondere_bedingungen)
                        else:
                            st.info("Noch keine Finanzierung gesichert.")

                        st.markdown("---")
        tab_index += 1

# ============================================================================
# HAUPTANWENDUNG
# ============================================================================

def render_notifications():
    """Rendert Benachrichtigungen in der Sidebar"""
    if not st.session_state.current_user:
        return

    notifications = get_unread_notifications(st.session_state.current_user.user_id)

    if notifications:
        st.sidebar.markdown("---")
        st.sidebar.markdown(f"### üîî Benachrichtigungen ({len(notifications)})")

        for notif in notifications[:5]:  # Nur die 5 neuesten
            icon_map = {
                NotificationType.INFO.value: "‚ÑπÔ∏è",
                NotificationType.SUCCESS.value: "‚úÖ",
                NotificationType.WARNING.value: "‚ö†Ô∏è",
                NotificationType.ERROR.value: "‚ùå"
            }
            icon = icon_map.get(notif.typ, "‚ÑπÔ∏è")

            with st.sidebar.expander(f"{icon} {notif.titel}", expanded=False):
                st.write(notif.nachricht)
                st.caption(notif.created_at.strftime("%d.%m.%Y %H:%M"))
                if st.button("Als gelesen markieren", key=f"read_{notif.notif_id}"):
                    notif.gelesen = True
                    st.rerun()

def makler_onboarding_page(token: str):
    """Onboarding-Seite f√ºr eingeladene Makler"""
    st.title("üè¢ Makler-Registrierung")

    # Finde die Empfehlung mit diesem Token
    empfehlung = None
    for emp in st.session_state.makler_empfehlungen.values():
        if emp.onboarding_token == token:
            empfehlung = emp
            break

    if not empfehlung:
        st.error("‚ùå Ung√ºltiger oder abgelaufener Einladungslink.")
        st.info("Bitte wenden Sie sich an den Notar, der Sie eingeladen hat.")
        return

    if empfehlung.status == MaklerEmpfehlungStatus.FREIGEGEBEN.value:
        st.success("‚úÖ Ihre Registrierung wurde bereits abgeschlossen und freigegeben!")
        st.info("Sie k√∂nnen sich jetzt mit Ihren Zugangsdaten anmelden.")
        return

    st.success(f"Willkommen, {empfehlung.makler_name or 'Makler'}!")
    st.info("""
    Sie wurden vom Notar eingeladen, sich auf unserer Plattform zu registrieren.
    Bitte f√ºllen Sie das folgende Formular aus, um Ihre Firmendaten zu hinterlegen.
    Nach der Freigabe durch den Notar sind Sie f√ºr Verk√§ufer sichtbar.
    """)

    st.markdown("---")
    st.markdown("### üìù Ihre Firmendaten")

    with st.form("makler_onboarding_form"):
        # Basis-Informationen
        st.markdown("#### Kontaktdaten")
        col1, col2 = st.columns(2)

        with col1:
            firmenname = st.text_input("Firmenname*", value=empfehlung.firmenname)
            kontaktperson = st.text_input("Kontaktperson / Ansprechpartner*", value=empfehlung.makler_name)
            email = st.text_input("E-Mail*", value=empfehlung.makler_email, disabled=True)
            telefon = st.text_input("Telefon*", value=empfehlung.telefon)

        with col2:
            website = st.text_input("Website", value=empfehlung.website, placeholder="www.beispiel.de")
            adresse = st.text_area("Gesch√§ftsadresse*", value=empfehlung.adresse, height=100)

        # Logo-Upload
        logo_upload = st.file_uploader("Firmenlogo (optional)", type=['jpg', 'jpeg', 'png'])

        st.markdown("---")
        st.markdown("#### üìã Kurzvita & Spezialisierung")

        kurzvita = st.text_area(
            "Kurzvita (max. 500 Zeichen)*",
            value=empfehlung.kurzvita,
            max_chars=500,
            height=150,
            help="Diese Beschreibung wird Verk√§ufern angezeigt. Beschreiben Sie Ihre Erfahrung und St√§rken."
        )

        col1, col2 = st.columns(2)
        with col1:
            spezialisierung_optionen = [
                "Ferienimmobilien", "Luxusimmobilien", "Anlageimmobilien",
                "Neubauprojekte", "Bestandsimmobilien", "Gewerbeimmobilien",
                "Grundst√ºcke", "Mehrfamilienh√§user"
            ]
            spezialisierung = st.multiselect(
                "Spezialisierung*",
                spezialisierung_optionen,
                default=empfehlung.spezialisierung if empfehlung.spezialisierung else []
            )

        with col2:
            regionen_optionen = [
                "Mallorca", "Ibiza", "Menorca", "Costa Brava", "Costa Blanca",
                "Algarve", "Toskana", "C√¥te d'Azur", "√ñsterreich Alpen",
                "Schweiz", "Deutschland Nordsee", "Deutschland Ostsee"
            ]
            regionen = st.multiselect(
                "T√§tigkeitsregionen*",
                regionen_optionen,
                default=empfehlung.regionen if empfehlung.regionen else []
            )

        st.markdown("---")
        st.markdown("#### üí∞ Konditionen")

        col1, col2 = st.columns(2)
        with col1:
            provision_verkaeufer = st.number_input(
                "Provision Verk√§ufer (%)*",
                min_value=0.0, max_value=10.0,
                value=empfehlung.provision_verkaeufer_prozent if empfehlung.provision_verkaeufer_prozent > 0 else 3.57,
                step=0.01,
                help="Ihre Provision vom Verk√§ufer inkl. MwSt."
            )
        with col2:
            provision_kaeufer = st.number_input(
                "Provision K√§ufer (%)*",
                min_value=0.0, max_value=10.0,
                value=empfehlung.provision_kaeufer_prozent if empfehlung.provision_kaeufer_prozent > 0 else 3.57,
                step=0.01,
                help="Ihre Provision vom K√§ufer inkl. MwSt."
            )

        st.markdown("---")
        st.markdown("#### üìÑ Rechtliche Dokumente")
        st.info("Diese Dokumente werden Verk√§ufern zur Verf√ºgung gestellt.")

        agb_text = st.text_area(
            "Allgemeine Gesch√§ftsbedingungen (AGB)*",
            value=empfehlung.agb_text or """¬ß1 Geltungsbereich
Diese AGB gelten f√ºr alle Vertr√§ge zwischen dem Auftraggeber und dem Makler.

¬ß2 Vertragsgegenstand
Der Makler wird beauftragt, ein geeignetes Kaufobjekt nachzuweisen oder zu vermitteln.

¬ß3 Provision
Die Provision wird gem√§√ü den vereinbarten Konditionen f√§llig.

¬ß4 Haftung
Die Haftung des Maklers beschr√§nkt sich auf Vorsatz und grobe Fahrl√§ssigkeit.

¬ß5 Schlussbestimmungen
Es gilt deutsches Recht. Gerichtsstand ist der Sitz des Maklers.""",
            height=250
        )

        widerrufsbelehrung_text = st.text_area(
            "Widerrufsbelehrung*",
            value=empfehlung.widerrufsbelehrung_text or """Widerrufsrecht

Sie haben das Recht, binnen vierzehn Tagen ohne Angabe von Gr√ºnden diesen Vertrag zu widerrufen.

Die Widerrufsfrist betr√§gt vierzehn Tage ab dem Tag des Vertragsabschlusses.

Um Ihr Widerrufsrecht auszu√ºben, m√ºssen Sie uns mittels einer eindeutigen Erkl√§rung (z.B. ein mit der Post versandter Brief oder E-Mail) √ºber Ihren Entschluss, diesen Vertrag zu widerrufen, informieren.

Zur Wahrung der Widerrufsfrist reicht es aus, dass Sie die Mitteilung √ºber die Aus√ºbung des Widerrufsrechts vor Ablauf der Widerrufsfrist absenden.

Folgen des Widerrufs:
Wenn Sie diesen Vertrag widerrufen, haben wir Ihnen alle Zahlungen, die wir von Ihnen erhalten haben, unverz√ºglich und sp√§testens binnen vierzehn Tagen ab dem Tag zur√ºckzuzahlen, an dem die Mitteilung √ºber Ihren Widerruf dieses Vertrags bei uns eingegangen ist.""",
            height=250
        )

        datenschutz_text = st.text_area(
            "Datenschutzerkl√§rung*",
            value=empfehlung.datenschutz_text or """Datenschutzerkl√§rung

1. Verantwortliche Stelle
Verantwortlich f√ºr die Datenverarbeitung ist der jeweilige Makler.

2. Erhebung und Speicherung personenbezogener Daten
Wir erheben personenbezogene Daten, wenn Sie uns diese im Rahmen Ihrer Anfrage mitteilen.

3. Nutzung und Weitergabe personenbezogener Daten
Die erhobenen Daten werden ausschlie√ülich zur Vertragserf√ºllung verwendet.

4. Ihre Rechte
Sie haben das Recht auf Auskunft, Berichtigung, L√∂schung und Einschr√§nkung der Verarbeitung Ihrer Daten.""",
            height=200
        )

        st.markdown("---")

        # Zustimmung
        zustimmung = st.checkbox(
            "Ich best√§tige, dass alle Angaben korrekt sind und stimme der Ver√∂ffentlichung meiner Daten auf der Plattform zu.*"
        )

        submit = st.form_submit_button("üíæ Registrierung abschlie√üen", type="primary", use_container_width=True)

        if submit:
            # Validierung
            if not all([firmenname, kontaktperson, telefon, adresse, kurzvita, spezialisierung, regionen, agb_text, widerrufsbelehrung_text]):
                st.error("Bitte f√ºllen Sie alle Pflichtfelder (*) aus.")
            elif not zustimmung:
                st.error("Bitte best√§tigen Sie die Richtigkeit Ihrer Angaben.")
            else:
                # Daten speichern
                empfehlung.firmenname = firmenname
                empfehlung.makler_name = kontaktperson
                empfehlung.telefon = telefon
                empfehlung.website = website
                empfehlung.adresse = adresse
                empfehlung.kurzvita = kurzvita
                empfehlung.spezialisierung = spezialisierung
                empfehlung.regionen = regionen
                empfehlung.provision_verkaeufer_prozent = provision_verkaeufer
                empfehlung.provision_kaeufer_prozent = provision_kaeufer
                empfehlung.agb_text = agb_text
                empfehlung.widerrufsbelehrung_text = widerrufsbelehrung_text
                empfehlung.datenschutz_text = datenschutz_text
                empfehlung.status = MaklerEmpfehlungStatus.DATEN_EINGEGEBEN.value

                if logo_upload:
                    empfehlung.logo = logo_upload.read()

                st.session_state.makler_empfehlungen[empfehlung.empfehlung_id] = empfehlung

                # Benachrichtigung an Notar
                create_notification(
                    empfehlung.notar_id,
                    "Makler-Registrierung abgeschlossen",
                    f"Makler {firmenname} hat die Registrierung abgeschlossen und wartet auf Ihre Freigabe.",
                    NotificationType.INFO.value
                )

                st.success("""
                ‚úÖ Vielen Dank f√ºr Ihre Registrierung!

                Ihre Daten wurden erfolgreich √ºbermittelt.
                Der Notar wird Ihre Angaben pr√ºfen und Sie nach der Freigabe benachrichtigen.

                Sie erhalten dann Ihre Zugangsdaten per E-Mail.
                """)
                st.balloons()


# ===== KOMMUNIKATIONS-ERWEITERUNGEN: UI-KOMPONENTEN =====

def audit_log_eintrag(user_id: str, aktion: str, objekt_typ: str, objekt_id: str, objekt_name: str = "", projekt_id: str = "", akte_id: str = "", details: str = ""):
    """Erstellt einen Audit-Log-Eintrag"""
    user = st.session_state.users.get(user_id)
    eintrag = AuditLogEintrag(
        log_id=str(uuid.uuid4())[:8],
        timestamp=datetime.now(),
        user_id=user_id,
        user_name=user.name if user else "",
        user_rolle=user.rolle if user else "",
        aktion=aktion,
        objekt_typ=objekt_typ,
        objekt_id=objekt_id,
        objekt_name=objekt_name,
        projekt_id=projekt_id,
        akte_id=akte_id,
        details=details
    )
    st.session_state.audit_log.append(eintrag)


def render_briefkopf_administration(user_id: str):
    """Administration der Briefk√∂pfe"""
    st.subheader("üìù Briefkopf-Verwaltung")

    user = st.session_state.users.get(user_id)
    if not user:
        st.error("Benutzer nicht gefunden")
        return

    # Bestehenden Briefkopf suchen oder neuen erstellen
    briefkopf = None
    for bk in st.session_state.briefkoepfe.values():
        if bk.inhaber_id == user_id:
            briefkopf = bk
            break

    col_form, col_preview = st.columns([2, 1])

    with col_form:
        with st.form("briefkopf_form"):
            st.markdown("#### Logo")
            logo_file = st.file_uploader("Logo hochladen", type=['png', 'jpg', 'jpeg'], key="briefkopf_logo")
            logo_position = st.radio(
                "Logo-Position",
                ["links", "zentriert", "rechts"],
                horizontal=True,
                index=0 if not briefkopf else ["links", "zentriert", "rechts"].index(briefkopf.logo_position)
            )

            st.markdown("---")
            st.markdown("#### Firmendaten")
            col1, col2 = st.columns(2)
            with col1:
                firmenname = st.text_input("Firmenname", value=briefkopf.firmenname if briefkopf else "")
                zusatz = st.text_input("Zusatz (z.B. Notariat, Immobilienmakler)", value=briefkopf.zusatz if briefkopf else "")
            with col2:
                inhaber_name = st.text_input("Inhaber/Name", value=briefkopf.inhaber_name if briefkopf else user.name)

            st.markdown("---")
            st.markdown("#### Adresse")
            col1, col2 = st.columns([2, 1])
            with col1:
                strasse = st.text_input("Stra√üe", value=briefkopf.strasse if briefkopf else "")
            with col2:
                hausnummer = st.text_input("Hausnummer", value=briefkopf.hausnummer if briefkopf else "")

            col1, col2, col3 = st.columns([1, 2, 1])
            with col1:
                plz = st.text_input("PLZ", value=briefkopf.plz if briefkopf else "")
            with col2:
                ort = st.text_input("Ort", value=briefkopf.ort if briefkopf else "")
            with col3:
                land = st.text_input("Land", value=briefkopf.land if briefkopf else "Deutschland")

            st.markdown("---")
            st.markdown("#### Kontakt")
            col1, col2 = st.columns(2)
            with col1:
                telefon = st.text_input("Telefon", value=briefkopf.telefon if briefkopf else "")
                email = st.text_input("E-Mail", value=briefkopf.email if briefkopf else user.email)
            with col2:
                fax = st.text_input("Fax", value=briefkopf.fax if briefkopf else "")
                website = st.text_input("Website", value=briefkopf.website if briefkopf else "")

            st.markdown("---")
            st.markdown("#### Rechtliche Angaben")
            col1, col2, col3 = st.columns(3)
            with col1:
                steuernummer = st.text_input("Steuernummer", value=briefkopf.steuernummer if briefkopf else "")
            with col2:
                ust_id = st.text_input("USt-IdNr.", value=briefkopf.ust_id if briefkopf else "")
            with col3:
                handelsregister = st.text_input("Handelsregister", value=briefkopf.handelsregister if briefkopf else "")

            st.markdown("---")
            st.markdown("#### Bankverbindung")
            bank_name = st.text_input("Bank", value=briefkopf.bank_name if briefkopf else "")
            col1, col2 = st.columns(2)
            with col1:
                iban = st.text_input("IBAN", value=briefkopf.iban if briefkopf else "")
            with col2:
                bic = st.text_input("BIC", value=briefkopf.bic if briefkopf else "")

            st.markdown("---")
            st.markdown("#### Fu√üzeile")
            fusszeile_text = st.text_input("Fu√üzeile Zeile 1", value=briefkopf.fusszeile_text if briefkopf else "")
            fusszeile_zeile2 = st.text_input("Fu√üzeile Zeile 2", value=briefkopf.fusszeile_zeile2 if briefkopf else "")

            submitted = st.form_submit_button("üíæ Briefkopf speichern", type="primary")

            if submitted:
                logo_data = None
                if logo_file:
                    logo_data = logo_file.read()
                elif briefkopf and briefkopf.logo_data:
                    logo_data = briefkopf.logo_data

                inhaber_typ = "kanzlei" if user.rolle == UserRole.NOTAR.value else "maklerb√ºro" if user.rolle == UserRole.MAKLER.value else "user"

                if briefkopf:
                    # Aktualisieren
                    briefkopf.logo_data = logo_data
                    briefkopf.logo_position = logo_position
                    briefkopf.firmenname = firmenname
                    briefkopf.zusatz = zusatz
                    briefkopf.inhaber_name = inhaber_name
                    briefkopf.strasse = strasse
                    briefkopf.hausnummer = hausnummer
                    briefkopf.plz = plz
                    briefkopf.ort = ort
                    briefkopf.land = land
                    briefkopf.telefon = telefon
                    briefkopf.fax = fax
                    briefkopf.email = email
                    briefkopf.website = website
                    briefkopf.steuernummer = steuernummer
                    briefkopf.ust_id = ust_id
                    briefkopf.handelsregister = handelsregister
                    briefkopf.bank_name = bank_name
                    briefkopf.iban = iban
                    briefkopf.bic = bic
                    briefkopf.fusszeile_text = fusszeile_text
                    briefkopf.fusszeile_zeile2 = fusszeile_zeile2
                    briefkopf.aktualisiert_am = datetime.now()
                    st.session_state.briefkoepfe[briefkopf.briefkopf_id] = briefkopf
                else:
                    # Neu erstellen
                    briefkopf_id = str(uuid.uuid4())[:8]
                    briefkopf = Briefkopf(
                        briefkopf_id=briefkopf_id,
                        inhaber_id=user_id,
                        inhaber_typ=inhaber_typ,
                        logo_data=logo_data,
                        logo_position=logo_position,
                        firmenname=firmenname,
                        zusatz=zusatz,
                        inhaber_name=inhaber_name,
                        strasse=strasse,
                        hausnummer=hausnummer,
                        plz=plz,
                        ort=ort,
                        land=land,
                        telefon=telefon,
                        fax=fax,
                        email=email,
                        website=website,
                        steuernummer=steuernummer,
                        ust_id=ust_id,
                        handelsregister=handelsregister,
                        bank_name=bank_name,
                        iban=iban,
                        bic=bic,
                        fusszeile_text=fusszeile_text,
                        fusszeile_zeile2=fusszeile_zeile2
                    )
                    st.session_state.briefkoepfe[briefkopf_id] = briefkopf

                st.success("‚úÖ Briefkopf gespeichert!")
                audit_log_eintrag(user_id, "bearbeitet", "briefkopf", briefkopf.briefkopf_id, "Briefkopf")
                st.rerun()

    with col_preview:
        st.markdown("#### Vorschau")
        if briefkopf or firmenname:
            # Briefkopf-Vorschau
            bk = briefkopf if briefkopf else None
            preview_html = f"""
            <div style="border: 1px solid #ccc; padding: 20px; font-family: Arial; max-width: 400px;">
                <div style="text-align: {'left' if (bk and bk.logo_position == 'links') else 'center' if (bk and bk.logo_position == 'zentriert') else 'right'};">
                    <strong style="font-size: 16px;">{bk.firmenname if bk else firmenname or 'Firmenname'}</strong><br>
                    <span style="font-size: 12px; color: #666;">{bk.zusatz if bk else zusatz or ''}</span><br>
                    <span style="font-size: 11px;">{bk.inhaber_name if bk else inhaber_name or ''}</span>
                </div>
                <hr style="margin: 10px 0;">
                <div style="font-size: 10px; color: #666; text-align: center;">
                    {bk.strasse if bk else strasse or ''} {bk.hausnummer if bk else hausnummer or ''} ¬∑ {bk.plz if bk else plz or ''} {bk.ort if bk else ort or ''}<br>
                    Tel: {bk.telefon if bk else telefon or ''} ¬∑ {bk.email if bk else email or ''}
                </div>
            </div>
            """
            st.markdown(preview_html, unsafe_allow_html=True)
        else:
            st.info("F√ºllen Sie das Formular aus, um eine Vorschau zu sehen.")


def render_email_signaturen(user_id: str):
    """Verwaltung der E-Mail-Signaturen"""
    st.subheader("‚úâÔ∏è E-Mail-Signaturen")

    user = st.session_state.users.get(user_id)
    if not user:
        st.error("Benutzer nicht gefunden")
        return

    # Bestehende Signaturen laden
    user_signaturen = [s for s in st.session_state.email_signaturen.values() if s.user_id == user_id]

    col1, col2 = st.columns([2, 1])

    with col1:
        st.markdown("### Meine Signaturen")

        if user_signaturen:
            for sig in user_signaturen:
                with st.expander(f"{'‚≠ê ' if sig.ist_standard else ''}{sig.name}", expanded=sig.ist_standard):
                    st.markdown(sig.html_signatur if sig.html_signatur else sig.text_signatur, unsafe_allow_html=True)

                    col_a, col_b, col_c = st.columns(3)
                    with col_a:
                        if st.button("‚úèÔ∏è Bearbeiten", key=f"edit_sig_{sig.signatur_id}"):
                            st.session_state[f'editing_signatur_{user_id}'] = sig.signatur_id
                            st.rerun()
                    with col_b:
                        if not sig.ist_standard:
                            if st.button("‚≠ê Als Standard", key=f"std_sig_{sig.signatur_id}"):
                                for s in user_signaturen:
                                    s.ist_standard = False
                                    st.session_state.email_signaturen[s.signatur_id] = s
                                sig.ist_standard = True
                                st.session_state.email_signaturen[sig.signatur_id] = sig
                                st.success("Als Standard-Signatur festgelegt!")
                                st.rerun()
                    with col_c:
                        if len(user_signaturen) > 1:
                            if st.button("üóëÔ∏è L√∂schen", key=f"del_sig_{sig.signatur_id}"):
                                del st.session_state.email_signaturen[sig.signatur_id]
                                st.success("Signatur gel√∂scht!")
                                st.rerun()
        else:
            st.info("Noch keine Signaturen angelegt.")

    with col2:
        st.markdown("### Neue Signatur erstellen")

        with st.form("neue_signatur_form"):
            sig_name = st.text_input("Name der Signatur", placeholder="z.B. Standard, Formal, Kurz")
            sig_text = st.text_area(
                "Signatur-Text",
                height=200,
                placeholder="""Mit freundlichen Gr√º√üen

Max Mustermann
Notar

Musterstra√üe 1, 12345 Musterstadt
Tel: 0123-456789
E-Mail: info@notar-muster.de""",
                help="Verwenden Sie Platzhalter wie {{name}}, {{telefon}}, {{email}}"
            )

            ist_standard = st.checkbox("Als Standard-Signatur verwenden", value=len(user_signaturen) == 0)
            fuer_antworten = st.checkbox("Auch f√ºr Antworten verwenden", value=True)

            if st.form_submit_button("üíæ Signatur speichern", type="primary"):
                if sig_name and sig_text:
                    signatur_id = str(uuid.uuid4())[:8]

                    # Wenn als Standard markiert, andere deaktivieren
                    if ist_standard:
                        for s in user_signaturen:
                            s.ist_standard = False
                            st.session_state.email_signaturen[s.signatur_id] = s

                    neue_signatur = EmailSignatur(
                        signatur_id=signatur_id,
                        user_id=user_id,
                        name=sig_name,
                        text_signatur=sig_text,
                        html_signatur=sig_text.replace('\n', '<br>'),
                        ist_standard=ist_standard,
                        fuer_antworten=fuer_antworten
                    )
                    st.session_state.email_signaturen[signatur_id] = neue_signatur
                    st.success(f"‚úÖ Signatur '{sig_name}' erstellt!")
                    st.rerun()
                else:
                    st.error("Bitte Name und Text eingeben.")

    # Platzhalter-Hilfe
    st.markdown("---")
    with st.expander("üìã Verf√ºgbare Platzhalter"):
        st.markdown("""
        | Platzhalter | Beschreibung |
        |-------------|--------------|
        | `{{name}}` | Vollst√§ndiger Name |
        | `{{vorname}}` | Vorname |
        | `{{nachname}}` | Nachname |
        | `{{titel}}` | Titel (Dr., Prof., etc.) |
        | `{{position}}` | Position/Rolle |
        | `{{telefon}}` | Telefonnummer |
        | `{{email}}` | E-Mail-Adresse |
        | `{{firma}}` | Firmenname |
        | `{{adresse}}` | Vollst√§ndige Adresse |
        | `{{datum}}` | Aktuelles Datum |
        | `{{aktenzeichen}}` | Aktenzeichen (im Kontext) |
        """)


def render_makler_mitarbeiter_verwaltung(makler_id: str):
    """Mitarbeiterverwaltung f√ºr Makler"""
    st.subheader("üë• Mitarbeiter-Verwaltung")

    makler = st.session_state.users.get(makler_id)
    if not makler or makler.rolle != UserRole.MAKLER.value:
        st.error("Nur f√ºr Makler verf√ºgbar")
        return

    # Bestehende Mitarbeiter laden
    mitarbeiter_liste = [m for m in st.session_state.makler_mitarbeiter.values() if m.makler_id == makler_id]

    tab1, tab2, tab3 = st.tabs(["üë• √úbersicht", "‚ûï Neuer Mitarbeiter", "üìã Projektzuweisung"])

    with tab1:
        if mitarbeiter_liste:
            for ma in mitarbeiter_liste:
                status_icon = "‚úÖ" if ma.ist_aktiv else "‚è∏Ô∏è"
                with st.expander(f"{status_icon} {ma.vorname} {ma.name} ({ma.rolle})", expanded=False):
                    col1, col2 = st.columns(2)
                    with col1:
                        st.markdown(f"**E-Mail:** {ma.email}")
                        st.markdown(f"**Telefon:** {ma.telefon or '-'}")
                        st.markdown(f"**K√ºrzel:** {ma.kuerzel or '-'}")
                        st.markdown(f"**Eingestellt:** {ma.eingestellt_am.strftime('%d.%m.%Y')}")
                    with col2:
                        st.markdown(f"**Zugewiesene Projekte:** {len(ma.projekt_ids)}")
                        st.markdown(f"**Alle Projekte sehen:** {'Ja' if ma.kann_alle_projekte_sehen else 'Nein'}")
                        st.markdown(f"**Im Namen kommunizieren:** {'Ja' if ma.kann_im_namen_kommunizieren else 'Nein'}")

                    st.markdown("**Berechtigungen:**")
                    if ma.berechtigungen:
                        berechtigung_cols = st.columns(3)
                        for i, b in enumerate(ma.berechtigungen):
                            berechtigung_cols[i % 3].markdown(f"‚úì {b}")
                    else:
                        st.info("Keine speziellen Berechtigungen")

                    col_a, col_b, col_c = st.columns(3)
                    with col_a:
                        if st.button("‚úèÔ∏è Bearbeiten", key=f"edit_ma_{ma.mitarbeiter_id}"):
                            st.session_state[f'editing_mitarbeiter'] = ma.mitarbeiter_id
                            st.rerun()
                    with col_b:
                        new_status = not ma.ist_aktiv
                        if st.button("‚úÖ Aktivieren" if not ma.ist_aktiv else "‚è∏Ô∏è Deaktivieren", key=f"status_ma_{ma.mitarbeiter_id}"):
                            ma.ist_aktiv = new_status
                            st.session_state.makler_mitarbeiter[ma.mitarbeiter_id] = ma
                            st.success(f"Mitarbeiter {'aktiviert' if new_status else 'deaktiviert'}!")
                            st.rerun()
                    with col_c:
                        if st.button("üóëÔ∏è Entfernen", key=f"del_ma_{ma.mitarbeiter_id}"):
                            del st.session_state.makler_mitarbeiter[ma.mitarbeiter_id]
                            st.success("Mitarbeiter entfernt!")
                            st.rerun()
        else:
            st.info("Noch keine Mitarbeiter angelegt. F√ºgen Sie im Tab 'Neuer Mitarbeiter' welche hinzu.")

    with tab2:
        with st.form("neuer_mitarbeiter_form"):
            st.markdown("### Neuen Mitarbeiter hinzuf√ºgen")

            col1, col2 = st.columns(2)
            with col1:
                ma_vorname = st.text_input("Vorname*")
                ma_email = st.text_input("E-Mail*")
                ma_kuerzel = st.text_input("K√ºrzel (f√ºr Aktenzeichen)", max_chars=3)
            with col2:
                ma_name = st.text_input("Nachname*")
                ma_telefon = st.text_input("Telefon")
                ma_passwort = st.text_input("Passwort*", type="password")

            st.markdown("---")
            ma_rolle = st.selectbox("Rolle", [r.value for r in MaklerMitarbeiterRolle])

            st.markdown("**Berechtigungen:**")
            col1, col2, col3 = st.columns(3)

            berechtigungen = []
            with col1:
                if st.checkbox("Projekte ansehen", value=True, key="perm_ansehen"):
                    berechtigungen.append(MaklerBerechtigungTyp.PROJEKTE_ANSEHEN.value)
                if st.checkbox("Projekte bearbeiten", value=True, key="perm_bearbeiten"):
                    berechtigungen.append(MaklerBerechtigungTyp.PROJEKTE_BEARBEITEN.value)
                if st.checkbox("Projekte erstellen", key="perm_erstellen"):
                    berechtigungen.append(MaklerBerechtigungTyp.PROJEKTE_ERSTELLEN.value)
                if st.checkbox("Expos√©s erstellen", value=True, key="perm_expose"):
                    berechtigungen.append(MaklerBerechtigungTyp.EXPOSE_ERSTELLEN.value)

            with col2:
                if st.checkbox("Nachrichten senden", value=True, key="perm_nachrichten"):
                    berechtigungen.append(MaklerBerechtigungTyp.NACHRICHTEN_SENDEN.value)
                if st.checkbox("Dokumente hochladen", value=True, key="perm_dokumente"):
                    berechtigungen.append(MaklerBerechtigungTyp.DOKUMENTE_HOCHLADEN.value)
                if st.checkbox("Teilnehmer einladen", key="perm_teilnehmer"):
                    berechtigungen.append(MaklerBerechtigungTyp.TEILNEHMER_EINLADEN.value)
                if st.checkbox("Termine erstellen", value=True, key="perm_termine"):
                    berechtigungen.append(MaklerBerechtigungTyp.TERMINE_ERSTELLEN.value)

            with col3:
                if st.checkbox("Preise sehen", key="perm_preise"):
                    berechtigungen.append(MaklerBerechtigungTyp.PREISE_SEHEN.value)
                if st.checkbox("Preisverhandlungen f√ºhren", key="perm_verhandeln"):
                    berechtigungen.append(MaklerBerechtigungTyp.PREISE_VERHANDELN.value)
                kann_im_namen = st.checkbox("Im Namen des Maklers kommunizieren", key="perm_im_namen")
                kann_alle_sehen = st.checkbox("Alle Projekte sehen", key="perm_alle")

            if st.form_submit_button("üìß Mitarbeiter hinzuf√ºgen", type="primary"):
                if ma_vorname and ma_name and ma_email and ma_passwort:
                    mitarbeiter_id = str(uuid.uuid4())[:8]

                    if kann_im_namen:
                        berechtigungen.append(MaklerBerechtigungTyp.IM_NAMEN_KOMMUNIZIEREN.value)

                    neuer_ma = MaklerMitarbeiter(
                        mitarbeiter_id=mitarbeiter_id,
                        makler_id=makler_id,
                        name=ma_name,
                        vorname=ma_vorname,
                        email=ma_email,
                        telefon=ma_telefon,
                        password_hash=hash_password(ma_passwort),
                        rolle=ma_rolle,
                        berechtigungen=berechtigungen,
                        kann_alle_projekte_sehen=kann_alle_sehen,
                        kann_im_namen_kommunizieren=kann_im_namen,
                        kuerzel=ma_kuerzel.upper() if ma_kuerzel else ""
                    )
                    st.session_state.makler_mitarbeiter[mitarbeiter_id] = neuer_ma

                    st.success(f"‚úÖ Mitarbeiter {ma_vorname} {ma_name} hinzugef√ºgt!")
                    audit_log_eintrag(makler_id, "erstellt", "mitarbeiter", mitarbeiter_id, f"{ma_vorname} {ma_name}")
                    st.rerun()
                else:
                    st.error("Bitte alle Pflichtfelder (*) ausf√ºllen.")

    with tab3:
        st.markdown("### Projekte zuweisen")

        if not mitarbeiter_liste:
            st.info("Erst Mitarbeiter anlegen, dann Projekte zuweisen.")
            return

        makler_projekte = [p for p in st.session_state.projekte.values() if p.makler_id == makler_id]

        if not makler_projekte:
            st.info("Noch keine Projekte vorhanden.")
            return

        selected_projekt = st.selectbox(
            "Projekt ausw√§hlen",
            makler_projekte,
            format_func=lambda p: f"{p.name} ({p.adresse})" if p.adresse else p.name
        )

        if selected_projekt:
            st.markdown(f"**Mitarbeiter f√ºr '{selected_projekt.name}':**")

            for ma in mitarbeiter_liste:
                ist_zugewiesen = selected_projekt.projekt_id in ma.projekt_ids
                col1, col2 = st.columns([3, 1])
                with col1:
                    checked = st.checkbox(
                        f"{ma.vorname} {ma.name} ({ma.rolle})",
                        value=ist_zugewiesen,
                        key=f"assign_{selected_projekt.projekt_id}_{ma.mitarbeiter_id}"
                    )
                with col2:
                    if checked != ist_zugewiesen:
                        if checked:
                            ma.projekt_ids.append(selected_projekt.projekt_id)
                        else:
                            ma.projekt_ids.remove(selected_projekt.projekt_id)
                        st.session_state.makler_mitarbeiter[ma.mitarbeiter_id] = ma
                        st.rerun()


def render_kommunikationszentrale(user_id: str, projekt_id: str = None):
    """Kommunikationszentrale mit Posteingang/Postausgang"""
    st.subheader("üì¨ Kommunikationszentrale")

    user = st.session_state.users.get(user_id)
    if not user:
        st.error("Benutzer nicht gefunden")
        return

    # Nachrichten f√ºr diesen Benutzer laden
    empfangene = [n for n in st.session_state.nachrichten.values()
                  if user_id in n.empfaenger_ids and not n.ist_geloescht and not n.ist_entwurf]
    gesendete = [n for n in st.session_state.nachrichten.values()
                 if n.absender_id == user_id and not n.ist_geloescht and not n.ist_entwurf]
    entwuerfe = [n for n in st.session_state.nachrichten.values()
                 if n.absender_id == user_id and n.ist_entwurf]

    # Filter nach Projekt wenn angegeben
    if projekt_id:
        empfangene = [n for n in empfangene if n.projekt_id == projekt_id]
        gesendete = [n for n in gesendete if n.projekt_id == projekt_id]

    # Ungelesene z√§hlen
    ungelesen_count = len([n for n in empfangene if user_id not in n.gelesen_von])

    tab1, tab2, tab3, tab4 = st.tabs([
        f"üì• Posteingang ({ungelesen_count})" if ungelesen_count > 0 else "üì• Posteingang",
        "üì§ Gesendet",
        f"üìù Entw√ºrfe ({len(entwuerfe)})" if entwuerfe else "üìù Entw√ºrfe",
        "‚úâÔ∏è Neue Nachricht"
    ])

    with tab1:
        _render_nachrichten_liste(empfangene, user_id, "eingang")

    with tab2:
        _render_nachrichten_liste(gesendete, user_id, "ausgang")

    with tab3:
        _render_nachrichten_liste(entwuerfe, user_id, "entwurf")

    with tab4:
        _render_neue_nachricht_form(user_id, projekt_id)


def _render_nachrichten_liste(nachrichten: list, user_id: str, typ: str):
    """Rendert eine Liste von Nachrichten"""
    if not nachrichten:
        st.info("Keine Nachrichten vorhanden.")
        return

    # Sortierung
    sort_option = st.selectbox(
        "Sortieren nach",
        ["Neueste zuerst", "√Ñlteste zuerst", "Priorit√§t", "Ungelesen zuerst"],
        key=f"sort_{typ}"
    )

    if sort_option == "Neueste zuerst":
        nachrichten.sort(key=lambda n: n.erstellt_am, reverse=True)
    elif sort_option == "√Ñlteste zuerst":
        nachrichten.sort(key=lambda n: n.erstellt_am)
    elif sort_option == "Priorit√§t":
        prio_order = {NachrichtenPrioritaet.DRINGEND.value: 0, NachrichtenPrioritaet.HOCH.value: 1, NachrichtenPrioritaet.NORMAL.value: 2}
        nachrichten.sort(key=lambda n: prio_order.get(n.prioritaet, 2))
    elif sort_option == "Ungelesen zuerst":
        nachrichten.sort(key=lambda n: (user_id in n.gelesen_von, n.erstellt_am), reverse=True)

    for nachricht in nachrichten:
        ist_gelesen = user_id in nachricht.gelesen_von
        absender = st.session_state.users.get(nachricht.absender_id)
        absender_name = absender.name if absender else "Unbekannt"

        # Priorit√§t-Icon
        prio_icon = ""
        if nachricht.prioritaet == NachrichtenPrioritaet.DRINGEND.value:
            prio_icon = "üî¥ "
        elif nachricht.prioritaet == NachrichtenPrioritaet.HOCH.value:
            prio_icon = "üü† "

        # Sicherheitsstufe-Icon
        sicher_icon = ""
        if nachricht.sicherheitsstufe == Sicherheitsstufe.VERTRAULICH.value:
            sicher_icon = "üîí "
        elif nachricht.sicherheitsstufe == Sicherheitsstufe.STRENG_VERTRAULICH.value:
            sicher_icon = "üîê "

        anlagen_count = len(nachricht.anlage_ids)
        anlagen_text = f" üìé{anlagen_count}" if anlagen_count > 0 else ""

        titel = f"{'**' if not ist_gelesen else ''}{prio_icon}{sicher_icon}{nachricht.betreff}{anlagen_text}{'**' if not ist_gelesen else ''}"

        with st.expander(f"{titel} - {absender_name} ({nachricht.erstellt_am.strftime('%d.%m.%Y %H:%M')})"):
            # Als gelesen markieren
            if typ == "eingang" and user_id not in nachricht.gelesen_von:
                nachricht.gelesen_von.append(user_id)
                st.session_state.nachrichten[nachricht.nachricht_id] = nachricht
                audit_log_eintrag(user_id, "angesehen", "nachricht", nachricht.nachricht_id, nachricht.betreff)

            st.markdown(f"**Von:** {absender_name}")
            st.markdown(f"**Betreff:** {nachricht.betreff}")
            st.markdown(f"**Kategorie:** {nachricht.kategorie}")
            if nachricht.projekt_id:
                projekt = st.session_state.projekte.get(nachricht.projekt_id)
                if projekt:
                    st.markdown(f"**Projekt:** {projekt.name}")
            st.markdown("---")
            st.markdown(nachricht.inhalt)

            # Anlagen anzeigen
            if nachricht.anlage_ids:
                st.markdown("---")
                st.markdown("**üìé Anlagen:**")
                for anlage_id in nachricht.anlage_ids:
                    anlage = st.session_state.kommunikations_anlagen.get(anlage_id)
                    if anlage:
                        col1, col2 = st.columns([3, 1])
                        with col1:
                            st.markdown(f"‚Ä¢ {anlage.dateiname} ({anlage.dateigroesse // 1024} KB)")
                        with col2:
                            if anlage.datei_data:
                                st.download_button(
                                    "‚¨áÔ∏è",
                                    anlage.datei_data,
                                    file_name=anlage.dateiname,
                                    key=f"dl_{anlage.anlage_id}"
                                )


def _render_neue_nachricht_form(user_id: str, projekt_id: str = None):
    """Formular f√ºr neue Nachricht"""
    user = st.session_state.users.get(user_id)

    with st.form("neue_nachricht_form"):
        # Projekt ausw√§hlen (wenn nicht vorgegeben)
        if not projekt_id:
            user_projekte = _get_user_projekte(user_id, user.rolle)
            if user_projekte:
                selected_projekt = st.selectbox(
                    "Projekt",
                    [None] + user_projekte,
                    format_func=lambda p: "-- Kein Projekt --" if p is None else p.name
                )
                projekt_id = selected_projekt.projekt_id if selected_projekt else None

        # Empf√§nger
        empfaenger_optionen = _get_moegliche_empfaenger(user_id, projekt_id)
        empfaenger = st.multiselect("Empf√§nger*", list(empfaenger_optionen.keys()))

        betreff = st.text_input("Betreff*")

        col1, col2 = st.columns(2)
        with col1:
            kategorie = st.selectbox("Kategorie", [k.value for k in NachrichtenKategorie])
        with col2:
            prioritaet = st.selectbox("Priorit√§t", [p.value for p in NachrichtenPrioritaet])

        sicherheitsstufe = st.selectbox("Sicherheitsstufe", [s.value for s in Sicherheitsstufe])

        inhalt = st.text_area("Nachricht*", height=200)

        # Anlagen
        anlagen = st.file_uploader("Anlagen hinzuf√ºgen", accept_multiple_files=True)

        col1, col2 = st.columns(2)
        with col1:
            senden = st.form_submit_button("üì§ Senden", type="primary")
        with col2:
            speichern = st.form_submit_button("üíæ Als Entwurf speichern")

        if senden or speichern:
            if (senden and not empfaenger) or not betreff or not inhalt:
                st.error("Bitte alle Pflichtfelder (*) ausf√ºllen.")
            else:
                nachricht_id = str(uuid.uuid4())[:8]

                # Anlagen speichern
                anlage_ids = []
                for datei in anlagen:
                    anlage_id = str(uuid.uuid4())[:8]
                    anlage = KommunikationsAnlage(
                        anlage_id=anlage_id,
                        nachricht_id=nachricht_id,
                        projekt_id=projekt_id or "",
                        dateiname=datei.name,
                        dateityp=datei.name.split('.')[-1].upper() if '.' in datei.name else "UNBEKANNT",
                        dateigroesse=datei.size,
                        datei_data=datei.read(),
                        hochgeladen_von=user_id,
                        sicherheitsstufe=sicherheitsstufe
                    )
                    st.session_state.kommunikations_anlagen[anlage_id] = anlage
                    anlage_ids.append(anlage_id)

                empfaenger_ids = [empfaenger_optionen[e] for e in empfaenger] if empfaenger else []

                nachricht = KommunikationsNachricht(
                    nachricht_id=nachricht_id,
                    projekt_id=projekt_id or "",
                    absender_id=user_id,
                    empfaenger_ids=empfaenger_ids,
                    betreff=betreff,
                    inhalt=inhalt,
                    inhalt_plaintext=inhalt,
                    prioritaet=prioritaet,
                    kategorie=kategorie,
                    sicherheitsstufe=sicherheitsstufe,
                    anlage_ids=anlage_ids,
                    ist_entwurf=speichern,
                    gesendet_am=datetime.now() if senden else None
                )
                st.session_state.nachrichten[nachricht_id] = nachricht

                if senden:
                    # Benachrichtigungen erstellen
                    for emp_id in empfaenger_ids:
                        create_notification(emp_id, f"Neue Nachricht: {betreff}", f"Von {user.name}", NotificationType.INFO.value)

                    st.success("‚úÖ Nachricht gesendet!")
                    audit_log_eintrag(user_id, "gesendet", "nachricht", nachricht_id, betreff, projekt_id)
                else:
                    st.success("‚úÖ Entwurf gespeichert!")

                st.rerun()


def _get_user_projekte(user_id: str, rolle: str) -> list:
    """Holt alle Projekte eines Benutzers"""
    projekte = []
    for p in st.session_state.projekte.values():
        if rolle == UserRole.MAKLER.value and p.makler_id == user_id:
            projekte.append(p)
        elif rolle == UserRole.NOTAR.value and p.notar_id == user_id:
            projekte.append(p)
        elif rolle == UserRole.KAEUFER.value and user_id in p.kaeufer_ids:
            projekte.append(p)
        elif rolle == UserRole.VERKAEUFER.value and user_id in p.verkaeufer_ids:
            projekte.append(p)
        elif rolle == UserRole.FINANZIERER.value and user_id in p.finanzierer_ids:
            projekte.append(p)
    return projekte


def _get_moegliche_empfaenger(user_id: str, projekt_id: str = None) -> dict:
    """Holt m√∂gliche Empf√§nger f√ºr Nachrichten"""
    empfaenger = {}

    if projekt_id:
        projekt = st.session_state.projekte.get(projekt_id)
        if projekt:
            # Alle Projektbeteiligten
            if projekt.makler_id and projekt.makler_id != user_id:
                makler = st.session_state.users.get(projekt.makler_id)
                if makler:
                    empfaenger[f"üëî Makler: {makler.name}"] = projekt.makler_id

            if projekt.notar_id and projekt.notar_id != user_id:
                notar = st.session_state.users.get(projekt.notar_id)
                if notar:
                    empfaenger[f"‚öñÔ∏è Notar: {notar.name}"] = projekt.notar_id

            for kid in projekt.kaeufer_ids:
                if kid != user_id:
                    kaeufer = st.session_state.users.get(kid)
                    if kaeufer:
                        empfaenger[f"üè† K√§ufer: {kaeufer.name}"] = kid

            for vid in projekt.verkaeufer_ids:
                if vid != user_id:
                    verkaeufer = st.session_state.users.get(vid)
                    if verkaeufer:
                        empfaenger[f"üè° Verk√§ufer: {verkaeufer.name}"] = vid

            for fid in projekt.finanzierer_ids:
                if fid != user_id:
                    finanzierer = st.session_state.users.get(fid)
                    if finanzierer:
                        empfaenger[f"üè¶ Finanzierer: {finanzierer.name}"] = fid
    else:
        # Alle bekannten Benutzer (au√üer sich selbst)
        for uid, u in st.session_state.users.items():
            if uid != user_id:
                rolle_icon = {"Makler": "üëî", "Notar": "‚öñÔ∏è", "K√§ufer": "üè†", "Verk√§ufer": "üè°", "Finanzierer": "üè¶"}.get(u.rolle, "üë§")
                empfaenger[f"{rolle_icon} {u.name}"] = uid

    return empfaenger


def render_akten_ordner_struktur(akte_id: str, user_id: str):
    """Rendert die Ordnerstruktur einer Akte"""
    akte = st.session_state.importierte_akten.get(akte_id)
    if not akte:
        st.error("Akte nicht gefunden")
        return

    st.markdown(f"### üìÅ {akte.aktenzeichen}")

    # Ordner f√ºr diese Akte laden
    ordner_liste = [o for o in st.session_state.akten_ordner.values() if o.akte_id == akte_id]
    ordner_liste.sort(key=lambda o: o.pfad)

    # Dokumente in dieser Akte
    dokumente = [d for d in st.session_state.akten_dokumente.values() if d.akte_id == akte_id] if hasattr(st.session_state, 'akten_dokumente') else []

    if not ordner_liste:
        # Ordner aus Template erstellen
        st.info("Keine Ordnerstruktur vorhanden. M√∂chten Sie eine Standard-Struktur erstellen?")

        akten_typ = st.selectbox("Aktentyp ausw√§hlen", list(AKTEN_ORDNER_TEMPLATES.keys()))

        if st.button("üìÅ Ordnerstruktur erstellen"):
            _erstelle_ordner_struktur(akte_id, akten_typ, user_id)
            st.success("Ordnerstruktur erstellt!")
            st.rerun()
    else:
        # Ordner als Baum anzeigen
        for ordner in ordner_liste:
            tiefe = ordner.pfad.count('/') - 1
            einzug = "  " * tiefe
            ordner_name = ordner.pfad.split('/')[-1]

            # Dokumente in diesem Ordner z√§hlen
            dok_count = len([d for d in dokumente if d.ordner_name == ordner.pfad])

            if dok_count > 0:
                with st.expander(f"{einzug}üìÇ {ordner_name} ({dok_count} Dokumente)"):
                    for dok in [d for d in dokumente if d.ordner_name == ordner.pfad]:
                        st.markdown(f"üìÑ {dok.titel}")
            else:
                st.markdown(f"{einzug}üìÅ {ordner_name}")


def _erstelle_ordner_struktur(akte_id: str, akten_typ: str, user_id: str):
    """Erstellt die Ordnerstruktur f√ºr eine Akte"""
    template = AKTEN_ORDNER_TEMPLATES.get(akten_typ, [])

    for pfad, beschreibung in template:
        ordner_id = str(uuid.uuid4())[:8]
        ordner = AktenOrdner(
            ordner_id=ordner_id,
            akte_id=akte_id,
            name=pfad.split('/')[-1],
            pfad=f"/{pfad}",
            beschreibung=beschreibung,
            erstellt_von=user_id
        )
        st.session_state.akten_ordner[ordner_id] = ordner


def render_erweiterte_suche(user_id: str):
    """Erweiterte Such- und Filterfunktionen"""
    st.subheader("üîç Erweiterte Suche")

    user = st.session_state.users.get(user_id)

    # Gespeicherte Suchen
    user_suchen = [s for s in st.session_state.gespeicherte_suchen.values() if s.user_id == user_id]

    col1, col2 = st.columns([3, 1])

    with col1:
        suchbegriff = st.text_input("üîç Suchbegriff", placeholder="Aktenzeichen, Name, Betreff...")

    with col2:
        if user_suchen:
            gespeicherte = st.selectbox(
                "Gespeicherte Suchen",
                [None] + user_suchen,
                format_func=lambda s: "-- Neue Suche --" if s is None else f"‚≠ê {s.name}"
            )
            if gespeicherte:
                suchbegriff = gespeicherte.suchbegriff

    # Filter
    with st.expander("üéõÔ∏è Erweiterte Filter", expanded=False):
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            filter_typ = st.multiselect(
                "Suchen in",
                ["Akten", "Nachrichten", "Dokumente", "Projekte"],
                default=["Akten", "Nachrichten", "Dokumente", "Projekte"]
            )

        with col2:
            filter_zeitraum = st.selectbox(
                "Zeitraum",
                ["Alle", "Heute", "Diese Woche", "Dieser Monat", "Dieses Jahr", "Benutzerdefiniert"]
            )

        with col3:
            filter_status = st.selectbox(
                "Status",
                ["Alle", "Offen", "In Bearbeitung", "Abgeschlossen", "Archiviert"]
            )

        with col4:
            filter_sicherheit = st.selectbox(
                "Sicherheitsstufe",
                ["Alle"] + [s.value for s in Sicherheitsstufe]
            )

        if filter_zeitraum == "Benutzerdefiniert":
            col1, col2 = st.columns(2)
            with col1:
                datum_von = st.date_input("Von")
            with col2:
                datum_bis = st.date_input("Bis")

    # Sortierung
    sortierung = st.selectbox(
        "Sortieren nach",
        ["Relevanz", "Datum (neueste)", "Datum (√§lteste)", "Name (A-Z)", "Name (Z-A)"]
    )

    col1, col2 = st.columns([1, 4])
    with col1:
        suchen_clicked = st.button("üîç Suchen", type="primary")
    with col2:
        if suchbegriff:
            speichern_clicked = st.button("üíæ Suche speichern")
            if speichern_clicked:
                suche_id = str(uuid.uuid4())[:8]
                name = st.text_input("Name f√ºr die Suche", value=suchbegriff[:30])
                if name:
                    neue_suche = GespeicherteSuche(
                        suche_id=suche_id,
                        user_id=user_id,
                        name=name,
                        suchbegriff=suchbegriff,
                        filter_kriterien={
                            "typ": filter_typ,
                            "zeitraum": filter_zeitraum,
                            "status": filter_status,
                            "sicherheit": filter_sicherheit
                        },
                        sortierung=sortierung
                    )
                    st.session_state.gespeicherte_suchen[suche_id] = neue_suche
                    st.success("Suche gespeichert!")

    # Suchergebnisse
    if suchen_clicked and suchbegriff:
        st.markdown("---")
        st.markdown("### Suchergebnisse")

        ergebnisse = []

        # In Akten suchen
        if "Akten" in filter_typ:
            for akte in st.session_state.importierte_akten.values():
                if suchbegriff.lower() in akte.aktenzeichen.lower() or suchbegriff.lower() in akte.bezeichnung.lower():
                    ergebnisse.append(("üìÅ Akte", akte.aktenzeichen, akte.bezeichnung, akte.importiert_am))

        # In Nachrichten suchen
        if "Nachrichten" in filter_typ:
            for nachricht in st.session_state.nachrichten.values():
                if user_id in nachricht.empfaenger_ids or nachricht.absender_id == user_id:
                    if suchbegriff.lower() in nachricht.betreff.lower() or suchbegriff.lower() in nachricht.inhalt.lower():
                        ergebnisse.append(("‚úâÔ∏è Nachricht", nachricht.betreff, nachricht.inhalt[:100], nachricht.erstellt_am))

        # In Projekten suchen
        if "Projekte" in filter_typ:
            for projekt in st.session_state.projekte.values():
                if suchbegriff.lower() in projekt.name.lower() or suchbegriff.lower() in projekt.beschreibung.lower():
                    ergebnisse.append(("üèòÔ∏è Projekt", projekt.name, projekt.beschreibung, projekt.created_at))

        if ergebnisse:
            st.info(f"{len(ergebnisse)} Ergebnisse gefunden")
            for typ, titel, beschreibung, datum in ergebnisse:
                with st.expander(f"{typ} {titel}"):
                    st.markdown(beschreibung)
                    st.caption(f"Datum: {datum.strftime('%d.%m.%Y %H:%M') if datum else '-'}")
        else:
            st.warning("Keine Ergebnisse gefunden.")


# ============================================================================
# BENACHRICHTIGUNGS-CENTER FUNKTIONEN
# ============================================================================

def _initialisiere_system_antwortvorlagen():
    """Initialisiert die System-Antwortvorlagen"""
    if 'antwort_vorlagen' not in st.session_state:
        st.session_state.antwort_vorlagen = {}

    system_vorlagen = [
        AntwortVorlage(
            vorlage_id="sys_bestaetigung_dokument",
            name="Dokumentenempfang best√§tigen",
            kategorie="Best√§tigung",
            betreff_template="Best√§tigung: {dokument_name} erhalten",
            text_template="Sehr geehrte/r {empfaenger_name},\n\nhiermit best√§tigen wir den Erhalt des Dokuments \"{dokument_name}\".\n\nDas Dokument wird nun gepr√ºft. Bei R√ºckfragen melden wir uns umgehend.\n\nMit freundlichen Gr√º√üen",
            platzhalter=["empfaenger_name", "dokument_name"],
            fuer_typen=[EingangTyp.DOKUMENT.value],
            ist_system=True
        ),
        AntwortVorlage(
            vorlage_id="sys_bestaetigung_termin",
            name="Termin best√§tigen",
            kategorie="Best√§tigung",
            betreff_template="Terminbest√§tigung: {termin_datum}",
            text_template="Sehr geehrte/r {empfaenger_name},\n\nhiermit best√§tigen wir den Termin am {termin_datum} um {termin_uhrzeit} Uhr.\n\nBitte bringen Sie folgende Unterlagen mit:\n{unterlagen_liste}\n\nMit freundlichen Gr√º√üen",
            platzhalter=["empfaenger_name", "termin_datum", "termin_uhrzeit", "unterlagen_liste"],
            fuer_typen=[EingangTyp.TERMIN.value],
            ist_system=True
        ),
        AntwortVorlage(
            vorlage_id="sys_ablehnung_dokument",
            name="Dokument ablehnen/Nachbesserung",
            kategorie="Ablehnung",
            betreff_template="Nachbesserung erforderlich: {dokument_name}",
            text_template="Sehr geehrte/r {empfaenger_name},\n\nbei der Pr√ºfung des Dokuments \"{dokument_name}\" sind folgende M√§ngel aufgefallen:\n\n{maengel_liste}\n\nBitte reichen Sie das Dokument korrigiert bis zum {frist_datum} ein.\n\nMit freundlichen Gr√º√üen",
            platzhalter=["empfaenger_name", "dokument_name", "maengel_liste", "frist_datum"],
            fuer_typen=[EingangTyp.DOKUMENT.value],
            ist_system=True
        ),
        AntwortVorlage(
            vorlage_id="sys_freigabe_erteilt",
            name="Freigabe erteilen",
            kategorie="Freigabe",
            betreff_template="Freigabe erteilt: {objekt_name}",
            text_template="Sehr geehrte/r {empfaenger_name},\n\nwir freuen uns, Ihnen mitteilen zu k√∂nnen, dass {objekt_name} freigegeben wurde.\n\n{zusatz_info}\n\nMit freundlichen Gr√º√üen",
            platzhalter=["empfaenger_name", "objekt_name", "zusatz_info"],
            fuer_typen=[EingangTyp.FREIGABE.value],
            ist_system=True
        ),
        AntwortVorlage(
            vorlage_id="sys_erinnerung_frist",
            name="Frist-Erinnerung",
            kategorie="Erinnerung",
            betreff_template="Erinnerung: {frist_name} l√§uft am {frist_datum} ab",
            text_template="Sehr geehrte/r {empfaenger_name},\n\nwir m√∂chten Sie daran erinnern, dass die Frist \"{frist_name}\" am {frist_datum} abl√§uft.\n\nBitte beachten Sie:\n{hinweise}\n\nMit freundlichen Gr√º√üen",
            platzhalter=["empfaenger_name", "frist_name", "frist_datum", "hinweise"],
            fuer_typen=[EingangTyp.FRIST.value],
            ist_system=True
        ),
        AntwortVorlage(
            vorlage_id="sys_nachfrage",
            name="R√ºckfrage stellen",
            kategorie="Nachfrage",
            betreff_template="R√ºckfrage zu: {betreff}",
            text_template="Sehr geehrte/r {empfaenger_name},\n\nzu Ihrer Anfrage haben wir folgende R√ºckfragen:\n\n{fragen_liste}\n\nBitte antworten Sie uns bis zum {frist_datum}.\n\nMit freundlichen Gr√º√üen",
            platzhalter=["empfaenger_name", "betreff", "fragen_liste", "frist_datum"],
            fuer_typen=[EingangTyp.NACHRICHT.value, EingangTyp.ANFORDERUNG.value],
            ist_system=True
        ),
    ]

    for vorlage in system_vorlagen:
        if vorlage.vorlage_id not in st.session_state.antwort_vorlagen:
            st.session_state.antwort_vorlagen[vorlage.vorlage_id] = vorlage


def get_eingaenge_zaehler(user_id: str) -> Dict[str, int]:
    """Z√§hlt die ungelesenen Eing√§nge nach Typ"""
    if 'eingaenge' not in st.session_state:
        st.session_state.eingaenge = {}

    zaehler = {
        EingangTyp.NACHRICHT.value: 0,
        EingangTyp.DOKUMENT.value: 0,
        EingangTyp.TERMIN.value: 0,
        EingangTyp.FREIGABE.value: 0,
        EingangTyp.FRIST.value: 0,
        EingangTyp.ANFORDERUNG.value: 0,
        EingangTyp.SYSTEM.value: 0,
        "gesamt": 0
    }

    for eingang in st.session_state.eingaenge.values():
        if eingang.empfaenger_id == user_id and eingang.status == EingangStatus.NEU.value:
            zaehler[eingang.typ] = zaehler.get(eingang.typ, 0) + 1
            zaehler["gesamt"] += 1

    return zaehler


def erstelle_eingang(
    empfaenger_id: str,
    typ: str,
    titel: str,
    beschreibung: str = "",
    absender_id: str = "",
    projekt_id: str = "",
    referenz_id: str = "",
    referenz_typ: str = "",
    prioritaet: str = NachrichtenPrioritaet.NORMAL.value,
    faellig_am: datetime = None
) -> Eingang:
    """Erstellt einen neuen Eingang"""
    eingang_id = f"eingang_{uuid.uuid4().hex[:8]}"

    eingang = Eingang(
        eingang_id=eingang_id,
        empfaenger_id=empfaenger_id,
        typ=typ,
        titel=titel,
        beschreibung=beschreibung,
        absender_id=absender_id,
        projekt_id=projekt_id,
        referenz_id=referenz_id,
        referenz_typ=referenz_typ,
        prioritaet=prioritaet,
        faellig_am=faellig_am
    )

    if 'eingaenge' not in st.session_state:
        st.session_state.eingaenge = {}
    st.session_state.eingaenge[eingang_id] = eingang

    return eingang


def render_benachrichtigungs_badge(user_id: str):
    """Zeigt das Benachrichtigungs-Badge in der Sidebar"""
    zaehler = get_eingaenge_zaehler(user_id)
    gesamt = zaehler["gesamt"]

    # Badge-Farbe basierend auf Anzahl
    if gesamt == 0:
        badge_style = "background-color: #28a745;"  # Gr√ºn
        badge_text = "‚úì"
    elif gesamt < 5:
        badge_style = "background-color: #ffc107; color: #000;"  # Gelb
        badge_text = str(gesamt)
    else:
        badge_style = "background-color: #dc3545;"  # Rot
        badge_text = str(gesamt) if gesamt < 100 else "99+"

    # CSS f√ºr Badge
    st.markdown(f"""
    <style>
    .notification-badge {{
        position: relative;
        display: inline-block;
        padding: 10px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 10px;
        color: white;
        cursor: pointer;
        margin-bottom: 10px;
        width: 100%;
        text-align: center;
    }}
    .notification-badge:hover {{
        transform: scale(1.02);
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }}
    .badge-count {{
        position: absolute;
        top: -8px;
        right: -8px;
        {badge_style}
        color: white;
        border-radius: 50%;
        padding: 4px 8px;
        font-size: 12px;
        font-weight: bold;
        min-width: 20px;
        text-align: center;
    }}
    .notification-types {{
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-top: 5px;
        font-size: 11px;
    }}
    .notification-type {{
        background: rgba(255,255,255,0.2);
        padding: 2px 6px;
        border-radius: 4px;
    }}
    </style>
    """, unsafe_allow_html=True)

    # Eing√§nge-Button in Sidebar
    with st.sidebar:
        st.markdown("---")

        if st.button(f"üì¨ Eing√§nge ({gesamt})", key="open_eingaenge", use_container_width=True, type="primary" if gesamt > 0 else "secondary"):
            st.session_state.show_eingaenge_center = True
            st.rerun()

        # Mini-√úbersicht
        if gesamt > 0:
            cols = st.columns(4)
            typ_icons = {
                EingangTyp.NACHRICHT.value: "‚úâÔ∏è",
                EingangTyp.DOKUMENT.value: "üìÑ",
                EingangTyp.TERMIN.value: "üìÖ",
                EingangTyp.FRIST.value: "‚è∞"
            }
            col_idx = 0
            for typ, icon in typ_icons.items():
                if zaehler.get(typ, 0) > 0:
                    with cols[col_idx % 4]:
                        st.caption(f"{icon} {zaehler[typ]}")
                    col_idx += 1


def render_eingaenge_center(user_id: str):
    """Zeigt das vollst√§ndige Eing√§nge-Center als Modal/Overlay"""
    if not st.session_state.get('show_eingaenge_center', False):
        return

    st.markdown("---")
    col1, col2 = st.columns([6, 1])
    with col1:
        st.subheader("üì¨ Eing√§nge-Center")
    with col2:
        if st.button("‚úñÔ∏è Schlie√üen", key="close_eingaenge"):
            st.session_state.show_eingaenge_center = False
            st.rerun()

    # Tabs f√ºr verschiedene Ansichten
    tabs = st.tabs([
        "üì• Alle Eing√§nge",
        "‚úâÔ∏è Nachrichten",
        "üìÑ Dokumente",
        "üìÖ Termine",
        "‚è∞ Fristen",
        "‚úÖ Freigaben",
        "üìã Erledigt"
    ])

    eingaenge = list(st.session_state.get('eingaenge', {}).values())
    user_eingaenge = [e for e in eingaenge if e.empfaenger_id == user_id]

    with tabs[0]:
        _render_eingaenge_liste(user_eingaenge, "alle")

    with tabs[1]:
        nachrichten = [e for e in user_eingaenge if e.typ == EingangTyp.NACHRICHT.value]
        _render_eingaenge_liste(nachrichten, "nachrichten")

    with tabs[2]:
        dokumente = [e for e in user_eingaenge if e.typ == EingangTyp.DOKUMENT.value]
        _render_eingaenge_liste(dokumente, "dokumente")

    with tabs[3]:
        termine = [e for e in user_eingaenge if e.typ == EingangTyp.TERMIN.value]
        _render_eingaenge_liste(termine, "termine")

    with tabs[4]:
        fristen = [e for e in user_eingaenge if e.typ == EingangTyp.FRIST.value]
        _render_eingaenge_liste(fristen, "fristen")

    with tabs[5]:
        freigaben = [e for e in user_eingaenge if e.typ == EingangTyp.FREIGABE.value]
        _render_eingaenge_liste(freigaben, "freigaben")

    with tabs[6]:
        erledigte = [e for e in user_eingaenge if e.status in [EingangStatus.ERLEDIGT.value, EingangStatus.ARCHIVIERT.value]]
        _render_eingaenge_liste(erledigte, "erledigt")


def _render_eingaenge_liste(eingaenge: List, kontext: str):
    """Rendert eine Liste von Eing√§ngen"""
    # Sortierung
    sort_option = st.selectbox(
        "Sortieren nach",
        ["Neueste zuerst", "√Ñlteste zuerst", "Priorit√§t", "F√§lligkeit"],
        key=f"sort_{kontext}"
    )

    if sort_option == "Neueste zuerst":
        eingaenge.sort(key=lambda e: e.erstellt_am, reverse=True)
    elif sort_option == "√Ñlteste zuerst":
        eingaenge.sort(key=lambda e: e.erstellt_am)
    elif sort_option == "Priorit√§t":
        prio_order = {NachrichtenPrioritaet.DRINGEND.value: 0, NachrichtenPrioritaet.HOCH.value: 1, NachrichtenPrioritaet.NORMAL.value: 2}
        eingaenge.sort(key=lambda e: prio_order.get(e.prioritaet, 2))
    elif sort_option == "F√§lligkeit":
        eingaenge.sort(key=lambda e: e.faellig_am or datetime.max)

    # Nur neue filtern (au√üer bei erledigt)
    if kontext != "erledigt":
        nur_neue = st.checkbox("Nur ungelesene", value=True, key=f"nur_neue_{kontext}")
        if nur_neue:
            eingaenge = [e for e in eingaenge if e.status == EingangStatus.NEU.value]

    if not eingaenge:
        st.info("Keine Eing√§nge vorhanden.")
        return

    st.caption(f"{len(eingaenge)} Eingang/Eing√§nge")

    for eingang in eingaenge:
        _render_eingang_card(eingang)


def _render_eingang_card(eingang: Eingang):
    """Rendert eine einzelne Eingangs-Karte"""
    # Status-Icons
    status_icons = {
        EingangStatus.NEU.value: "üîµ",
        EingangStatus.GELESEN.value: "‚ö™",
        EingangStatus.BEARBEITET.value: "üü°",
        EingangStatus.ERLEDIGT.value: "üü¢",
        EingangStatus.ARCHIVIERT.value: "üìÅ"
    }

    # Typ-Icons
    typ_icons = {
        EingangTyp.NACHRICHT.value: "‚úâÔ∏è",
        EingangTyp.DOKUMENT.value: "üìÑ",
        EingangTyp.TERMIN.value: "üìÖ",
        EingangTyp.FREIGABE.value: "‚úÖ",
        EingangTyp.FRIST.value: "‚è∞",
        EingangTyp.ANFORDERUNG.value: "üìã",
        EingangTyp.SYSTEM.value: "üîî"
    }

    # Priorit√§ts-Farben
    prio_colors = {
        NachrichtenPrioritaet.DRINGEND.value: "#dc3545",
        NachrichtenPrioritaet.HOCH.value: "#fd7e14",
        NachrichtenPrioritaet.NORMAL.value: "#6c757d"
    }

    status_icon = status_icons.get(eingang.status, "‚ö™")
    typ_icon = typ_icons.get(eingang.typ, "üì®")
    prio_color = prio_colors.get(eingang.prioritaet, "#6c757d")

    # Absender-Name holen
    absender_name = "System"
    if eingang.absender_id and eingang.absender_id in st.session_state.get('users', {}):
        absender_name = st.session_state.users[eingang.absender_id].name

    # Projekt-Name holen
    projekt_name = ""
    if eingang.projekt_id and eingang.projekt_id in st.session_state.get('projekte', {}):
        projekt_name = st.session_state.projekte[eingang.projekt_id].name

    with st.expander(f"{status_icon} {typ_icon} **{eingang.titel}**", expanded=eingang.status == EingangStatus.NEU.value):
        col1, col2 = st.columns([3, 1])

        with col1:
            st.markdown(f"**Von:** {absender_name}")
            if projekt_name:
                st.markdown(f"**Projekt:** {projekt_name}")
            st.markdown(f"**Datum:** {eingang.erstellt_am.strftime('%d.%m.%Y %H:%M')}")
            if eingang.faellig_am:
                tage_bis = (eingang.faellig_am - datetime.now()).days
                if tage_bis < 0:
                    st.error(f"‚ö†Ô∏è √úberf√§llig seit {abs(tage_bis)} Tagen!")
                elif tage_bis == 0:
                    st.warning("‚è∞ Heute f√§llig!")
                elif tage_bis <= 3:
                    st.warning(f"‚è∞ F√§llig in {tage_bis} Tagen")
                else:
                    st.caption(f"F√§llig am: {eingang.faellig_am.strftime('%d.%m.%Y')}")

            if eingang.beschreibung:
                st.markdown("---")
                st.markdown(eingang.beschreibung)

        with col2:
            st.markdown(f"<span style='color: {prio_color}; font-weight: bold;'>{eingang.prioritaet}</span>", unsafe_allow_html=True)
            st.caption(f"Status: {eingang.status}")

        # Aktionen
        st.markdown("---")
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            if eingang.status == EingangStatus.NEU.value:
                if st.button("üëÅÔ∏è Gelesen", key=f"read_{eingang.eingang_id}"):
                    eingang.status = EingangStatus.GELESEN.value
                    eingang.gelesen_am = datetime.now()
                    st.rerun()

        with col2:
            if st.button("üí¨ Antworten", key=f"reply_{eingang.eingang_id}"):
                st.session_state[f'reply_to_{eingang.eingang_id}'] = True
                st.rerun()

        with col3:
            if eingang.status not in [EingangStatus.ERLEDIGT.value, EingangStatus.ARCHIVIERT.value]:
                if st.button("‚úÖ Erledigt", key=f"done_{eingang.eingang_id}"):
                    eingang.status = EingangStatus.ERLEDIGT.value
                    eingang.bearbeitet_am = datetime.now()
                    st.rerun()

        with col4:
            if st.button("üìÅ Archiv", key=f"archive_{eingang.eingang_id}"):
                eingang.status = EingangStatus.ARCHIVIERT.value
                st.rerun()

        # Antwort-Formular
        if st.session_state.get(f'reply_to_{eingang.eingang_id}', False):
            _render_antwort_formular(eingang)


def _render_antwort_formular(eingang: Eingang):
    """Rendert das Antwort-Formular mit Vorlagen"""
    st.markdown("### üí¨ Antwort verfassen")

    # Vorlagen filtern nach Typ
    vorlagen = [v for v in st.session_state.get('antwort_vorlagen', {}).values()
                if eingang.typ in v.fuer_typen or not v.fuer_typen]

    vorlage_options = ["-- Keine Vorlage --"] + [v.name for v in vorlagen]
    selected_vorlage = st.selectbox("Vorlage verwenden", vorlage_options, key=f"vorlage_{eingang.eingang_id}")

    # Betreff und Text vorbelegen
    betreff = f"Re: {eingang.titel}"
    text = ""

    if selected_vorlage != "-- Keine Vorlage --":
        vorlage = next((v for v in vorlagen if v.name == selected_vorlage), None)
        if vorlage:
            betreff = vorlage.betreff_template
            text = vorlage.text_template

            # Platzhalter ersetzen (wo m√∂glich)
            absender = st.session_state.get('users', {}).get(eingang.absender_id)
            if absender:
                betreff = betreff.replace("{empfaenger_name}", absender.name)
                text = text.replace("{empfaenger_name}", absender.name)

    with st.form(key=f"reply_form_{eingang.eingang_id}"):
        antwort_betreff = st.text_input("Betreff", value=betreff)
        antwort_text = st.text_area("Nachricht", value=text, height=200)

        col1, col2 = st.columns(2)
        with col1:
            if st.form_submit_button("üì§ Senden", type="primary"):
                if eingang.absender_id:
                    # Neue Nachricht erstellen
                    erstelle_eingang(
                        empfaenger_id=eingang.absender_id,
                        typ=EingangTyp.NACHRICHT.value,
                        titel=antwort_betreff,
                        beschreibung=antwort_text,
                        absender_id=st.session_state.current_user.user_id,
                        projekt_id=eingang.projekt_id,
                        referenz_id=eingang.eingang_id,
                        referenz_typ="antwort"
                    )
                    eingang.status = EingangStatus.BEARBEITET.value
                    eingang.bearbeitet_am = datetime.now()
                    st.session_state[f'reply_to_{eingang.eingang_id}'] = False
                    st.success("‚úÖ Antwort gesendet!")
                    st.rerun()

        with col2:
            if st.form_submit_button("‚ùå Abbrechen"):
                st.session_state[f'reply_to_{eingang.eingang_id}'] = False
                st.rerun()


# ============================================================================
# FINANZIERUNGS- UND LEGAL-GATING
# ============================================================================

def erstelle_standard_gating_pruefungen(projekt_id: str):
    """Erstellt die Standard-Gating-Pr√ºfungen f√ºr ein Projekt"""
    if 'gating_pruefungen' not in st.session_state:
        st.session_state.gating_pruefungen = {}

    projekt = st.session_state.get('projekte', {}).get(projekt_id)
    if not projekt:
        return

    # Standard-Pr√ºfungen definieren
    pruefungen = [
        # Legal-Gating f√ºr K√§ufer
        {
            "typ": "legal",
            "bezeichnung": "K√§ufer: Widerrufsbelehrung akzeptiert",
            "user_rolle": "kaeufer",
            "reihenfolge": 1,
            "erforderlich": True
        },
        {
            "typ": "legal",
            "bezeichnung": "K√§ufer: Verbraucherschutzbelehrung akzeptiert",
            "user_rolle": "kaeufer",
            "reihenfolge": 2,
            "erforderlich": True
        },
        {
            "typ": "legal",
            "bezeichnung": "K√§ufer: Geldw√§schegesetz-Belehrung akzeptiert",
            "user_rolle": "kaeufer",
            "reihenfolge": 3,
            "erforderlich": True
        },
        {
            "typ": "dokument",
            "bezeichnung": "K√§ufer: Legitimation vollst√§ndig",
            "user_rolle": "kaeufer",
            "reihenfolge": 4,
            "erforderlich": True
        },
        # Legal-Gating f√ºr Verk√§ufer
        {
            "typ": "legal",
            "bezeichnung": "Verk√§ufer: Geldw√§schegesetz-Belehrung akzeptiert",
            "user_rolle": "verkaeufer",
            "reihenfolge": 5,
            "erforderlich": True
        },
        {
            "typ": "dokument",
            "bezeichnung": "Verk√§ufer: Legitimation vollst√§ndig",
            "user_rolle": "verkaeufer",
            "reihenfolge": 6,
            "erforderlich": True
        },
        # Finanzierungs-Gating (erst nach Legal m√∂glich)
        {
            "typ": "finanzierung",
            "bezeichnung": "Finanzierungsbest√§tigung der Bank",
            "user_rolle": "finanzierer",
            "reihenfolge": 10,
            "erforderlich": True,
            "vorgaenger": [1, 2, 3, 4]  # Alle K√§ufer-Legal-Pr√ºfungen
        },
        {
            "typ": "finanzierung",
            "bezeichnung": "Kaufpreisfinanzierung gesichert",
            "user_rolle": "kaeufer",
            "reihenfolge": 11,
            "erforderlich": True,
            "vorgaenger": [10]
        },
    ]

    # User-IDs zuordnen
    user_ids = {
        "kaeufer": projekt.kaeufer_id,
        "verkaeufer": projekt.verkaeufer_id,
        "finanzierer": projekt.finanzierer_id,
        "notar": projekt.notar_id,
        "makler": projekt.makler_id
    }

    created_pruefungen = {}

    for idx, p in enumerate(pruefungen):
        user_id = user_ids.get(p["user_rolle"], "")
        if not user_id:
            continue

        pruefung_id = f"gating_{projekt_id}_{idx}"

        vorgaenger_ids = []
        if "vorgaenger" in p:
            for v_idx in p["vorgaenger"]:
                v_id = f"gating_{projekt_id}_{v_idx - 1}"
                if v_id in created_pruefungen:
                    vorgaenger_ids.append(v_id)

        pruefung = GatingPruefung(
            pruefung_id=pruefung_id,
            projekt_id=projekt_id,
            user_id=user_id,
            typ=p["typ"],
            bezeichnung=p["bezeichnung"],
            reihenfolge=p["reihenfolge"],
            vorgaenger_ids=vorgaenger_ids,
            erforderlich=p["erforderlich"]
        )

        # Status auf "wartet" setzen wenn Vorg√§nger existieren
        if vorgaenger_ids:
            pruefung.status = GatingStatus.WARTET.value

        st.session_state.gating_pruefungen[pruefung_id] = pruefung
        created_pruefungen[pruefung_id] = pruefung


def get_gating_status(projekt_id: str) -> Dict:
    """Ermittelt den Gating-Status f√ºr ein Projekt"""
    pruefungen = [p for p in st.session_state.get('gating_pruefungen', {}).values()
                  if p.projekt_id == projekt_id]

    if not pruefungen:
        return {
            "legal_status": "nicht_konfiguriert",
            "finanzierung_status": "nicht_konfiguriert",
            "fortschritt": 0,
            "naechste_schritte": [],
            "blockiert": False
        }

    legal_pruefungen = [p for p in pruefungen if p.typ == "legal"]
    finanz_pruefungen = [p for p in pruefungen if p.typ == "finanzierung"]

    legal_freigegeben = all(p.status == GatingStatus.FREIGEGEBEN.value for p in legal_pruefungen if p.erforderlich)
    finanz_freigegeben = all(p.status == GatingStatus.FREIGEGEBEN.value for p in finanz_pruefungen if p.erforderlich)

    gesamt = len([p for p in pruefungen if p.erforderlich])
    erledigt = len([p for p in pruefungen if p.erforderlich and p.status == GatingStatus.FREIGEGEBEN.value])
    fortschritt = (erledigt / gesamt * 100) if gesamt > 0 else 0

    # N√§chste Schritte ermitteln
    naechste_schritte = []
    for p in pruefungen:
        if p.status in [GatingStatus.OFFEN.value, GatingStatus.IN_PRUEFUNG.value]:
            # Pr√ºfen ob Vorg√§nger erledigt
            vorgaenger_erledigt = all(
                st.session_state.gating_pruefungen.get(v_id, GatingPruefung("", "", "", "", "")).status == GatingStatus.FREIGEGEBEN.value
                for v_id in p.vorgaenger_ids
            )
            if vorgaenger_erledigt:
                naechste_schritte.append(p)

    return {
        "legal_status": "freigegeben" if legal_freigegeben else "offen",
        "finanzierung_status": "freigegeben" if finanz_freigegeben else ("blockiert" if not legal_freigegeben else "offen"),
        "fortschritt": fortschritt,
        "naechste_schritte": naechste_schritte,
        "blockiert": not legal_freigegeben and any(p.typ == "finanzierung" and p.status == GatingStatus.WARTET.value for p in pruefungen)
    }


def render_gating_uebersicht(projekt_id: str, user_rolle: str):
    """Zeigt die Gating-√úbersicht f√ºr ein Projekt"""
    st.subheader("üîê Freigabe-Status")

    status = get_gating_status(projekt_id)

    # Fortschrittsanzeige
    col1, col2, col3 = st.columns(3)

    with col1:
        if status["legal_status"] == "freigegeben":
            st.success("‚úÖ Legal-Pr√ºfung abgeschlossen")
        else:
            st.warning("‚è≥ Legal-Pr√ºfung ausstehend")

    with col2:
        if status["finanzierung_status"] == "freigegeben":
            st.success("‚úÖ Finanzierung gesichert")
        elif status["finanzierung_status"] == "blockiert":
            st.error("üîí Finanzierung blockiert (Legal-Pr√ºfung erforderlich)")
        else:
            st.warning("‚è≥ Finanzierung ausstehend")

    with col3:
        st.metric("Fortschritt", f"{status['fortschritt']:.0f}%")

    st.progress(status['fortschritt'] / 100)

    # Detaillierte Pr√ºfungen
    st.markdown("### üìã Pr√ºfungen im Detail")

    pruefungen = [p for p in st.session_state.get('gating_pruefungen', {}).values()
                  if p.projekt_id == projekt_id]
    pruefungen.sort(key=lambda p: p.reihenfolge)

    for pruefung in pruefungen:
        _render_gating_pruefung(pruefung, user_rolle)

    # N√§chste Schritte
    if status["naechste_schritte"]:
        st.markdown("### ‚è≠Ô∏è N√§chste Schritte")
        for schritt in status["naechste_schritte"]:
            user = st.session_state.get('users', {}).get(schritt.user_id)
            user_name = user.name if user else "Unbekannt"
            st.info(f"**{schritt.bezeichnung}** - Verantwortlich: {user_name}")


def _render_gating_pruefung(pruefung: GatingPruefung, user_rolle: str):
    """Rendert eine einzelne Gating-Pr√ºfung"""
    status_icons = {
        GatingStatus.OFFEN.value: "‚ö™",
        GatingStatus.IN_PRUEFUNG.value: "üîµ",
        GatingStatus.FREIGEGEBEN.value: "üü¢",
        GatingStatus.ABGELEHNT.value: "üî¥",
        GatingStatus.WARTET.value: "‚è∏Ô∏è"
    }

    typ_icons = {
        "legal": "‚öñÔ∏è",
        "finanzierung": "üí∞",
        "dokument": "üìÑ"
    }

    icon = status_icons.get(pruefung.status, "‚ö™")
    typ_icon = typ_icons.get(pruefung.typ, "üìã")

    user = st.session_state.get('users', {}).get(pruefung.user_id)
    user_name = user.name if user else "Unbekannt"

    with st.expander(f"{icon} {typ_icon} {pruefung.bezeichnung}"):
        col1, col2 = st.columns([3, 1])

        with col1:
            st.markdown(f"**Verantwortlich:** {user_name}")
            st.markdown(f"**Status:** {pruefung.status}")
            if pruefung.geprueft_am:
                st.markdown(f"**Gepr√ºft am:** {pruefung.geprueft_am.strftime('%d.%m.%Y %H:%M')}")
            if pruefung.kommentar:
                st.markdown(f"**Kommentar:** {pruefung.kommentar}")

        with col2:
            # Aktionen nur f√ºr berechtigte User
            current_user = st.session_state.current_user
            kann_bearbeiten = (
                current_user.user_id == pruefung.user_id or
                user_rolle in ["notar", "admin"]
            )

            if kann_bearbeiten and pruefung.status in [GatingStatus.OFFEN.value, GatingStatus.IN_PRUEFUNG.value]:
                if st.button("‚úÖ Freigeben", key=f"approve_{pruefung.pruefung_id}"):
                    pruefung.status = GatingStatus.FREIGEGEBEN.value
                    pruefung.geprueft_von = current_user.user_id
                    pruefung.geprueft_am = datetime.now()
                    _aktualisiere_abhaengige_pruefungen(pruefung.pruefung_id)
                    st.success("Freigabe erteilt!")
                    st.rerun()

                if st.button("‚ùå Ablehnen", key=f"reject_{pruefung.pruefung_id}"):
                    pruefung.status = GatingStatus.ABGELEHNT.value
                    pruefung.geprueft_von = current_user.user_id
                    pruefung.geprueft_am = datetime.now()
                    st.rerun()


def _aktualisiere_abhaengige_pruefungen(pruefung_id: str):
    """Aktualisiert abh√§ngige Pr√ºfungen wenn eine Pr√ºfung freigegeben wurde"""
    for pruefung in st.session_state.get('gating_pruefungen', {}).values():
        if pruefung_id in pruefung.vorgaenger_ids:
            # Pr√ºfen ob alle Vorg√§nger erledigt
            alle_vorgaenger_erledigt = all(
                st.session_state.gating_pruefungen.get(v_id, GatingPruefung("", "", "", "", "")).status == GatingStatus.FREIGEGEBEN.value
                for v_id in pruefung.vorgaenger_ids
            )
            if alle_vorgaenger_erledigt and pruefung.status == GatingStatus.WARTET.value:
                pruefung.status = GatingStatus.OFFEN.value


# ============================================================================
# FRISTENMANAGEMENT
# ============================================================================

def erstelle_standard_fristen(projekt_id: str, beurkundungsdatum: datetime = None):
    """Erstellt Standard-Fristen f√ºr ein Projekt"""
    if 'fristen' not in st.session_state:
        st.session_state.fristen = {}

    projekt = st.session_state.get('projekte', {}).get(projekt_id)
    if not projekt:
        return

    # Basis-Datum ist entweder Beurkundungsdatum oder heute
    basis = beurkundungsdatum or datetime.now()

    standard_fristen = [
        {
            "typ": FristTyp.WIDERRUFSFRIST.value,
            "bezeichnung": "Widerrufsfrist K√§ufer",
            "tage_offset": 14,
            "verantwortlich": projekt.kaeufer_id,
            "erinnerung_tage": 3
        },
        {
            "typ": FristTyp.KAUFPREISZAHLUNG.value,
            "bezeichnung": "Kaufpreiszahlung",
            "tage_offset": 30,
            "verantwortlich": projekt.kaeufer_id,
            "erinnerung_tage": 7
        },
        {
            "typ": FristTyp.GRUNDBUCHEINTRAGUNG.value,
            "bezeichnung": "Auflassungsvormerkung eintragen",
            "tage_offset": 7,
            "verantwortlich": projekt.notar_id,
            "erinnerung_tage": 2
        },
        {
            "typ": FristTyp.UEBERGABE.value,
            "bezeichnung": "Objekt√ºbergabe",
            "tage_offset": 60,
            "verantwortlich": projekt.makler_id,
            "erinnerung_tage": 14
        }
    ]

    for idx, f in enumerate(standard_fristen):
        if not f["verantwortlich"]:
            continue

        frist_id = f"frist_{projekt_id}_{idx}"

        frist = Frist(
            frist_id=frist_id,
            projekt_id=projekt_id,
            typ=f["typ"],
            bezeichnung=f["bezeichnung"],
            faellig_am=basis + timedelta(days=f["tage_offset"]),
            verantwortlich_id=f["verantwortlich"],
            erinnerung_tage=f["erinnerung_tage"],
            automatisch_berechnet=True,
            basis_datum=basis,
            tage_offset=f["tage_offset"]
        )

        st.session_state.fristen[frist_id] = frist


def get_faellige_fristen(user_id: str = None, projekt_id: str = None, tage_voraus: int = 7) -> List[Frist]:
    """Ermittelt f√§llige Fristen"""
    fristen = list(st.session_state.get('fristen', {}).values())

    if user_id:
        fristen = [f for f in fristen if f.verantwortlich_id == user_id]
    if projekt_id:
        fristen = [f for f in fristen if f.projekt_id == projekt_id]

    # Nur offene Fristen
    fristen = [f for f in fristen if f.status == "offen"]

    # F√§llige oder bald f√§llige
    jetzt = datetime.now()
    grenze = jetzt + timedelta(days=tage_voraus)

    faellige = [f for f in fristen if f.faellig_am and f.faellig_am <= grenze]
    faellige.sort(key=lambda f: f.faellig_am)

    return faellige


def render_fristenmanagement(projekt_id: str = None, user_id: str = None):
    """Rendert die Fristenverwaltung"""
    st.subheader("‚è∞ Fristenmanagement")

    tabs = st.tabs(["üìã √úbersicht", "‚ûï Neue Frist", "üìä Kalender"])

    with tabs[0]:
        # Filter
        col1, col2 = st.columns(2)
        with col1:
            tage_filter = st.selectbox("Zeitraum", ["7 Tage", "14 Tage", "30 Tage", "Alle"], key="frist_zeitraum")
            tage = {"7 Tage": 7, "14 Tage": 14, "30 Tage": 30, "Alle": 365}.get(tage_filter, 7)

        with col2:
            status_filter = st.selectbox("Status", ["Alle", "Offen", "√úberf√§llig", "Erledigt"], key="frist_status")

        fristen = list(st.session_state.get('fristen', {}).values())
        if projekt_id:
            fristen = [f for f in fristen if f.projekt_id == projekt_id]
        if user_id:
            fristen = [f for f in fristen if f.verantwortlich_id == user_id]

        # Status-Filter anwenden
        jetzt = datetime.now()
        if status_filter == "Offen":
            fristen = [f for f in fristen if f.status == "offen"]
        elif status_filter == "√úberf√§llig":
            fristen = [f for f in fristen if f.status == "offen" and f.faellig_am and f.faellig_am < jetzt]
        elif status_filter == "Erledigt":
            fristen = [f for f in fristen if f.status == "erledigt"]

        # Zeitfilter
        if tage_filter != "Alle":
            grenze = jetzt + timedelta(days=tage)
            fristen = [f for f in fristen if not f.faellig_am or f.faellig_am <= grenze]

        fristen.sort(key=lambda f: f.faellig_am or datetime.max)

        if not fristen:
            st.info("Keine Fristen im ausgew√§hlten Zeitraum.")
        else:
            for frist in fristen:
                _render_frist_card(frist)

    with tabs[1]:
        _render_neue_frist_formular(projekt_id)

    with tabs[2]:
        _render_fristen_kalender(projekt_id, user_id)


def _render_frist_card(frist: Frist):
    """Rendert eine Frist-Karte"""
    jetzt = datetime.now()

    if frist.status == "erledigt":
        status_color = "üü¢"
        bg_color = "#d4edda"
    elif frist.faellig_am and frist.faellig_am < jetzt:
        status_color = "üî¥"
        bg_color = "#f8d7da"
    elif frist.faellig_am and (frist.faellig_am - jetzt).days <= frist.erinnerung_tage:
        status_color = "üü°"
        bg_color = "#fff3cd"
    else:
        status_color = "‚ö™"
        bg_color = "#f8f9fa"

    verantwortlich = st.session_state.get('users', {}).get(frist.verantwortlich_id)
    verantwortlich_name = verantwortlich.name if verantwortlich else "Unbekannt"

    projekt = st.session_state.get('projekte', {}).get(frist.projekt_id)
    projekt_name = projekt.name if projekt else ""

    with st.container():
        col1, col2, col3 = st.columns([3, 2, 1])

        with col1:
            st.markdown(f"{status_color} **{frist.bezeichnung}**")
            if projekt_name:
                st.caption(f"Projekt: {projekt_name}")

        with col2:
            if frist.faellig_am:
                tage_bis = (frist.faellig_am - jetzt).days
                if tage_bis < 0:
                    st.error(f"‚ö†Ô∏è √úberf√§llig: {frist.faellig_am.strftime('%d.%m.%Y')}")
                elif tage_bis == 0:
                    st.warning(f"‚è∞ Heute f√§llig!")
                else:
                    st.info(f"üìÖ {frist.faellig_am.strftime('%d.%m.%Y')} ({tage_bis} Tage)")
            st.caption(f"Verantwortlich: {verantwortlich_name}")

        with col3:
            if frist.status == "offen":
                if st.button("‚úÖ", key=f"done_frist_{frist.frist_id}", help="Als erledigt markieren"):
                    frist.status = "erledigt"
                    frist.erledigt_am = datetime.now()
                    st.rerun()


def _render_neue_frist_formular(projekt_id: str = None):
    """Formular f√ºr neue Frist"""
    st.markdown("### ‚ûï Neue Frist erstellen")

    with st.form("neue_frist_form"):
        # Projekt ausw√§hlen wenn nicht vorgegeben
        if not projekt_id:
            projekte = list(st.session_state.get('projekte', {}).values())
            projekt_options = {p.name: p.projekt_id for p in projekte}
            selected_projekt = st.selectbox("Projekt", list(projekt_options.keys()))
            projekt_id = projekt_options.get(selected_projekt)

        bezeichnung = st.text_input("Bezeichnung *")

        col1, col2 = st.columns(2)
        with col1:
            typ = st.selectbox("Fristtyp", [f.value for f in FristTyp])
            faellig_am = st.date_input("F√§llig am *")

        with col2:
            erinnerung_tage = st.number_input("Erinnerung (Tage vorher)", min_value=0, max_value=30, value=3)

            # Verantwortlichen ausw√§hlen
            users = list(st.session_state.get('users', {}).values())
            user_options = {u.name: u.user_id for u in users}
            selected_user = st.selectbox("Verantwortlich *", list(user_options.keys()))

        notizen = st.text_area("Notizen")

        if st.form_submit_button("üíæ Frist erstellen", type="primary"):
            if bezeichnung and faellig_am and selected_user:
                frist_id = f"frist_{uuid.uuid4().hex[:8]}"
                frist = Frist(
                    frist_id=frist_id,
                    projekt_id=projekt_id or "",
                    typ=typ,
                    bezeichnung=bezeichnung,
                    faellig_am=datetime.combine(faellig_am, datetime.min.time()),
                    verantwortlich_id=user_options[selected_user],
                    erinnerung_tage=erinnerung_tage,
                    notizen=notizen
                )

                if 'fristen' not in st.session_state:
                    st.session_state.fristen = {}
                st.session_state.fristen[frist_id] = frist

                st.success("‚úÖ Frist erstellt!")
                st.rerun()
            else:
                st.error("Bitte alle Pflichtfelder ausf√ºllen!")


def _render_fristen_kalender(projekt_id: str = None, user_id: str = None):
    """Zeigt Fristen im Kalenderformat"""
    st.markdown("### üìÖ Fristen-Kalender")

    fristen = list(st.session_state.get('fristen', {}).values())
    if projekt_id:
        fristen = [f for f in fristen if f.projekt_id == projekt_id]
    if user_id:
        fristen = [f for f in fristen if f.verantwortlich_id == user_id]

    fristen = [f for f in fristen if f.status == "offen" and f.faellig_am]

    if not fristen:
        st.info("Keine anstehenden Fristen.")
        return

    # Nach Wochen gruppieren
    jetzt = datetime.now()
    wochen = {}

    for frist in fristen:
        kw = frist.faellig_am.isocalendar()[1]
        jahr = frist.faellig_am.year
        key = f"{jahr}-KW{kw:02d}"
        if key not in wochen:
            wochen[key] = []
        wochen[key].append(frist)

    for woche, woche_fristen in sorted(wochen.items()):
        with st.expander(f"üìÖ {woche} ({len(woche_fristen)} Fristen)", expanded=True):
            for frist in sorted(woche_fristen, key=lambda f: f.faellig_am):
                tage_bis = (frist.faellig_am - jetzt).days
                status = "üî¥" if tage_bis < 0 else ("üü°" if tage_bis <= 3 else "‚ö™")
                st.markdown(f"{status} **{frist.faellig_am.strftime('%d.%m.')}** - {frist.bezeichnung}")


# ============================================================================
# REPORTING & KPIs
# ============================================================================

def berechne_kpis(user_id: str) -> Dict:
    """Berechnet die KPIs f√ºr einen Benutzer"""
    user = st.session_state.get('users', {}).get(user_id)
    if not user:
        return {}

    projekte = list(st.session_state.get('projekte', {}).values())

    # Projekte nach Rolle filtern
    if user.rolle == UserRole.MAKLER.value:
        user_projekte = [p for p in projekte if p.makler_id == user_id]
    elif user.rolle == UserRole.NOTAR.value:
        user_projekte = [p for p in projekte if p.notar_id == user_id]
    else:
        user_projekte = [p for p in projekte if user_id in [p.kaeufer_id, p.verkaeufer_id]]

    # Projekt-KPIs
    projekte_gesamt = len(user_projekte)
    projekte_aktiv = len([p for p in user_projekte if p.status not in ["Abgeschlossen", "Storniert"]])
    projekte_abgeschlossen = len([p for p in user_projekte if p.status == "Abgeschlossen"])

    # Durchschnittliche Dauer berechnen
    dauern = []
    for p in user_projekte:
        if p.status == "Abgeschlossen" and hasattr(p, 'erstellt_am') and hasattr(p, 'abgeschlossen_am'):
            if p.abgeschlossen_am and p.erstellt_am:
                dauer = (p.abgeschlossen_am - p.erstellt_am).days
                dauern.append(dauer)
    durchschnittliche_dauer = sum(dauern) / len(dauern) if dauern else 0

    # Umsatz-KPIs (f√ºr Makler)
    umsatz_monat = 0
    umsatz_jahr = 0
    provision_offen = 0

    if user.rolle == UserRole.MAKLER.value:
        jetzt = datetime.now()
        for p in user_projekte:
            if p.status == "Abgeschlossen" and p.kaufpreis:
                provision = p.kaufpreis * 0.0357  # 3.57% Provision
                if hasattr(p, 'abgeschlossen_am') and p.abgeschlossen_am:
                    if p.abgeschlossen_am.year == jetzt.year:
                        umsatz_jahr += provision
                        if p.abgeschlossen_am.month == jetzt.month:
                            umsatz_monat += provision
            elif p.status not in ["Storniert"] and p.kaufpreis:
                provision_offen += p.kaufpreis * 0.0357

    return {
        "projekte_gesamt": projekte_gesamt,
        "projekte_aktiv": projekte_aktiv,
        "projekte_abgeschlossen": projekte_abgeschlossen,
        "durchschnittliche_dauer_tage": durchschnittliche_dauer,
        "umsatz_monat": umsatz_monat,
        "umsatz_jahr": umsatz_jahr,
        "provision_offen": provision_offen
    }


def render_reporting_dashboard(user_id: str):
    """Zeigt das Reporting-Dashboard"""
    st.subheader("üìä Reporting & Statistiken")

    kpis = berechne_kpis(user_id)
    user = st.session_state.get('users', {}).get(user_id)

    # KPI-Karten
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("Projekte gesamt", kpis.get("projekte_gesamt", 0))
    with col2:
        st.metric("Aktive Projekte", kpis.get("projekte_aktiv", 0))
    with col3:
        st.metric("Abgeschlossen", kpis.get("projekte_abgeschlossen", 0))
    with col4:
        st.metric("√ò Dauer (Tage)", f"{kpis.get('durchschnittliche_dauer_tage', 0):.0f}")

    # Umsatz-KPIs f√ºr Makler
    if user and user.rolle == UserRole.MAKLER.value:
        st.markdown("---")
        st.markdown("### üí∞ Umsatz-√úbersicht")

        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Umsatz Monat", f"{kpis.get('umsatz_monat', 0):,.2f} ‚Ç¨")
        with col2:
            st.metric("Umsatz Jahr", f"{kpis.get('umsatz_jahr', 0):,.2f} ‚Ç¨")
        with col3:
            st.metric("Provision offen", f"{kpis.get('provision_offen', 0):,.2f} ‚Ç¨")

    # Diagramme
    st.markdown("---")
    st.markdown("### üìà Projekt-Entwicklung")

    # Projekt-Status-Verteilung
    projekte = list(st.session_state.get('projekte', {}).values())
    if user.rolle == UserRole.MAKLER.value:
        projekte = [p for p in projekte if p.makler_id == user_id]
    elif user.rolle == UserRole.NOTAR.value:
        projekte = [p for p in projekte if p.notar_id == user_id]

    status_counts = {}
    for p in projekte:
        status_counts[p.status] = status_counts.get(p.status, 0) + 1

    if status_counts:
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("**Projekte nach Status**")
            for status, count in sorted(status_counts.items(), key=lambda x: -x[1]):
                prozent = (count / len(projekte) * 100) if projekte else 0
                st.progress(prozent / 100, text=f"{status}: {count} ({prozent:.0f}%)")

        with col2:
            st.markdown("**Aktivit√§ten**")
            # Aktivit√§ten aus Audit-Log z√§hlen
            logs = st.session_state.get('audit_log', [])
            user_logs = [l for l in logs if hasattr(l, 'user_id') and l.user_id == user_id]

            aktionen = {}
            for log in user_logs[-100:]:  # Letzte 100
                if hasattr(log, 'aktion'):
                    aktionen[log.aktion] = aktionen.get(log.aktion, 0) + 1

            if aktionen:
                for aktion, count in sorted(aktionen.items(), key=lambda x: -x[1])[:5]:
                    st.markdown(f"‚Ä¢ {aktion}: **{count}**")
            else:
                st.caption("Keine Aktivit√§ten erfasst.")


# ============================================================================
# DOKUMENTEN-VERSIONIERUNG
# ============================================================================

def erstelle_dokument_version(
    dokument_id: str,
    dateiname: str,
    datei_data: bytes,
    dateityp: str,
    aenderungen: str = "",
    erstellt_von: str = ""
) -> DokumentVersionierung:
    """Erstellt eine neue Dokumentenversion"""
    if 'dokument_versionen' not in st.session_state:
        st.session_state.dokument_versionen = {}

    # H√∂chste Version finden
    bestehende = [v for v in st.session_state.dokument_versionen.values() if v.dokument_id == dokument_id]
    naechste_version = max([v.version_nummer for v in bestehende], default=0) + 1

    version_id = f"version_{dokument_id}_{naechste_version}"

    version = DokumentVersionierung(
        version_id=version_id,
        dokument_id=dokument_id,
        version_nummer=naechste_version,
        dateiname=dateiname,
        datei_data=datei_data,
        dateityp=dateityp,
        dateigroesse=len(datei_data) if datei_data else 0,
        aenderungen=aenderungen,
        erstellt_von=erstellt_von,
        wasserzeichen=True  # Entw√ºrfe haben Wasserzeichen
    )

    st.session_state.dokument_versionen[version_id] = version
    return version


def render_dokument_versionen(dokument_id: str, user_rolle: str):
    """Zeigt alle Versionen eines Dokuments"""
    st.markdown("### üìö Dokumentenversionen")

    versionen = [v for v in st.session_state.get('dokument_versionen', {}).values()
                 if v.dokument_id == dokument_id]
    versionen.sort(key=lambda v: v.version_nummer, reverse=True)

    if not versionen:
        st.info("Keine Versionen vorhanden.")
        return

    for version in versionen:
        ersteller = st.session_state.get('users', {}).get(version.erstellt_von)
        ersteller_name = ersteller.name if ersteller else "Unbekannt"

        status_icons = {
            DokumentVersion.ENTWURF.value: "üìù",
            DokumentVersion.ZUR_PRUEFUNG.value: "üëÅÔ∏è",
            DokumentVersion.FREIGEGEBEN.value: "‚úÖ",
            DokumentVersion.SIGNIERT.value: "‚úçÔ∏è",
            DokumentVersion.ARCHIVIERT.value: "üìÅ"
        }

        icon = status_icons.get(version.status, "üìÑ")

        with st.expander(f"{icon} Version {version.version_nummer} - {version.status}", expanded=version.version_nummer == versionen[0].version_nummer):
            col1, col2 = st.columns([3, 1])

            with col1:
                st.markdown(f"**Datei:** {version.dateiname}")
                st.markdown(f"**Erstellt von:** {ersteller_name}")
                st.markdown(f"**Datum:** {version.erstellt_am.strftime('%d.%m.%Y %H:%M')}")
                if version.aenderungen:
                    st.markdown(f"**√Ñnderungen:** {version.aenderungen}")
                if version.freigegeben_von:
                    freigeber = st.session_state.get('users', {}).get(version.freigegeben_von)
                    st.markdown(f"**Freigegeben von:** {freigeber.name if freigeber else 'Unbekannt'} am {version.freigegeben_am.strftime('%d.%m.%Y')}")

            with col2:
                # Download-Button
                if version.datei_data:
                    st.download_button(
                        "‚¨áÔ∏è Download",
                        data=version.datei_data,
                        file_name=version.dateiname,
                        mime=version.dateityp,
                        key=f"download_{version.version_id}"
                    )

                # Status-Aktionen
                if user_rolle in ["notar", "admin"]:
                    if version.status == DokumentVersion.ENTWURF.value:
                        if st.button("üëÅÔ∏è Zur Pr√ºfung", key=f"review_{version.version_id}"):
                            version.status = DokumentVersion.ZUR_PRUEFUNG.value
                            st.rerun()
                    elif version.status == DokumentVersion.ZUR_PRUEFUNG.value:
                        if st.button("‚úÖ Freigeben", key=f"approve_{version.version_id}"):
                            version.status = DokumentVersion.FREIGEGEBEN.value
                            version.freigegeben_von = st.session_state.current_user.user_id
                            version.freigegeben_am = datetime.now()
                            version.wasserzeichen = False
                            st.rerun()


def render_audit_log(user_id: str, akte_id: str = None, projekt_id: str = None):
    """Zeigt das Aktivit√§tsprotokoll an"""
    st.subheader("üìã Aktivit√§tsprotokoll")

    # Filter
    log_eintraege = st.session_state.audit_log.copy()

    if akte_id:
        log_eintraege = [e for e in log_eintraege if e.akte_id == akte_id]
    if projekt_id:
        log_eintraege = [e for e in log_eintraege if e.projekt_id == projekt_id]

    # Sortieren nach Datum (neueste zuerst)
    log_eintraege.sort(key=lambda e: e.timestamp, reverse=True)

    # Limitieren
    max_eintraege = st.slider("Anzahl Eintr√§ge", 10, 100, 50)
    log_eintraege = log_eintraege[:max_eintraege]

    if log_eintraege:
        st.markdown("| Datum/Zeit | Benutzer | Aktion | Objekt | Details |")
        st.markdown("|------------|----------|--------|--------|---------|")

        for eintrag in log_eintraege:
            st.markdown(f"| {eintrag.timestamp.strftime('%d.%m.%Y %H:%M')} | {eintrag.user_name} | {eintrag.aktion} | {eintrag.objekt_typ}: {eintrag.objekt_name} | {eintrag.details[:50] if eintrag.details else '-'} |")
    else:
        st.info("Keine Aktivit√§ten protokolliert.")


# ============================================================================
# MANDANTEN-PORTAL
# ============================================================================

def render_mandanten_portal(user_id: str, user_rolle: str):
    """Zentrales Mandanten-Portal mit √úbersicht aller relevanten Informationen"""
    st.markdown("## üè† Willkommen im Mandanten-Portal")

    user = st.session_state.users.get(user_id)
    if not user:
        st.error("Benutzer nicht gefunden.")
        return

    st.markdown(f"**Guten Tag, {user.name}!** Hier finden Sie alle wichtigen Informationen zu Ihrer Immobilientransaktion.")

    # Projekte des Mandanten finden
    if user_rolle == UserRole.KAEUFER.value:
        projekte = [p for p in st.session_state.projekte.values() if user_id in p.kaeufer_ids]
        rolle_text = "K√§ufer"
    else:
        projekte = [p for p in st.session_state.projekte.values() if user_id in p.verkaeufer_ids]
        rolle_text = "Verk√§ufer"

    if not projekte:
        st.info("Sie sind noch keinem Projekt zugewiesen. Sobald Sie einem Projekt zugewiesen werden, erscheinen hier alle relevanten Informationen.")
        return

    # ===== SCHNELL√úBERSICHT =====
    st.markdown("### üìä Schnell√ºbersicht")

    # Z√§hler f√ºr verschiedene Bereiche
    eingaenge = st.session_state.get('eingaenge', {})
    ungelesene_eingaenge = len([e for e in eingaenge.values()
                                if e.empfaenger_id == user_id and e.status == EingangStatus.NEU.value])

    fristen = st.session_state.get('fristen', {})
    offene_fristen = []
    for p in projekte:
        projekt_fristen = [f for f in fristen.values()
                          if f.projekt_id == p.projekt_id and f.status == "offen"]
        offene_fristen.extend(projekt_fristen)

    # Anstehende Termine
    termine_count = 0
    for p in projekte:
        projekt_termine = [t for t in st.session_state.termine.values()
                          if t.projekt_id == p.projekt_id and t.status != "abgesagt"]
        termine_count += len(projekt_termine)

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            label="üìÅ Aktive Projekte",
            value=len(projekte)
        )

    with col2:
        st.metric(
            label="üì¨ Ungelesene Nachrichten",
            value=ungelesene_eingaenge,
            delta="Neu" if ungelesene_eingaenge > 0 else None
        )

    with col3:
        st.metric(
            label="‚è∞ Offene Fristen",
            value=len(offene_fristen),
            delta="Achtung" if len(offene_fristen) > 3 else None,
            delta_color="inverse" if len(offene_fristen) > 3 else "normal"
        )

    with col4:
        st.metric(
            label="üìÖ Anstehende Termine",
            value=termine_count
        )

    st.markdown("---")

    # ===== DRINGENDE AUFGABEN =====
    st.markdown("### ‚ö†Ô∏è Dringende Aufgaben")

    dringende_aufgaben = []

    # Ungelesene Eing√§nge
    if ungelesene_eingaenge > 0:
        dringende_aufgaben.append(f"üì¨ **{ungelesene_eingaenge} ungelesene Nachrichten** - Bitte pr√ºfen Sie Ihren Posteingang")

    # Ausweis fehlt?
    personal_key = f"personal_{user_id}"
    if personal_key not in st.session_state:
        dringende_aufgaben.append("ü™™ **Ausweisdaten fehlen** - Bitte laden Sie Ihren Ausweis hoch")

    # Fristen die bald ablaufen
    heute = datetime.now()
    for frist in offene_fristen:
        if frist.faellig_am:
            tage_bis = (frist.faellig_am - heute).days
            if tage_bis <= 3 and tage_bis >= 0:
                dringende_aufgaben.append(f"‚è∞ **Frist '{frist.bezeichnung}'** l√§uft in {tage_bis} Tag(en) ab")

    # Wirtschaftsdaten f√ºr K√§ufer
    if user_rolle == UserRole.KAEUFER.value:
        wirtschaftsdaten = [w for w in st.session_state.wirtschaftsdaten.values() if w.kaeufer_id == user_id]
        if not wirtschaftsdaten:
            dringende_aufgaben.append("üíº **Bonit√§tsnachweise fehlen** - Bitte laden Sie Ihre Unterlagen hoch")

    if dringende_aufgaben:
        for aufgabe in dringende_aufgaben:
            st.warning(aufgabe)
    else:
        st.success("‚úÖ Keine dringenden Aufgaben - Alles im gr√ºnen Bereich!")

    st.markdown("---")

    # ===== PROJEKT-STATUS =====
    st.markdown("### üìÅ Ihre Projekte")

    for projekt in projekte:
        with st.expander(f"üèòÔ∏è **{projekt.name}**", expanded=True):
            col1, col2 = st.columns(2)

            with col1:
                st.markdown(f"**Adresse:** {projekt.adresse or 'Nicht angegeben'}")
                st.markdown(f"**Kaufpreis:** {format_euro(projekt.kaufpreis)} ‚Ç¨" if projekt.kaufpreis > 0 else "**Kaufpreis:** Noch nicht festgelegt")
                st.markdown(f"**Status:** {projekt.status}")
                st.markdown(f"**Ihre Rolle:** {rolle_text}")

            with col2:
                # Fortschrittsanzeige
                gating_status = get_gating_status(projekt.projekt_id)

                st.markdown("**Transaktionsfortschritt:**")
                if gating_status['legal_vollstaendig']:
                    st.success("‚úÖ Rechtliche Pr√ºfung abgeschlossen")
                else:
                    st.warning(f"‚è≥ Rechtliche Pr√ºfung: {gating_status['legal_prozent']}%")

                if gating_status['finanzierung_vollstaendig']:
                    st.success("‚úÖ Finanzierung gesichert")
                else:
                    st.warning(f"‚è≥ Finanzierung: {gating_status['finanzierung_prozent']}%")

            # Beteiligte Parteien
            st.markdown("**Beteiligte Parteien:**")
            col_p1, col_p2, col_p3 = st.columns(3)

            with col_p1:
                if projekt.makler_id:
                    makler = st.session_state.users.get(projekt.makler_id)
                    st.markdown(f"üëî **Makler:** {makler.name if makler else 'Unbekannt'}")

            with col_p2:
                if projekt.notar_id:
                    notar = st.session_state.users.get(projekt.notar_id)
                    st.markdown(f"‚öñÔ∏è **Notar:** {notar.name if notar else 'Unbekannt'}")

            with col_p3:
                for fid in projekt.finanzierer_ids:
                    finanzierer = st.session_state.users.get(fid)
                    if finanzierer:
                        st.markdown(f"üè¶ **Finanzierer:** {finanzierer.name}")

    st.markdown("---")

    # ===== N√ÑCHSTE SCHRITTE =====
    st.markdown("### üéØ N√§chste Schritte")

    naechste_schritte = []

    for projekt in projekte:
        # Pr√ºfe verschiedene Status
        gating_status = get_gating_status(projekt.projekt_id)

        if not gating_status['legal_vollstaendig']:
            naechste_schritte.append({
                'projekt': projekt.name,
                'schritt': "Rechtliche Dokumente akzeptieren",
                'beschreibung': "Bitte pr√ºfen und akzeptieren Sie die erforderlichen rechtlichen Dokumente.",
                'prioritaet': 'hoch'
            })

        if user_rolle == UserRole.KAEUFER.value:
            wirtschaftsdaten = [w for w in st.session_state.wirtschaftsdaten.values()
                               if w.kaeufer_id == user_id and w.kaeufer_id in projekt.kaeufer_ids]
            if not wirtschaftsdaten:
                naechste_schritte.append({
                    'projekt': projekt.name,
                    'schritt': "Bonit√§tsnachweise hochladen",
                    'beschreibung': "Laden Sie Ihre Einkommensnachweise und weitere Bonit√§tsunterlagen hoch.",
                    'prioritaet': 'hoch'
                })

            if not gating_status['finanzierung_vollstaendig']:
                naechste_schritte.append({
                    'projekt': projekt.name,
                    'schritt': "Finanzierung kl√§ren",
                    'beschreibung': "Kontaktieren Sie einen Finanzierer, um Ihre Finanzierung zu sichern.",
                    'prioritaet': 'mittel'
                })

    if naechste_schritte:
        for schritt in naechste_schritte[:5]:  # Max 5 Schritte anzeigen
            prioritaet_icon = "üî¥" if schritt['prioritaet'] == 'hoch' else "üü°" if schritt['prioritaet'] == 'mittel' else "üü¢"
            st.info(f"{prioritaet_icon} **{schritt['schritt']}** ({schritt['projekt']})\n\n{schritt['beschreibung']}")
    else:
        st.success("üéâ Alle wichtigen Schritte wurden erledigt!")

    st.markdown("---")

    # ===== KONTAKT & HILFE =====
    st.markdown("### üìû Kontakt & Hilfe")

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("""
        **Haben Sie Fragen?**

        Nutzen Sie den Tab **Nachrichten**, um direkt mit Ihrem Makler, Notar oder Finanzierer zu kommunizieren.
        """)

    with col2:
        st.markdown("""
        **Wichtige Dokumente**

        Alle Ihre Dokumente finden Sie im Tab **Dokumente**. Dort k√∂nnen Sie auch neue Unterlagen hochladen.
        """)


# ============================================================================
# VORLAGEN-MANAGEMENT SYSTEM
# ============================================================================

@dataclass
class DokumentVorlage:
    """Vorlage f√ºr Dokumente und Textbausteine"""
    vorlage_id: str
    name: str
    kategorie: str  # z.B. "Kaufvertrag", "Brief", "E-Mail"
    beschreibung: str = ""
    inhalt: str = ""
    platzhalter: List[str] = field(default_factory=list)  # z.B. ["{{KAEUFER}}", "{{VERKAEUFER}}"]
    erstellt_von: str = ""
    erstellt_am: datetime = field(default_factory=datetime.now)
    zuletzt_geaendert: datetime = field(default_factory=datetime.now)
    ist_system_vorlage: bool = False


def init_vorlagen_system():
    """Initialisiert das Vorlagen-System mit Standard-Vorlagen"""
    if 'dokument_vorlagen' not in st.session_state:
        st.session_state.dokument_vorlagen = {}

    # System-Vorlagen erstellen, falls nicht vorhanden
    system_vorlagen = [
        DokumentVorlage(
            vorlage_id="sys_1",
            name="Standard Kaufvertrag",
            kategorie="Kaufvertrag",
            beschreibung="Basis-Vorlage f√ºr einen Immobilien-Kaufvertrag",
            inhalt="""KAUFVERTRAG

Zwischen

{{VERKAEUFER_NAME}}, geboren am {{VERKAEUFER_GEBURTSDATUM}}, wohnhaft {{VERKAEUFER_ADRESSE}}
- nachfolgend "Verk√§ufer" genannt -

und

{{KAEUFER_NAME}}, geboren am {{KAEUFER_GEBURTSDATUM}}, wohnhaft {{KAEUFER_ADRESSE}}
- nachfolgend "K√§ufer" genannt -

wird folgender Kaufvertrag geschlossen:

¬ß 1 Kaufgegenstand
Der Verk√§ufer verkauft an den K√§ufer das Grundst√ºck {{ADRESSE}} eingetragen im Grundbuch von {{GRUNDBUCHAMT}}, Blatt {{GRUNDBUCHBLATT}}.

¬ß 2 Kaufpreis
Der Kaufpreis betr√§gt {{KAUFPREIS}} ‚Ç¨ (in Worten: {{KAUFPREIS_WORT}} Euro).

¬ß 3 Zahlung
Der Kaufpreis ist innerhalb von 14 Tagen nach Vorliegen der F√§lligkeitsvoraussetzungen auf das Notaranderkonto zu zahlen.

{{WEITERE_KLAUSELN}}

Ort, Datum: _______________

Unterschrift Verk√§ufer: _______________

Unterschrift K√§ufer: _______________
""",
            platzhalter=["{{VERKAEUFER_NAME}}", "{{VERKAEUFER_GEBURTSDATUM}}", "{{VERKAEUFER_ADRESSE}}",
                        "{{KAEUFER_NAME}}", "{{KAEUFER_GEBURTSDATUM}}", "{{KAEUFER_ADRESSE}}",
                        "{{ADRESSE}}", "{{GRUNDBUCHAMT}}", "{{GRUNDBUCHBLATT}}",
                        "{{KAUFPREIS}}", "{{KAUFPREIS_WORT}}", "{{WEITERE_KLAUSELN}}"],
            ist_system_vorlage=True
        ),
        DokumentVorlage(
            vorlage_id="sys_2",
            name="Terminbest√§tigung",
            kategorie="Brief",
            beschreibung="Best√§tigung eines Beurkundungstermins",
            inhalt="""Sehr geehrte(r) {{EMPFAENGER_NAME}},

hiermit best√§tigen wir Ihnen den Beurkundungstermin:

Datum: {{TERMIN_DATUM}}
Uhrzeit: {{TERMIN_UHRZEIT}}
Ort: {{TERMIN_ORT}}

Betreff: {{PROJEKT_NAME}}

Bitte bringen Sie folgende Unterlagen mit:
- G√ºltigen Personalausweis oder Reisepass
- {{WEITERE_UNTERLAGEN}}

Bei Fragen stehen wir Ihnen gerne zur Verf√ºgung.

Mit freundlichen Gr√º√üen

{{NOTAR_NAME}}
Notar
""",
            platzhalter=["{{EMPFAENGER_NAME}}", "{{TERMIN_DATUM}}", "{{TERMIN_UHRZEIT}}",
                        "{{TERMIN_ORT}}", "{{PROJEKT_NAME}}", "{{WEITERE_UNTERLAGEN}}", "{{NOTAR_NAME}}"],
            ist_system_vorlage=True
        ),
        DokumentVorlage(
            vorlage_id="sys_3",
            name="Unterlagenerinnerung",
            kategorie="E-Mail",
            beschreibung="Erinnerung an fehlende Unterlagen",
            inhalt="""Betreff: Erinnerung: Fehlende Unterlagen f√ºr {{PROJEKT_NAME}}

Sehr geehrte(r) {{EMPFAENGER_NAME}},

in Bezug auf den geplanten Kaufvertrag f√ºr {{PROJEKT_NAME}} fehlen uns noch folgende Unterlagen:

{{FEHLENDE_UNTERLAGEN}}

Bitte √ºbermitteln Sie uns diese Unterlagen bis zum {{FRIST_DATUM}}.

Falls Sie Fragen haben, stehen wir Ihnen gerne zur Verf√ºgung.

Mit freundlichen Gr√º√üen
{{ABSENDER_NAME}}
""",
            platzhalter=["{{PROJEKT_NAME}}", "{{EMPFAENGER_NAME}}", "{{FEHLENDE_UNTERLAGEN}}",
                        "{{FRIST_DATUM}}", "{{ABSENDER_NAME}}"],
            ist_system_vorlage=True
        )
    ]

    for vorlage in system_vorlagen:
        if vorlage.vorlage_id not in st.session_state.dokument_vorlagen:
            st.session_state.dokument_vorlagen[vorlage.vorlage_id] = vorlage


def render_vorlagen_management(user_id: str):
    """Verwaltung von Dokumentenvorlagen"""
    st.subheader("üìã Vorlagen-Management")

    # Initialisierung
    init_vorlagen_system()

    sub_tabs = st.tabs(["üìö Vorlagen-Bibliothek", "‚ûï Neue Vorlage", "‚öôÔ∏è Platzhalter-Hilfe"])

    with sub_tabs[0]:
        render_vorlagen_bibliothek(user_id)

    with sub_tabs[1]:
        render_neue_vorlage(user_id)

    with sub_tabs[2]:
        render_platzhalter_hilfe()


def render_vorlagen_bibliothek(user_id: str):
    """Zeigt alle verf√ºgbaren Vorlagen"""
    st.markdown("### üìö Vorlagen-Bibliothek")

    vorlagen = list(st.session_state.dokument_vorlagen.values())

    # Filter
    kategorien = list(set(v.kategorie for v in vorlagen))
    filter_kategorie = st.selectbox("Kategorie filtern", ["Alle"] + kategorien)

    if filter_kategorie != "Alle":
        vorlagen = [v for v in vorlagen if v.kategorie == filter_kategorie]

    if not vorlagen:
        st.info("Keine Vorlagen gefunden.")
        return

    for vorlage in vorlagen:
        with st.expander(f"{'üîí' if vorlage.ist_system_vorlage else 'üìÑ'} {vorlage.name} ({vorlage.kategorie})"):
            st.markdown(f"**Beschreibung:** {vorlage.beschreibung}")
            st.markdown(f"**Platzhalter:** {', '.join(vorlage.platzhalter) if vorlage.platzhalter else 'Keine'}")

            # Vorschau
            with st.container():
                st.markdown("**Vorschau:**")
                st.code(vorlage.inhalt[:500] + ("..." if len(vorlage.inhalt) > 500 else ""), language=None)

            col1, col2, col3 = st.columns(3)

            with col1:
                if st.button("üìù Verwenden", key=f"use_vorlage_{vorlage.vorlage_id}"):
                    st.session_state.aktive_vorlage = vorlage.vorlage_id
                    st.success("Vorlage ausgew√§hlt! Gehen Sie zum Tab 'Neue Vorlage' um sie anzupassen.")

            with col2:
                if not vorlage.ist_system_vorlage:
                    if st.button("‚úèÔ∏è Bearbeiten", key=f"edit_vorlage_{vorlage.vorlage_id}"):
                        st.session_state.edit_vorlage = vorlage.vorlage_id
                        st.rerun()

            with col3:
                if not vorlage.ist_system_vorlage:
                    if st.button("üóëÔ∏è L√∂schen", key=f"del_vorlage_{vorlage.vorlage_id}"):
                        del st.session_state.dokument_vorlagen[vorlage.vorlage_id]
                        st.success("Vorlage gel√∂scht!")
                        st.rerun()


def render_neue_vorlage(user_id: str):
    """Erstellen einer neuen Vorlage"""
    st.markdown("### ‚ûï Neue Vorlage erstellen")

    # Pr√ºfen ob eine Vorlage bearbeitet wird
    edit_id = st.session_state.get('edit_vorlage')
    vorlage_zum_bearbeiten = None
    if edit_id:
        vorlage_zum_bearbeiten = st.session_state.dokument_vorlagen.get(edit_id)

    with st.form("neue_vorlage_form"):
        name = st.text_input(
            "Vorlagen-Name*",
            value=vorlage_zum_bearbeiten.name if vorlage_zum_bearbeiten else ""
        )

        kategorie = st.selectbox(
            "Kategorie*",
            ["Kaufvertrag", "Brief", "E-Mail", "Checkliste", "Sonstiges"],
            index=["Kaufvertrag", "Brief", "E-Mail", "Checkliste", "Sonstiges"].index(
                vorlage_zum_bearbeiten.kategorie) if vorlage_zum_bearbeiten and vorlage_zum_bearbeiten.kategorie in
                ["Kaufvertrag", "Brief", "E-Mail", "Checkliste", "Sonstiges"] else 0
        )

        beschreibung = st.text_area(
            "Beschreibung",
            value=vorlage_zum_bearbeiten.beschreibung if vorlage_zum_bearbeiten else ""
        )

        inhalt = st.text_area(
            "Vorlagen-Inhalt*",
            height=300,
            value=vorlage_zum_bearbeiten.inhalt if vorlage_zum_bearbeiten else "",
            help="Verwenden Sie {{PLATZHALTER}} f√ºr variable Inhalte"
        )

        # Platzhalter automatisch erkennen
        import re
        gefundene_platzhalter = re.findall(r'\{\{[A-Z_]+\}\}', inhalt)
        if gefundene_platzhalter:
            st.info(f"Erkannte Platzhalter: {', '.join(set(gefundene_platzhalter))}")

        submitted = st.form_submit_button("üíæ Vorlage speichern")

        if submitted:
            if not name or not inhalt:
                st.error("Bitte f√ºllen Sie alle Pflichtfelder aus.")
            else:
                vorlage_id = edit_id if edit_id else str(uuid.uuid4())[:8]

                neue_vorlage = DokumentVorlage(
                    vorlage_id=vorlage_id,
                    name=name,
                    kategorie=kategorie,
                    beschreibung=beschreibung,
                    inhalt=inhalt,
                    platzhalter=list(set(gefundene_platzhalter)),
                    erstellt_von=user_id,
                    ist_system_vorlage=False
                )

                st.session_state.dokument_vorlagen[vorlage_id] = neue_vorlage

                if edit_id:
                    st.session_state.pop('edit_vorlage', None)
                    st.success("Vorlage aktualisiert!")
                else:
                    st.success("Neue Vorlage erstellt!")

                st.rerun()

    if edit_id:
        if st.button("‚ùå Bearbeitung abbrechen"):
            st.session_state.pop('edit_vorlage', None)
            st.rerun()


def render_platzhalter_hilfe():
    """Hilfe zu Platzhaltern"""
    st.markdown("### ‚ÑπÔ∏è Platzhalter-Hilfe")

    st.markdown("""
    Platzhalter werden automatisch durch die tats√§chlichen Werte ersetzt, wenn ein Dokument aus einer Vorlage erstellt wird.

    **Format:** `{{PLATZHALTER_NAME}}`

    **Verf√ºgbare Standard-Platzhalter:**
    """)

    platzhalter_liste = {
        "Personen": [
            ("{{KAEUFER_NAME}}", "Name des K√§ufers"),
            ("{{KAEUFER_GEBURTSDATUM}}", "Geburtsdatum des K√§ufers"),
            ("{{KAEUFER_ADRESSE}}", "Vollst√§ndige Adresse des K√§ufers"),
            ("{{VERKAEUFER_NAME}}", "Name des Verk√§ufers"),
            ("{{VERKAEUFER_GEBURTSDATUM}}", "Geburtsdatum des Verk√§ufers"),
            ("{{VERKAEUFER_ADRESSE}}", "Vollst√§ndige Adresse des Verk√§ufers"),
            ("{{NOTAR_NAME}}", "Name des Notars"),
            ("{{MAKLER_NAME}}", "Name des Maklers"),
        ],
        "Objekt": [
            ("{{ADRESSE}}", "Objektadresse"),
            ("{{KAUFPREIS}}", "Kaufpreis in Euro"),
            ("{{KAUFPREIS_WORT}}", "Kaufpreis in Worten"),
            ("{{GRUNDBUCHAMT}}", "Zust√§ndiges Grundbuchamt"),
            ("{{GRUNDBUCHBLATT}}", "Grundbuchblatt-Nummer"),
            ("{{FLURST√úCK}}", "Flurst√ºcksnummer"),
        ],
        "Termine": [
            ("{{TERMIN_DATUM}}", "Datum des Termins"),
            ("{{TERMIN_UHRZEIT}}", "Uhrzeit des Termins"),
            ("{{TERMIN_ORT}}", "Ort des Termins"),
            ("{{FRIST_DATUM}}", "Fristdatum"),
        ],
        "Allgemein": [
            ("{{PROJEKT_NAME}}", "Name des Projekts"),
            ("{{HEUTE_DATUM}}", "Aktuelles Datum"),
            ("{{EMPFAENGER_NAME}}", "Name des Empf√§ngers"),
            ("{{ABSENDER_NAME}}", "Name des Absenders"),
        ]
    }

    for kategorie, platzhalter in platzhalter_liste.items():
        st.markdown(f"**{kategorie}:**")
        for ph, beschreibung in platzhalter:
            st.markdown(f"- `{ph}` - {beschreibung}")


# ============================================================================
# VERTRAGSVERSIONEN-VERGLEICH (SIDE-BY-SIDE DIFF)
# ============================================================================

def inject_diff_css():
    """CSS f√ºr die Diff-Hervorhebungen"""
    st.markdown("""
    <style>
    /* Diff Container */
    .diff-container {
        display: flex;
        gap: 20px;
        margin: 20px 0;
    }
    .diff-pane {
        flex: 1;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.6;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-height: 600px;
        overflow-y: auto;
    }
    .diff-pane-header {
        font-weight: bold;
        padding: 10px 15px;
        background: #e9ecef;
        border-radius: 8px 8px 0 0;
        margin: -15px -15px 15px -15px;
        border-bottom: 1px solid #dee2e6;
    }

    /* √Ñnderungstypen */
    .diff-added {
        background-color: #ffe0e6 !important;
        padding: 2px 4px;
        border-radius: 3px;
        position: relative;
        cursor: pointer;
    }
    .diff-deleted {
        background-color: #ffd0d6 !important;
        text-decoration: line-through;
        padding: 2px 4px;
        border-radius: 3px;
        position: relative;
        cursor: pointer;
    }
    .diff-changed {
        background-color: #ffccd5 !important;
        padding: 2px 4px;
        border-radius: 3px;
        position: relative;
        cursor: pointer;
    }

    /* Tooltip */
    .diff-tooltip {
        visibility: hidden;
        position: absolute;
        z-index: 1000;
        background: #333;
        color: white;
        padding: 10px 15px;
        border-radius: 6px;
        font-size: 12px;
        white-space: nowrap;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 5px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        font-family: sans-serif;
        text-decoration: none;
    }
    .diff-tooltip::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: #333 transparent transparent transparent;
    }
    .diff-added:hover .diff-tooltip,
    .diff-deleted:hover .diff-tooltip,
    .diff-changed:hover .diff-tooltip {
        visibility: visible;
    }

    /* Legende */
    .diff-legend {
        display: flex;
        gap: 20px;
        margin-bottom: 15px;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 6px;
    }
    .diff-legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
    }
    .legend-added {
        width: 20px;
        height: 16px;
        background: #ffe0e6;
        border-radius: 3px;
    }
    .legend-deleted {
        width: 20px;
        height: 16px;
        background: #ffd0d6;
        border-radius: 3px;
        position: relative;
    }
    .legend-deleted::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 1px;
        background: #666;
    }
    .legend-changed {
        width: 20px;
        height: 16px;
        background: #ffccd5;
        border-radius: 3px;
    }
    </style>
    """, unsafe_allow_html=True)


def berechne_text_diff(alter_text: str, neuer_text: str) -> List[dict]:
    """
    Berechnet die Unterschiede zwischen zwei Texten.
    Verwendet einen einfachen zeilenbasierten Diff-Algorithmus.

    Returns: Liste von Diff-Eintr√§gen mit typ, alter_text, neuer_text
    """
    import difflib

    alter_zeilen = alter_text.splitlines(keepends=True)
    neuer_zeilen = neuer_text.splitlines(keepends=True)

    differ = difflib.SequenceMatcher(None, alter_zeilen, neuer_zeilen)
    diff_ergebnis = []

    for tag, i1, i2, j1, j2 in differ.get_opcodes():
        if tag == 'equal':
            for zeile in alter_zeilen[i1:i2]:
                diff_ergebnis.append({
                    'typ': AenderungsTyp.UNVERAENDERT.value,
                    'alter_text': zeile,
                    'neuer_text': zeile
                })
        elif tag == 'delete':
            for zeile in alter_zeilen[i1:i2]:
                diff_ergebnis.append({
                    'typ': AenderungsTyp.GELOESCHT.value,
                    'alter_text': zeile,
                    'neuer_text': ''
                })
        elif tag == 'insert':
            for zeile in neuer_zeilen[j1:j2]:
                diff_ergebnis.append({
                    'typ': AenderungsTyp.HINZUGEFUEGT.value,
                    'alter_text': '',
                    'neuer_text': zeile
                })
        elif tag == 'replace':
            # Zeilen wurden ge√§ndert
            alte = alter_zeilen[i1:i2]
            neue = neuer_zeilen[j1:j2]
            max_len = max(len(alte), len(neue))
            for idx in range(max_len):
                alt = alte[idx] if idx < len(alte) else ''
                neu = neue[idx] if idx < len(neue) else ''
                if alt and not neu:
                    diff_ergebnis.append({
                        'typ': AenderungsTyp.GELOESCHT.value,
                        'alter_text': alt,
                        'neuer_text': ''
                    })
                elif neu and not alt:
                    diff_ergebnis.append({
                        'typ': AenderungsTyp.HINZUGEFUEGT.value,
                        'alter_text': '',
                        'neuer_text': neu
                    })
                else:
                    diff_ergebnis.append({
                        'typ': AenderungsTyp.GEAENDERT.value,
                        'alter_text': alt,
                        'neuer_text': neu
                    })

    return diff_ergebnis


def berechne_wort_diff(alter_text: str, neuer_text: str) -> List[dict]:
    """
    Berechnet die Unterschiede auf Wort-Ebene f√ºr genauere Hervorhebung.
    """
    import difflib

    alte_woerter = alter_text.split()
    neue_woerter = neuer_text.split()

    differ = difflib.SequenceMatcher(None, alte_woerter, neue_woerter)
    diff_ergebnis = []

    for tag, i1, i2, j1, j2 in differ.get_opcodes():
        if tag == 'equal':
            diff_ergebnis.append({
                'typ': AenderungsTyp.UNVERAENDERT.value,
                'text': ' '.join(alte_woerter[i1:i2])
            })
        elif tag == 'delete':
            diff_ergebnis.append({
                'typ': AenderungsTyp.GELOESCHT.value,
                'text': ' '.join(alte_woerter[i1:i2])
            })
        elif tag == 'insert':
            diff_ergebnis.append({
                'typ': AenderungsTyp.HINZUGEFUEGT.value,
                'text': ' '.join(neue_woerter[j1:j2])
            })
        elif tag == 'replace':
            diff_ergebnis.append({
                'typ': AenderungsTyp.GELOESCHT.value,
                'text': ' '.join(alte_woerter[i1:i2])
            })
            diff_ergebnis.append({
                'typ': AenderungsTyp.HINZUGEFUEGT.value,
                'text': ' '.join(neue_woerter[j1:j2])
            })

    return diff_ergebnis


def erstelle_vertrags_version(
    vertrag_id: str,
    titel: str,
    text_inhalt: str,
    erstellt_von: str,
    aenderungsbeschreibung: str = "",
    basiert_auf_version: str = ""
) -> VertragsVersion:
    """Erstellt eine neue Vertragsversion"""
    if 'vertrags_versionen' not in st.session_state:
        st.session_state.vertrags_versionen = {}

    # H√∂chste Version finden
    bestehende = [v for v in st.session_state.vertrags_versionen.values()
                  if v.vertrag_id == vertrag_id]
    naechste_version = max([v.version_nummer for v in bestehende], default=0) + 1

    version_id = f"vversion_{vertrag_id}_{naechste_version}"

    version = VertragsVersion(
        version_id=version_id,
        vertrag_id=vertrag_id,
        version_nummer=naechste_version,
        titel=titel,
        text_inhalt=text_inhalt,
        erstellt_von=erstellt_von,
        aenderungsbeschreibung=aenderungsbeschreibung,
        basiert_auf_version=basiert_auf_version
    )

    st.session_state.vertrags_versionen[version_id] = version
    return version


def erstelle_text_aenderung(
    version_id: str,
    typ: str,
    alter_text: str,
    neuer_text: str,
    geaendert_von: str,
    grund: str = "",
    referenz_dokument_id: str = "",
    referenz_dokument_typ: str = ""
) -> TextAenderung:
    """Erstellt eine Text√§nderung mit Metadaten"""
    if 'text_aenderungen' not in st.session_state:
        st.session_state.text_aenderungen = {}

    aenderung_id = f"aend_{uuid.uuid4().hex[:8]}"

    aenderung = TextAenderung(
        aenderung_id=aenderung_id,
        version_id=version_id,
        typ=typ,
        alter_text=alter_text,
        neuer_text=neuer_text,
        geaendert_von=geaendert_von,
        grund=grund,
        referenz_dokument_id=referenz_dokument_id,
        referenz_dokument_typ=referenz_dokument_typ
    )

    st.session_state.text_aenderungen[aenderung_id] = aenderung
    return aenderung


def get_aenderung_tooltip_html(
    aenderung_typ: str,
    geaendert_von: str,
    geaendert_am: datetime,
    grund: str = "",
    referenz_dokument_typ: str = "",
    referenz_sichtbar: bool = False
) -> str:
    """Generiert den HTML-Inhalt f√ºr das Tooltip"""
    user = st.session_state.users.get(geaendert_von)
    user_name = user.name if user else "Unbekannt"

    tooltip_parts = [f"<strong>Ge√§ndert von:</strong> {user_name}"]

    if geaendert_am:
        tooltip_parts.append(f"<strong>Am:</strong> {geaendert_am.strftime('%d.%m.%Y %H:%M')}")

    if grund:
        tooltip_parts.append(f"<strong>Grund:</strong> {grund}")

    if referenz_sichtbar and referenz_dokument_typ:
        tooltip_parts.append(f"<strong>Auf Basis von:</strong> {referenz_dokument_typ}")

    return "<br>".join(tooltip_parts)


def render_diff_html(
    alter_text: str,
    neuer_text: str,
    aenderungen_meta: dict = None,
    zeige_referenzen: bool = False
) -> tuple:
    """
    Rendert HTML f√ºr Side-by-Side Diff mit Hervorhebungen.

    Returns: (linke_seite_html, rechte_seite_html)
    """
    import html
    import difflib

    # Zeilenweiser Diff
    alter_zeilen = alter_text.splitlines()
    neuer_zeilen = neuer_text.splitlines()

    differ = difflib.SequenceMatcher(None, alter_zeilen, neuer_zeilen)

    linke_html = []
    rechte_html = []

    for tag, i1, i2, j1, j2 in differ.get_opcodes():
        if tag == 'equal':
            for zeile in alter_zeilen[i1:i2]:
                escaped = html.escape(zeile)
                linke_html.append(escaped)
                rechte_html.append(escaped)
        elif tag == 'delete':
            for zeile in alter_zeilen[i1:i2]:
                escaped = html.escape(zeile)
                tooltip = "Gel√∂schter Text"
                linke_html.append(f'<span class="diff-deleted">{escaped}<span class="diff-tooltip">{tooltip}</span></span>')
                rechte_html.append('<span style="color: #999;">‚Äî</span>')
        elif tag == 'insert':
            for zeile in neuer_zeilen[j1:j2]:
                escaped = html.escape(zeile)
                tooltip = "Hinzugef√ºgter Text"
                linke_html.append('<span style="color: #999;">‚Äî</span>')
                rechte_html.append(f'<span class="diff-added">{escaped}<span class="diff-tooltip">{tooltip}</span></span>')
        elif tag == 'replace':
            alte = alter_zeilen[i1:i2]
            neue = neuer_zeilen[j1:j2]
            max_len = max(len(alte), len(neue))

            for idx in range(max_len):
                if idx < len(alte) and idx < len(neue):
                    # Beide Zeilen existieren - zeige √Ñnderung
                    alt_escaped = html.escape(alte[idx])
                    neu_escaped = html.escape(neue[idx])

                    # Wort-Level Diff f√ºr bessere Hervorhebung
                    wort_diff = berechne_inline_diff(alte[idx], neue[idx])

                    tooltip = "Ge√§nderter Text"
                    linke_html.append(f'<span class="diff-changed">{wort_diff["alt"]}<span class="diff-tooltip">{tooltip}</span></span>')
                    rechte_html.append(f'<span class="diff-changed">{wort_diff["neu"]}<span class="diff-tooltip">{tooltip}</span></span>')
                elif idx < len(alte):
                    # Nur alte Zeile
                    alt_escaped = html.escape(alte[idx])
                    tooltip = "Gel√∂schter Text"
                    linke_html.append(f'<span class="diff-deleted">{alt_escaped}<span class="diff-tooltip">{tooltip}</span></span>')
                    rechte_html.append('<span style="color: #999;">‚Äî</span>')
                else:
                    # Nur neue Zeile
                    neu_escaped = html.escape(neue[idx])
                    tooltip = "Hinzugef√ºgter Text"
                    linke_html.append('<span style="color: #999;">‚Äî</span>')
                    rechte_html.append(f'<span class="diff-added">{neu_escaped}<span class="diff-tooltip">{tooltip}</span></span>')

    return ('\n'.join(linke_html), '\n'.join(rechte_html))


def berechne_inline_diff(alte_zeile: str, neue_zeile: str) -> dict:
    """Berechnet Wort-Level Diff f√ºr eine einzelne Zeile"""
    import html
    import difflib

    alte_woerter = alte_zeile.split()
    neue_woerter = neue_zeile.split()

    differ = difflib.SequenceMatcher(None, alte_woerter, neue_woerter)

    alt_html = []
    neu_html = []

    for tag, i1, i2, j1, j2 in differ.get_opcodes():
        if tag == 'equal':
            text = ' '.join(alte_woerter[i1:i2])
            alt_html.append(html.escape(text))
            neu_html.append(html.escape(text))
        elif tag == 'delete':
            text = ' '.join(alte_woerter[i1:i2])
            alt_html.append(f'<strong style="background:#ffb3c1;">{html.escape(text)}</strong>')
        elif tag == 'insert':
            text = ' '.join(neue_woerter[j1:j2])
            neu_html.append(f'<strong style="background:#ffb3c1;">{html.escape(text)}</strong>')
        elif tag == 'replace':
            alt_text = ' '.join(alte_woerter[i1:i2])
            neu_text = ' '.join(neue_woerter[j1:j2])
            alt_html.append(f'<strong style="background:#ffb3c1;">{html.escape(alt_text)}</strong>')
            neu_html.append(f'<strong style="background:#ffb3c1;">{html.escape(neu_text)}</strong>')

    return {
        'alt': ' '.join(alt_html),
        'neu': ' '.join(neu_html)
    }


def render_vertragsvergleich(
    vertrag_id: str,
    user_id: str,
    user_rolle: str
):
    """Hauptfunktion zum Rendern des Vertragsvergleichs"""
    inject_diff_css()

    st.subheader("üìÑ Vertragsversionen vergleichen")

    # Versionen f√ºr diesen Vertrag laden
    versionen = [v for v in st.session_state.get('vertrags_versionen', {}).values()
                 if v.vertrag_id == vertrag_id]
    versionen.sort(key=lambda v: v.version_nummer, reverse=True)

    if len(versionen) < 1:
        st.info("Noch keine Vertragsversionen vorhanden.")

        # Demo-Daten erstellen Button f√ºr Testzwecke
        if st.button("üìù Demo-Versionen erstellen"):
            _erstelle_demo_vertragsversionen(vertrag_id, user_id)
            st.rerun()
        return

    # Legende anzeigen
    st.markdown("""
    <div class="diff-legend">
        <div class="diff-legend-item">
            <div class="legend-added"></div>
            <span>Hinzugef√ºgt</span>
        </div>
        <div class="diff-legend-item">
            <div class="legend-deleted"></div>
            <span>Gel√∂scht</span>
        </div>
        <div class="diff-legend-item">
            <div class="legend-changed"></div>
            <span>Ge√§ndert</span>
        </div>
    </div>
    """, unsafe_allow_html=True)

    # Version-Auswahl
    col1, col2 = st.columns(2)

    version_optionen = {v.version_id: f"Version {v.version_nummer} - {v.titel} ({v.erstellt_am.strftime('%d.%m.%Y')})"
                       for v in versionen}

    with col1:
        st.markdown("**üìÑ √Ñltere Version (links)**")
        if len(versionen) >= 2:
            default_links = versionen[1].version_id
        else:
            default_links = versionen[0].version_id

        version_links_id = st.selectbox(
            "Version w√§hlen",
            list(version_optionen.keys()),
            format_func=lambda x: version_optionen[x],
            index=list(version_optionen.keys()).index(default_links) if default_links in version_optionen else 0,
            key=f"diff_links_{vertrag_id}"
        )

    with col2:
        st.markdown("**üìÑ Neuere Version (rechts)**")
        version_rechts_id = st.selectbox(
            "Version w√§hlen",
            list(version_optionen.keys()),
            format_func=lambda x: version_optionen[x],
            index=0,
            key=f"diff_rechts_{vertrag_id}"
        )

    if version_links_id == version_rechts_id:
        st.warning("‚ö†Ô∏è Bitte w√§hlen Sie zwei unterschiedliche Versionen zum Vergleichen.")
        return

    version_links = st.session_state.vertrags_versionen.get(version_links_id)
    version_rechts = st.session_state.vertrags_versionen.get(version_rechts_id)

    if not version_links or not version_rechts:
        st.error("Versionen konnten nicht geladen werden.")
        return

    # Notar-Freigabe f√ºr Referenz-Anzeige
    zeige_referenzen = version_rechts.referenz_freigabe_durch_notar
    if user_rolle == UserRole.NOTAR.value:
        zeige_referenzen = True  # Notar sieht immer alles

    # Metadaten anzeigen
    st.markdown("---")
    col_meta1, col_meta2 = st.columns(2)

    with col_meta1:
        ersteller_links = st.session_state.users.get(version_links.erstellt_von)
        st.markdown(f"""
        **Version {version_links.version_nummer}** - {version_links.titel}
        - Erstellt von: {ersteller_links.name if ersteller_links else 'Unbekannt'}
        - Datum: {version_links.erstellt_am.strftime('%d.%m.%Y %H:%M')}
        - Status: {version_links.status}
        """)

    with col_meta2:
        ersteller_rechts = st.session_state.users.get(version_rechts.erstellt_von)
        st.markdown(f"""
        **Version {version_rechts.version_nummer}** - {version_rechts.titel}
        - Erstellt von: {ersteller_rechts.name if ersteller_rechts else 'Unbekannt'}
        - Datum: {version_rechts.erstellt_am.strftime('%d.%m.%Y %H:%M')}
        - Status: {version_rechts.status}
        """)

    if version_rechts.aenderungsbeschreibung:
        st.info(f"üìù **√Ñnderungsbeschreibung:** {version_rechts.aenderungsbeschreibung}")

    st.markdown("---")

    # Side-by-Side Diff rendern
    linke_html, rechte_html = render_diff_html(
        version_links.text_inhalt,
        version_rechts.text_inhalt,
        zeige_referenzen=zeige_referenzen
    )

    # √Ñnderungsstatistik
    diff_stats = berechne_diff_statistik(version_links.text_inhalt, version_rechts.text_inhalt)
    col_stat1, col_stat2, col_stat3 = st.columns(3)
    with col_stat1:
        st.metric("‚ûï Hinzugef√ºgt", f"{diff_stats['hinzugefuegt']} Zeilen")
    with col_stat2:
        st.metric("‚ûñ Gel√∂scht", f"{diff_stats['geloescht']} Zeilen")
    with col_stat3:
        st.metric("‚úèÔ∏è Ge√§ndert", f"{diff_stats['geaendert']} Zeilen")

    st.markdown("---")

    # Side-by-Side Ansicht
    st.markdown(f"""
    <div class="diff-container">
        <div class="diff-pane">
            <div class="diff-pane-header">üìÑ Version {version_links.version_nummer}</div>
            {linke_html}
        </div>
        <div class="diff-pane">
            <div class="diff-pane-header">üìÑ Version {version_rechts.version_nummer}</div>
            {rechte_html}
        </div>
    </div>
    """, unsafe_allow_html=True)

    # Notar-Optionen f√ºr Referenz-Freigabe
    if user_rolle == UserRole.NOTAR.value:
        st.markdown("---")
        st.markdown("### ‚öñÔ∏è Notar-Optionen")

        freigabe_aktuell = version_rechts.referenz_freigabe_durch_notar
        neue_freigabe = st.checkbox(
            "üîì √Ñnderungsreferenzen f√ºr alle Parteien sichtbar machen",
            value=freigabe_aktuell,
            help="Wenn aktiviert, k√∂nnen alle Parteien sehen, auf welches Dokument sich eine √Ñnderung bezieht."
        )

        if neue_freigabe != freigabe_aktuell:
            if st.button("üíæ Freigabe-Einstellung speichern"):
                version_rechts.referenz_freigabe_durch_notar = neue_freigabe
                st.session_state.vertrags_versionen[version_rechts_id] = version_rechts
                st.success("‚úÖ Einstellung gespeichert!")
                st.rerun()


def berechne_diff_statistik(alter_text: str, neuer_text: str) -> dict:
    """Berechnet Statistiken √ºber die Unterschiede"""
    import difflib

    alter_zeilen = alter_text.splitlines()
    neuer_zeilen = neuer_text.splitlines()

    differ = difflib.SequenceMatcher(None, alter_zeilen, neuer_zeilen)

    stats = {
        'hinzugefuegt': 0,
        'geloescht': 0,
        'geaendert': 0,
        'unveraendert': 0
    }

    for tag, i1, i2, j1, j2 in differ.get_opcodes():
        if tag == 'equal':
            stats['unveraendert'] += (i2 - i1)
        elif tag == 'delete':
            stats['geloescht'] += (i2 - i1)
        elif tag == 'insert':
            stats['hinzugefuegt'] += (j2 - j1)
        elif tag == 'replace':
            stats['geaendert'] += max(i2 - i1, j2 - j1)

    return stats


def _erstelle_demo_vertragsversionen(vertrag_id: str, user_id: str):
    """Erstellt Demo-Vertragsversionen f√ºr Testzwecke"""
    # Version 1 - Original
    v1_text = """KAUFVERTRAG

Zwischen

Max Mustermann, geboren am 01.01.1970, wohnhaft Musterstra√üe 1, 12345 Musterstadt
- nachfolgend "Verk√§ufer" genannt -

und

Erika Musterfrau, geboren am 15.05.1985, wohnhaft Beispielweg 10, 54321 Beispielstadt
- nachfolgend "K√§ufer" genannt -

wird folgender Kaufvertrag geschlossen:

¬ß 1 Kaufgegenstand
Der Verk√§ufer verkauft an den K√§ufer das Grundst√ºck Musterstra√üe 5, 12345 Musterstadt,
eingetragen im Grundbuch von Musterstadt, Blatt 1234.

¬ß 2 Kaufpreis
Der Kaufpreis betr√§gt 350.000,00 ‚Ç¨ (in Worten: dreihundertf√ºnfzigtausend Euro).

¬ß 3 Zahlung
Der Kaufpreis ist innerhalb von 14 Tagen nach Vorliegen der F√§lligkeitsvoraussetzungen
auf das Notaranderkonto zu zahlen.

¬ß 4 √úbergabe
Die √úbergabe erfolgt am Tag der vollst√§ndigen Kaufpreiszahlung.
"""

    erstelle_vertrags_version(
        vertrag_id=vertrag_id,
        titel="Erster Entwurf",
        text_inhalt=v1_text,
        erstellt_von=user_id,
        aenderungsbeschreibung="Initialer Vertragsentwurf"
    )

    # Version 2 - Mit √Ñnderungen
    v2_text = """KAUFVERTRAG

Zwischen

Max Mustermann, geboren am 01.01.1970, wohnhaft Musterstra√üe 1, 12345 Musterstadt
- nachfolgend "Verk√§ufer" genannt -

und

Erika Musterfrau, geboren am 15.05.1985, wohnhaft Beispielweg 10, 54321 Beispielstadt
- nachfolgend "K√§ufer" genannt -

wird folgender Kaufvertrag geschlossen:

¬ß 1 Kaufgegenstand
Der Verk√§ufer verkauft an den K√§ufer das Grundst√ºck Musterstra√üe 5, 12345 Musterstadt,
eingetragen im Grundbuch von Musterstadt, Blatt 1234, Flurst√ºck 567/8.

¬ß 2 Kaufpreis
Der Kaufpreis betr√§gt 345.000,00 ‚Ç¨ (in Worten: dreihundertf√ºnfundvierzigtausend Euro).

¬ß 3 Zahlung
Der Kaufpreis ist innerhalb von 21 Tagen nach Vorliegen der F√§lligkeitsvoraussetzungen
auf das Notaranderkonto bei der Musterbank (IBAN: DE12 3456 7890 1234 5678 90) zu zahlen.

¬ß 4 √úbergabe
Die √úbergabe erfolgt am 01.03.2025.

¬ß 5 Gew√§hrleistung
Der Verkauf erfolgt unter Ausschluss jeglicher Gew√§hrleistung f√ºr Sachm√§ngel.
Diese Vereinbarung gilt nicht f√ºr arglistig verschwiegene M√§ngel.
"""

    erstelle_vertrags_version(
        vertrag_id=vertrag_id,
        titel="Zweiter Entwurf nach K√§uferanfrage",
        text_inhalt=v2_text,
        erstellt_von=user_id,
        aenderungsbeschreibung="Kaufpreis angepasst auf K√§uferwunsch, Gew√§hrleistungsklausel hinzugef√ºgt, Zahlungsfrist verl√§ngert"
    )

    st.success("‚úÖ Demo-Versionen wurden erstellt!")


def render_vertragsvergleich_tab(projekt_id: str, user_id: str, user_rolle: str):
    """Tab-Wrapper f√ºr den Vertragsvergleich"""
    st.markdown("### üìë Vertragsversionen vergleichen")
    st.markdown("""
    Hier k√∂nnen Sie verschiedene Versionen des Kaufvertrags nebeneinander vergleichen.
    √Ñnderungen werden farblich hervorgehoben:
    - **Rosa hinterlegt**: Hinzugef√ºgter oder ge√§nderter Text
    - **Durchgestrichen**: Gel√∂schter Text

    Fahren Sie mit dem Cursor √ºber markierte Stellen, um Details zur √Ñnderung zu sehen.
    """)

    render_vertragsvergleich(projekt_id, user_id, user_rolle)


def main():
    """Hauptanwendung"""
    st.set_page_config(
        page_title="Immobilien-Transaktionsplattform",
        page_icon="üè†",
        layout="wide",
        initial_sidebar_state="expanded"
    )

    init_session_state()

    # Responsive Design aktivieren
    inject_responsive_css()
    inject_device_detection()

    # Pr√ºfe auf Makler-Onboarding-Token in URL
    query_params = st.query_params
    if "token" in query_params:
        makler_onboarding_page(query_params["token"])
        return

    if st.session_state.current_user is None:
        login_page()
        return

    # Sidebar
    with st.sidebar:
        st.markdown("### üë§ Angemeldet als:")
        st.write(f"**{st.session_state.current_user.name}**")

        # Unterschiedliche Anzeige f√ºr Mitarbeiter vs normale Benutzer
        if st.session_state.get("is_notar_mitarbeiter", False):
            st.caption(f"Rolle: Notar-Mitarbeiter ({st.session_state.current_user.rolle})")
            st.caption(f"E-Mail: {st.session_state.current_user.email}")
        else:
            st.caption(f"Rolle: {st.session_state.current_user.role}")
            st.caption(f"E-Mail: {st.session_state.current_user.email}")

        if st.button("üö™ Abmelden", use_container_width=True):
            logout()

        # Benachrichtigungen nur f√ºr normale Benutzer (Mitarbeiter haben keine user_id)
        if not st.session_state.get("is_notar_mitarbeiter", False):
            render_notifications()

        st.markdown("---")
        st.markdown("### ‚ÑπÔ∏è System-Info")
        st.caption(f"Benutzer: {len(st.session_state.users)}")
        st.caption(f"Projekte: {len(st.session_state.projekte)}")
        st.caption(f"Angebote: {len(st.session_state.financing_offers)}")

    # Hauptbereich
    # Pr√ºfe ob Mitarbeiter oder normaler Benutzer
    if st.session_state.get("is_notar_mitarbeiter", False):
        notarmitarbeiter_dashboard()
    else:
        role = st.session_state.current_user.role

        if role == UserRole.MAKLER.value:
            makler_dashboard()
        elif role == UserRole.KAEUFER.value:
            kaeufer_dashboard()
        elif role == UserRole.VERKAEUFER.value:
            verkaeufer_dashboard()
        elif role == UserRole.FINANZIERER.value:
            finanzierer_dashboard()
        elif role == UserRole.NOTAR.value:
            notar_dashboard()
        else:
            st.error("Unbekannte Rolle")

if __name__ == "__main__":
    main()
